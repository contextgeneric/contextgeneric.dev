<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
    <title>Context-Generic Programming</title>
    <link rel="self" type="application/atom+xml" href="https://www.contextgeneric.dev/atom.xml"/>
    <link rel="alternate" type="text/html" href="https://www.contextgeneric.dev"/>
    <generator uri="https://www.getzola.org/">Zola</generator>
    <updated>2025-11-03T00:00:00+00:00</updated>
    <id>https://www.contextgeneric.dev/atom.xml</id>
    <entry xml:lang="en">
        <title>Announcing cgp-serde: A modular serialization library for Serde powered by CGP</title>
        <published>2025-11-03T00:00:00+00:00</published>
        <updated>2025-11-03T00:00:00+00:00</updated>
        
        <author>
          <name>
            Soares Chen
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://www.contextgeneric.dev/blog/cgp-serde-release/"/>
        <id>https://www.contextgeneric.dev/blog/cgp-serde-release/</id>
        
        <content type="html" xml:base="https://www.contextgeneric.dev/blog/cgp-serde-release/">&lt;h1 id=&quot;preface&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#preface&quot; aria-label=&quot;Anchor link for: preface&quot;&gt;Preface&lt;&#x2F;a&gt;&lt;&#x2F;h1&gt;
&lt;p&gt;This is a companion blog post for my &lt;a href=&quot;https:&#x2F;&#x2F;rustlab.it&#x2F;talks&#x2F;how-to-stop-fighting-with-coherence-and-start-writing-context-generic-trait-impls&quot;&gt;RustLab presentation&lt;&#x2F;a&gt; titled &lt;strong&gt;How to Stop Fighting with Coherence and Start Writing Context-Generic Trait Impls&lt;&#x2F;strong&gt;.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;overview&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#overview&quot; aria-label=&quot;Anchor link for: overview&quot;&gt;Overview&lt;&#x2F;a&gt;&lt;&#x2F;h1&gt;
&lt;p&gt;I am excited to announce the release of &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;contextgeneric&#x2F;cgp-serde&quot;&gt;&lt;strong&gt;cgp-serde&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;, a modular serialization library for &lt;a href=&quot;https:&#x2F;&#x2F;serde.rs&#x2F;&quot;&gt;Serde&lt;&#x2F;a&gt; that leverages the power of &lt;a href=&quot;&#x2F;&quot;&gt;&lt;strong&gt;Context-Generic Programming&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt; (CGP).&lt;&#x2F;p&gt;
&lt;p&gt;In short, &lt;code&gt;cgp-serde&lt;&#x2F;code&gt; extends Serde’s original &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;serde&#x2F;latest&#x2F;serde&#x2F;trait.Serialize.html&quot;&gt;&lt;code&gt;Serialize&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; and &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;serde&#x2F;latest&#x2F;serde&#x2F;trait.Deserialize.html&quot;&gt;&lt;code&gt;Deserialize&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; traits with CGP, making it possible to write &lt;strong&gt;overlapping&lt;&#x2F;strong&gt; or &lt;strong&gt;orphaned&lt;&#x2F;strong&gt; implementations of these traits and thus bypass the standard Rust &lt;strong&gt;coherence restrictions&lt;&#x2F;strong&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Furthermore, &lt;code&gt;cgp-serde&lt;&#x2F;code&gt; allows us to leverage the powerful &lt;a href=&quot;https:&#x2F;&#x2F;tmandry.gitlab.io&#x2F;blog&#x2F;posts&#x2F;2021-12-21-context-capabilities&#x2F;&quot;&gt;&lt;strong&gt;context and capabilities&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt; concepts in stable Rust today. This unlocks the ability to write context-dependent implementations of &lt;code&gt;Deserialize&lt;&#x2F;code&gt;, such as one that uses an arena allocator to deserialize a &lt;code&gt;&#x27;a T&lt;&#x2F;code&gt; value, a concept detailed in the proposal article.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;quick-intro-to-context-generic-programming&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#quick-intro-to-context-generic-programming&quot; aria-label=&quot;Anchor link for: quick-intro-to-context-generic-programming&quot;&gt;Quick intro to Context-Generic Programming&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;For those readers new to the project, here is a quick introduction: Context-Generic Programming (CGP) is a modular programming paradigm that enables you to bypass the &lt;strong&gt;coherence restrictions&lt;&#x2F;strong&gt; in Rust traits, allowing for &lt;strong&gt;overlapping&lt;&#x2F;strong&gt; and &lt;strong&gt;orphan&lt;&#x2F;strong&gt; implementations of any CGP trait.&lt;&#x2F;p&gt;
&lt;p&gt;You can adapt almost any existing Rust trait to use CGP today by applying the &lt;code&gt;#[cgp_component]&lt;&#x2F;code&gt; macro to the trait definition. After this annotation, you can write &lt;strong&gt;named&lt;&#x2F;strong&gt; implementations of the trait using &lt;code&gt;#[cgp_impl]&lt;&#x2F;code&gt;, which can be defined without being constrained by the coherence rules. You can then selectively enable and reuse the named implementation for your type using the &lt;code&gt;delegate_components!&lt;&#x2F;code&gt; macro.&lt;&#x2F;p&gt;
&lt;p&gt;For instance, we can, in principle, annotate the standard library’s &lt;a href=&quot;https:&#x2F;&#x2F;www.contextgeneric.dev&#x2F;blog&#x2F;cgp-serde-release&#x2F;%5Bhttps:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;hash&#x2F;trait.Hash.html%5D(https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;hash&#x2F;trait.Hash.html)&quot;&gt;&lt;code&gt;Hash&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; trait with &lt;code&gt;#[cgp_component]&lt;&#x2F;code&gt; like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_component(HashProvider)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;Hash { &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;... &lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This change does not affect existing code that uses or implements &lt;code&gt;Hash&lt;&#x2F;code&gt;, but it allows for new, potentially overlapping implementations, such as one that works for any type that also implements &lt;code&gt;Display&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_impl(HashWithDisplay)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;T: Display&amp;gt; HashProvider &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;T { &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;... &lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;You can then apply and reuse this implementation on any type by using the &lt;code&gt;delegate_components!&lt;&#x2F;code&gt; macro:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;MyData { ... }
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;Display &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;MyData { &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;... &lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;delegate_components! {
&lt;&#x2F;span&gt;&lt;span&gt;    MyData {
&lt;&#x2F;span&gt;&lt;span&gt;        HashProviderComponent: HashWithDisplay,
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In this example, &lt;code&gt;MyData&lt;&#x2F;code&gt; implements the &lt;code&gt;Hash&lt;&#x2F;code&gt; trait by using &lt;code&gt;delegate_components!&lt;&#x2F;code&gt; to delegate its implementation to the &lt;code&gt;HashWithDisplay&lt;&#x2F;code&gt; provider, identified by the key &lt;code&gt;HashProviderComponent&lt;&#x2F;code&gt;. Because &lt;code&gt;MyData&lt;&#x2F;code&gt; already implements &lt;code&gt;Display&lt;&#x2F;code&gt;, the &lt;code&gt;Hash&lt;&#x2F;code&gt; trait is now automatically implemented through CGP via this delegation.&lt;&#x2F;p&gt;
&lt;p&gt;If you are eager to learn more about CGP, please check out the &lt;a href=&quot;&#x2F;&quot;&gt;project homepage&lt;&#x2F;a&gt; for all the details. For now, let us return to examine the new features introduced in &lt;code&gt;cgp-serde&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h1 id=&quot;context-generic-serialization-traits&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#context-generic-serialization-traits&quot; aria-label=&quot;Anchor link for: context-generic-serialization-traits&quot;&gt;Context-Generic Serialization Traits&lt;&#x2F;a&gt;&lt;&#x2F;h1&gt;
&lt;p&gt;The key highlight of &lt;code&gt;cgp-serde&lt;&#x2F;code&gt; is its introduction of context-generic versions of the Serde traits. First, the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;serde&#x2F;latest&#x2F;serde&#x2F;trait.Serialize.html&quot;&gt;&lt;code&gt;Serialize&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; trait is redefined as follows:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_component {
&lt;&#x2F;span&gt;&lt;span&gt;    provider: ValueSerializer,
&lt;&#x2F;span&gt;&lt;span&gt;    derive_delegate: UseDelegate&amp;lt;Value&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;CanSerializeValue&amp;lt;Value: ?Sized&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;serialize&amp;lt;S&amp;gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self, value: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;Value, serializer: S) -&amp;gt; Result&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;S::&lt;&#x2F;span&gt;&lt;span&gt;Ok, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;S::&lt;&#x2F;span&gt;&lt;span&gt;Error&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;        S: serde::Serializer;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Compared to the original &lt;code&gt;Serialize&lt;&#x2F;code&gt; trait, &lt;code&gt;cgp-serde&lt;&#x2F;code&gt; provides the &lt;code&gt;CanSerializeValue&lt;&#x2F;code&gt; CGP trait, which moves the original &lt;code&gt;Self&lt;&#x2F;code&gt; type from &lt;code&gt;Serialize&lt;&#x2F;code&gt; to an explicit generic parameter named &lt;code&gt;Value&lt;&#x2F;code&gt;. The &lt;code&gt;Self&lt;&#x2F;code&gt; type in &lt;code&gt;CanSerializeValue&lt;&#x2F;code&gt; now represents a &lt;strong&gt;context&lt;&#x2F;strong&gt; type, which can be used for &lt;strong&gt;dependency injection&lt;&#x2F;strong&gt;. The &lt;code&gt;serialize&lt;&#x2F;code&gt; method also accepts an extra &lt;code&gt;&amp;amp;self&lt;&#x2F;code&gt; value, making it possible to retrieve additional runtime dependencies from this context.&lt;&#x2F;p&gt;
&lt;p&gt;In a similar manner, &lt;code&gt;cgp-serde&lt;&#x2F;code&gt; defines a context-generic version of the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;serde&#x2F;latest&#x2F;serde&#x2F;trait.Deserialize.html&quot;&gt;&lt;code&gt;Deserialize&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; trait as follows:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_component {
&lt;&#x2F;span&gt;&lt;span&gt;    provider: ValueDeserializer,
&lt;&#x2F;span&gt;&lt;span&gt;    derive_delegate: UseDelegate&amp;lt;Value&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;CanDeserializeValue&amp;lt;&amp;#39;de, Value&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;deserialize&amp;lt;D&amp;gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self, deserializer: D) -&amp;gt; Result&amp;lt;Value, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;D::&lt;&#x2F;span&gt;&lt;span&gt;Error&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;        D: serde::Deserializer&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;#39;de&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Analogous to &lt;code&gt;CanSerializeValue&lt;&#x2F;code&gt;, the &lt;code&gt;CanDeserializeValue&lt;&#x2F;code&gt; trait moves the original &lt;code&gt;Self&lt;&#x2F;code&gt; type in &lt;code&gt;Deserialize&lt;&#x2F;code&gt; to become the &lt;code&gt;Value&lt;&#x2F;code&gt; generic parameter. This &lt;code&gt;deserialize&lt;&#x2F;code&gt; method similarly accepts an additional &lt;code&gt;&amp;amp;self&lt;&#x2F;code&gt; value, which can be utilized to supply runtime dependencies, such as an arena allocator.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;provider-traits&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#provider-traits&quot; aria-label=&quot;Anchor link for: provider-traits&quot;&gt;Provider Traits&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;In addition to having the extra &lt;code&gt;Context&lt;&#x2F;code&gt; parameter as the &lt;code&gt;Self&lt;&#x2F;code&gt; type, both &lt;code&gt;CanSerializeValue&lt;&#x2F;code&gt; and &lt;code&gt;CanDeserializeValue&lt;&#x2F;code&gt; are annotated with the &lt;code&gt;#[cgp_component]&lt;&#x2F;code&gt; macro, which is the mechanism that unlocks additional CGP capabilities on these traits.&lt;&#x2F;p&gt;
&lt;p&gt;The &lt;code&gt;provider&lt;&#x2F;code&gt; argument to &lt;code&gt;#[cgp_component]&lt;&#x2F;code&gt; automatically generates the &lt;strong&gt;provider traits&lt;&#x2F;strong&gt; called &lt;code&gt;ValueSerializer&lt;&#x2F;code&gt; and &lt;code&gt;ValueDeserializer&lt;&#x2F;code&gt;. These traits are the ones you will use for implementing &lt;strong&gt;named&lt;&#x2F;strong&gt; serialization implementations that can bypass the coherence restrictions.&lt;&#x2F;p&gt;
&lt;p&gt;Conversely, in CGP, we refer to the original traits &lt;code&gt;CanSerializeValue&lt;&#x2F;code&gt; and &lt;code&gt;CanDeserializeValue&lt;&#x2F;code&gt; as the &lt;strong&gt;consumer traits&lt;&#x2F;strong&gt;. The general rule of thumb is that a CGP component is &lt;strong&gt;used&lt;&#x2F;strong&gt; through its consumer trait but &lt;strong&gt;implemented&lt;&#x2F;strong&gt; using its provider trait.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;usedelegate-provider&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#usedelegate-provider&quot; aria-label=&quot;Anchor link for: usedelegate-provider&quot;&gt;&lt;code&gt;UseDelegate&lt;&#x2F;code&gt; Provider&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Our CGP trait definitions also include a second &lt;code&gt;derive_delegate&lt;&#x2F;code&gt; entry within the &lt;code&gt;#[cgp_component]&lt;&#x2F;code&gt; macro. This entry generates a specialized &lt;code&gt;UseDelegate&lt;&#x2F;code&gt; provider that enables &lt;strong&gt;static dispatch&lt;&#x2F;strong&gt; of provider implementations based on the specific &lt;code&gt;Value&lt;&#x2F;code&gt; type. The practical application and use of &lt;code&gt;UseDelegate&lt;&#x2F;code&gt; will be explained in greater detail later in this article.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h1 id=&quot;overlapping-provider-implementations&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#overlapping-provider-implementations&quot; aria-label=&quot;Anchor link for: overlapping-provider-implementations&quot;&gt;Overlapping Provider Implementations&lt;&#x2F;a&gt;&lt;&#x2F;h1&gt;
&lt;p&gt;Compared to the original Serde definitions of &lt;code&gt;Serialize&lt;&#x2F;code&gt; and &lt;code&gt;Deserialize&lt;&#x2F;code&gt;, the greatest improvement offered by &lt;code&gt;CanSerializeValue&lt;&#x2F;code&gt; and &lt;code&gt;CanDeserializeValue&lt;&#x2F;code&gt; is the ability to define &lt;strong&gt;overlapping&lt;&#x2F;strong&gt; and &lt;strong&gt;orphan&lt;&#x2F;strong&gt; implementations of the trait. Let us now examine a few concrete examples of how this crucial feature works.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;serialize-with-serde&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#serialize-with-serde&quot; aria-label=&quot;Anchor link for: serialize-with-serde&quot;&gt;Serialize with Serde&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;To maintain full backward compatibility with the existing Serde ecosystem, the most straightforward implementation of &lt;code&gt;ValueSerializer&lt;&#x2F;code&gt; utilizes Serde’s own &lt;code&gt;Serialize&lt;&#x2F;code&gt; trait to perform serialization. This is implemented within &lt;code&gt;cgp-serde&lt;&#x2F;code&gt; as shown below:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;UseSerde;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[cgp_impl(UseSerde)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;Context, Value&amp;gt; ValueSerializer&amp;lt;Value&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;Context
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;    Value: Serialize,
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;serialize&amp;lt;S&amp;gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self, value: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;Value, serializer: S) -&amp;gt; Result&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;S::&lt;&#x2F;span&gt;&lt;span&gt;Ok, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;S::&lt;&#x2F;span&gt;&lt;span&gt;Error&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;        S: Serializer,
&lt;&#x2F;span&gt;&lt;span&gt;    {
&lt;&#x2F;span&gt;&lt;span&gt;        value.serialize(serializer)
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;First, we define a unit struct named &lt;code&gt;UseSerde&lt;&#x2F;code&gt;, which acts as the &lt;em&gt;name&lt;&#x2F;em&gt; for our specific provider implementation. We then define a blanket trait implementation annotated with &lt;code&gt;#[cgp_impl]&lt;&#x2F;code&gt;, explicitly setting &lt;code&gt;UseSerde&lt;&#x2F;code&gt; as the provider type.&lt;&#x2F;p&gt;
&lt;p&gt;Following this, we define our implementation on the &lt;code&gt;ValueSerializer&lt;&#x2F;code&gt; provider trait, rather than the &lt;code&gt;CanSerializeValue&lt;&#x2F;code&gt; consumer trait. This implementation is defined to work with any &lt;code&gt;Context&lt;&#x2F;code&gt; and &lt;code&gt;Value&lt;&#x2F;code&gt; types, provided that the target &lt;code&gt;Value&lt;&#x2F;code&gt; implements the original &lt;code&gt;Serialize&lt;&#x2F;code&gt; trait. Inside our &lt;code&gt;serialize&lt;&#x2F;code&gt; implementation, we ignore the &lt;code&gt;&amp;amp;self&lt;&#x2F;code&gt; context and simply call &lt;code&gt;Serialize::serialize&lt;&#x2F;code&gt; on the value.&lt;&#x2F;p&gt;
&lt;p&gt;While this implementation itself is not remarkable, it crucially highlights that &lt;code&gt;cgp-serde&lt;&#x2F;code&gt; is fully compatible with the standard Serde crate. Consequently, if we wish to reuse an existing &lt;code&gt;Serialize&lt;&#x2F;code&gt; implementation for a given value type, we can simply utilize &lt;code&gt;UseSerde&lt;&#x2F;code&gt; to serialize that type through &lt;code&gt;CanSerializeValue&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Another important detail to notice is that our blanket implementation for &lt;code&gt;UseSerde&lt;&#x2F;code&gt; works universally for &lt;em&gt;any&lt;&#x2F;em&gt; &lt;code&gt;Context&lt;&#x2F;code&gt; and &lt;code&gt;Value&lt;&#x2F;code&gt; types satisfying the bounds. As we will soon see, we can define &lt;strong&gt;more than one&lt;&#x2F;strong&gt; such blanket implementation using CGP.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;serialize-with-display&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#serialize-with-display&quot; aria-label=&quot;Anchor link for: serialize-with-display&quot;&gt;Serialize with &lt;code&gt;Display&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Just as we can implement &lt;code&gt;ValueSerializer&lt;&#x2F;code&gt; for any &lt;code&gt;Value&lt;&#x2F;code&gt; type that implements &lt;code&gt;Serialize&lt;&#x2F;code&gt;, we can also implement &lt;code&gt;ValueSerializer&lt;&#x2F;code&gt; for any &lt;code&gt;Value&lt;&#x2F;code&gt; type that implements the &lt;code&gt;Display&lt;&#x2F;code&gt; trait. This alternative behavior is implemented by &lt;code&gt;cgp-serde&lt;&#x2F;code&gt; as follows:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_impl(new SerializeWithDisplay)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;Context, Value&amp;gt; ValueSerializer&amp;lt;Value&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;Context
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;    Context: CanSerializeValue&amp;lt;String&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    Value: Display,
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;serialize&amp;lt;S&amp;gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self, value: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;Value, serializer: S) -&amp;gt; Result&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;S::&lt;&#x2F;span&gt;&lt;span&gt;Ok, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;S::&lt;&#x2F;span&gt;&lt;span&gt;Error&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;        S: Serializer,
&lt;&#x2F;span&gt;&lt;span&gt;    {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; str_value = value.to_string();
&lt;&#x2F;span&gt;&lt;span&gt;        self.serialize(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;str_value, serializer)
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In the very first line, the inclusion of the &lt;code&gt;new&lt;&#x2F;code&gt; keyword in &lt;code&gt;#[cgp_impl]&lt;&#x2F;code&gt; instructs the macro to automatically generate the necessary provider struct definition for us, so that we don&#x27;t have to define them manually:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span&gt;SerializeWithDisplay;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Our blanket implementation for &lt;code&gt;SerializeWithDisplay&lt;&#x2F;code&gt; works with any &lt;code&gt;Value&lt;&#x2F;code&gt; type that implements &lt;code&gt;Display&lt;&#x2F;code&gt;. Crucially, this implementation also requires the &lt;code&gt;Context&lt;&#x2F;code&gt; type to implement &lt;code&gt;CanSerializeValue&amp;lt;String&amp;gt;&lt;&#x2F;code&gt;. This means we use the &lt;code&gt;Context&lt;&#x2F;code&gt; to &lt;em&gt;look up&lt;&#x2F;em&gt; the serialization implementation for &lt;code&gt;String&lt;&#x2F;code&gt; and then employ it within our current provider implementation.&lt;&#x2F;p&gt;
&lt;p&gt;Inside the method body, we first use &lt;code&gt;to_string&lt;&#x2F;code&gt; to convert our value into a standard string, and then we call &lt;code&gt;self.serialize&lt;&#x2F;code&gt; to serialize that string value using the context&#x27;s &lt;code&gt;CanSerializeValue&amp;lt;String&amp;gt;&lt;&#x2F;code&gt; implementation.&lt;&#x2F;p&gt;
&lt;p&gt;To appreciate what is enabled by this implementation, consider how this might be implemented directly on Serde&#x27;s &lt;code&gt;Serialize&lt;&#x2F;code&gt; trait:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;Value&amp;gt; Serialize &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;Value
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;    Value: Display,
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;serialize&amp;lt;S&amp;gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self, serializer: S) -&amp;gt; Result&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;S::&lt;&#x2F;span&gt;&lt;span&gt;Ok, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;S::&lt;&#x2F;span&gt;&lt;span&gt;Error&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;        S: Serializer,
&lt;&#x2F;span&gt;&lt;span&gt;    {
&lt;&#x2F;span&gt;&lt;span&gt;        self.to_string().serialize(serializer)
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;If you have any experience with Rust traits, you will immediately recognize that it is practically impossible to define this blanket &lt;code&gt;Serialize&lt;&#x2F;code&gt; implementation in Serde. More accurately, you are &lt;strong&gt;restricted&lt;&#x2F;strong&gt; to having &lt;strong&gt;at most one&lt;&#x2F;strong&gt; such blanket implementation of &lt;code&gt;Serialize&lt;&#x2F;code&gt;. Because of this restriction, it is extremely difficult to justify why this version, which uses the &lt;code&gt;Value: Display&lt;&#x2F;code&gt; bound, should be the &lt;em&gt;chosen&lt;&#x2F;em&gt; global implementation for &lt;code&gt;Serialize&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;In stark contrast, both &lt;code&gt;UseSerde&lt;&#x2F;code&gt; and &lt;code&gt;SerializeWithDisplay&lt;&#x2F;code&gt; contain &lt;strong&gt;overlapping&lt;&#x2F;strong&gt; implementations of &lt;code&gt;ValueSerializer&lt;&#x2F;code&gt; across &lt;em&gt;both&lt;&#x2F;em&gt; the &lt;code&gt;Context&lt;&#x2F;code&gt; and &lt;code&gt;Value&lt;&#x2F;code&gt; types. In vanilla Rust, this would be outright rejected, as it is perfectly possible, for instance, to have a &lt;code&gt;Value&lt;&#x2F;code&gt; type that implements both &lt;code&gt;Serialize&lt;&#x2F;code&gt; and &lt;code&gt;Display&lt;&#x2F;code&gt;. However, this overlapping is seamlessly enabled in CGP by utilizing the provider trait &lt;code&gt;ValueSerializer&lt;&#x2F;code&gt; and the powerful &lt;code&gt;#[cgp_impl]&lt;&#x2F;code&gt; macro. We will elaborate on the underlying mechanism in later sections.&lt;&#x2F;p&gt;
&lt;p&gt;Regarding the specific use case of string serialization, it might not seem remarkable that we must look up how to serialize &lt;code&gt;String&lt;&#x2F;code&gt; from the context, given that Serde already has an efficient &lt;code&gt;Serialize&lt;&#x2F;code&gt; implementation for &lt;code&gt;String&lt;&#x2F;code&gt;. Nevertheless, this successfully demonstrates the &lt;em&gt;potential&lt;&#x2F;em&gt; to replace the serialization implementation of &lt;code&gt;String&lt;&#x2F;code&gt; with a custom one. We will later see how this override capability is highly useful for serializing &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;&#x2F;code&gt; bytes.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;serialize-bytes&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#serialize-bytes&quot; aria-label=&quot;Anchor link for: serialize-bytes&quot;&gt;Serialize Bytes&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Just as we can serialize any &lt;code&gt;Value&lt;&#x2F;code&gt; that implements &lt;code&gt;Display&lt;&#x2F;code&gt;, we can also define a way to serialize any &lt;code&gt;Value&lt;&#x2F;code&gt; that contains a byte slice directly into bytes. This behavior is implemented by &lt;code&gt;cgp-serde&lt;&#x2F;code&gt; as follows:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_impl(SerializeBytes)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;Context, Value&amp;gt; ValueSerializer&amp;lt;Value&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;Context
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;    Value: AsRef&amp;lt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u8&lt;&#x2F;span&gt;&lt;span&gt;]&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;serialize&amp;lt;S&amp;gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self, value: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;Value, serializer: S) -&amp;gt; Result&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;S::&lt;&#x2F;span&gt;&lt;span&gt;Ok, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;S::&lt;&#x2F;span&gt;&lt;span&gt;Error&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;        S: Serializer,
&lt;&#x2F;span&gt;&lt;span&gt;    {
&lt;&#x2F;span&gt;&lt;span&gt;        serializer.serialize_bytes(value.as_ref())
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Our &lt;code&gt;SerializeBytes&lt;&#x2F;code&gt; provider can successfully work with any &lt;code&gt;Value&lt;&#x2F;code&gt; type that implements &lt;code&gt;AsRef&amp;lt;[u8]&amp;gt;&lt;&#x2F;code&gt;. Crucially, this includes &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;&#x2F;code&gt;, which also implements &lt;code&gt;AsRef&amp;lt;[u8]&amp;gt;&lt;&#x2F;code&gt;. This is significant because, unlike the constraints imposed by the standard &lt;code&gt;Serialize&lt;&#x2F;code&gt; trait, we can now potentially &lt;strong&gt;override&lt;&#x2F;strong&gt; the serialization implementation of &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;&#x2F;code&gt; to explicitly use &lt;code&gt;SerializeBytes&lt;&#x2F;code&gt;, ensuring it is serialized as raw bytes instead of a list of &lt;code&gt;u8&lt;&#x2F;code&gt; values.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;serialize-iterator&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#serialize-iterator&quot; aria-label=&quot;Anchor link for: serialize-iterator&quot;&gt;Serialize Iterator&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Similar to how we implemented &lt;code&gt;SerializeWithDisplay&lt;&#x2F;code&gt;, we can define a &lt;code&gt;SerializeIterator&lt;&#x2F;code&gt; provider that works with any &lt;code&gt;Value&lt;&#x2F;code&gt; type that implements &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;iter&#x2F;trait.IntoIterator.html&quot;&gt;&lt;code&gt;IntoIterator&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_impl(new SerializeIterator)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;Context, Value&amp;gt; ValueSerializer&amp;lt;Value&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;Context
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;#39;a&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;#39;a&lt;&#x2F;span&gt;&lt;span&gt; Value: IntoIterator,
&lt;&#x2F;span&gt;&lt;span&gt;    Context: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;#39;a&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; CanSerializeValue&amp;lt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;#39;a&lt;&#x2F;span&gt;&lt;span&gt; Value &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as &lt;&#x2F;span&gt;&lt;span&gt;IntoIterator&amp;gt;::Item&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;serialize&amp;lt;S&amp;gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self, value: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;Value, serializer: S) -&amp;gt; Result&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;S::&lt;&#x2F;span&gt;&lt;span&gt;Ok, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;S::&lt;&#x2F;span&gt;&lt;span&gt;Error&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;        S: serde::Serializer,
&lt;&#x2F;span&gt;&lt;span&gt;    { &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;... &lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Our implementation includes a &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nomicon&#x2F;hrtb.html&quot;&gt;&lt;em&gt;higher-ranked trait bound&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; (HRTB) &lt;code&gt;for&amp;lt;&#x27;a&amp;gt; &amp;amp;&#x27;a Value: IntoIterator&lt;&#x2F;code&gt;, which permits us to call &lt;code&gt;into_iter&lt;&#x2F;code&gt; on any reference &lt;code&gt;&amp;amp;Value&lt;&#x2F;code&gt;. Likewise, we introduce a HRTB for &lt;code&gt;Context&lt;&#x2F;code&gt; to implement &lt;code&gt;CanSerializeValue&lt;&#x2F;code&gt; for the associated &lt;code&gt;Item&lt;&#x2F;code&gt; type yielded by the iterator produced from &lt;code&gt;&amp;amp;Value&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;We have omitted the method body of &lt;code&gt;SerializeIterator&lt;&#x2F;code&gt; for brevity. Behind the scenes, it utilizes &lt;code&gt;serialize_seq&lt;&#x2F;code&gt; to handle the serialization of each item.&lt;&#x2F;p&gt;
&lt;p&gt;The key takeaway here is that the serialization of the iterator&#x27;s &lt;code&gt;Item&lt;&#x2F;code&gt;s is performed via the consumer trait &lt;code&gt;CanSerializeValue&lt;&#x2F;code&gt; provided by &lt;code&gt;Context&lt;&#x2F;code&gt;. This grants us the ability to deeply customize how the &lt;code&gt;Item&lt;&#x2F;code&gt; itself is serialized, without being restricted to a fixed &lt;code&gt;Serialize&lt;&#x2F;code&gt; implementation.&lt;&#x2F;p&gt;
&lt;p&gt;Another critical observation is that both &lt;code&gt;SerializeBytes&lt;&#x2F;code&gt; and &lt;code&gt;SerializeIterator&lt;&#x2F;code&gt; are inherently &lt;strong&gt;overlapping&lt;&#x2F;strong&gt; on the &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;&#x2F;code&gt; type. This perfectly illustrates how the serialization behavior of &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;&#x2F;code&gt; is determined entirely by which specific provider is wired into a particular CGP context. We will examine this topic further in later sections.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h1 id=&quot;modular-serialization-demo&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#modular-serialization-demo&quot; aria-label=&quot;Anchor link for: modular-serialization-demo&quot;&gt;Modular Serialization Demo&lt;&#x2F;a&gt;&lt;&#x2F;h1&gt;
&lt;p&gt;To fully demonstrate the modular serialization capabilities provided by &lt;code&gt;cgp-serde&lt;&#x2F;code&gt;, we will set up a practical example involving the serialization of encrypted messages. This is where you see the power of CGP in action.&lt;&#x2F;p&gt;
&lt;p&gt;Suppose we are developing a naive encrypted messaging library, defining the following core data types:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[derive(CgpData)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;EncryptedMessage {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;message_id: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u64&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;author_id: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u64&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;date: DateTime&amp;lt;Utc&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;encrypted_data: Vec&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u8&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[derive(CgpData)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;MessagesByTopic {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;encrypted_topic: Vec&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u8&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;messages: Vec&amp;lt;EncryptedMessage&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[derive(CgpData)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;MessagesArchive {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;decryption_key: Vec&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u8&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;messages_by_topics: Vec&amp;lt;MessagesByTopic&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We start with an &lt;code&gt;EncryptedMessage&lt;&#x2F;code&gt; struct containing message metadata and encrypted data. These messages are grouped within a &lt;code&gt;MessagesByTopic&lt;&#x2F;code&gt; struct, which also includes an encrypted topic string. Finally, the &lt;code&gt;MessagesArchive&lt;&#x2F;code&gt; struct holds messages grouped by multiple topics, along with a password-protected decryption key.&lt;&#x2F;p&gt;
&lt;p&gt;The key technical challenge we aim to solve is how to serialize this message archive into different JSON formats, depending on the specific application consuming the data. Specifically, we need to support the following two formats simultaneously:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Application A:&lt;&#x2F;strong&gt; Serializes bytes as hexadecimal strings and dates using the RFC 3339 format.&lt;&#x2F;p&gt;
&lt;details&gt;
  &lt;summary&gt;Click here for example serialization for App A&lt;&#x2F;summary&gt;
&lt;pre data-lang=&quot;json&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-json &quot;&gt;&lt;code class=&quot;language-json&quot; data-lang=&quot;json&quot;&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;decryption_key&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;746f702d736563726574&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;messages_by_topics&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;: [
&lt;&#x2F;span&gt;&lt;span&gt;    {
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;encrypted_topic&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;416c6c2061626f757420434750&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;messages&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;: [
&lt;&#x2F;span&gt;&lt;span&gt;        {
&lt;&#x2F;span&gt;&lt;span&gt;          &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;message_id&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;          &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;author_id&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;          &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;date&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;2025-11-03T14:15:00+00:00&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;          &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;encrypted_data&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;48656c6c6f2066726f6d20527573744c616221&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;        },
&lt;&#x2F;span&gt;&lt;span&gt;        {
&lt;&#x2F;span&gt;&lt;span&gt;          &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;message_id&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;4&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;          &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;author_id&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;8&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;          &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;date&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;2025-12-19T23:45:00+00:00&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;          &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;encrypted_data&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;4f6e65207965617220616e6e697665727361727921&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;      ]
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;  ]
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;details&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Application B:&lt;&#x2F;strong&gt; Serializes bytes as Base64 strings and dates using Unix timestamps.&lt;&#x2F;p&gt;
&lt;details&gt;
  &lt;summary&gt;Click here for example serialization for App B&lt;&#x2F;summary&gt;
&lt;pre data-lang=&quot;json&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-json &quot;&gt;&lt;code class=&quot;language-json&quot; data-lang=&quot;json&quot;&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;decryption_key&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;dG9wLXNlY3JldA==&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;messages_by_topics&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;: [
&lt;&#x2F;span&gt;&lt;span&gt;    {
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;encrypted_topic&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;QWxsIGFib3V0IENHUA==&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;messages&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;: [
&lt;&#x2F;span&gt;&lt;span&gt;        {
&lt;&#x2F;span&gt;&lt;span&gt;          &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;message_id&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;          &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;author_id&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;          &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;date&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1762179300&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;          &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;encrypted_data&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;SGVsbG8gZnJvbSBSdXN0TGFiIQ==&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;        },
&lt;&#x2F;span&gt;&lt;span&gt;        {
&lt;&#x2F;span&gt;&lt;span&gt;          &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;message_id&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;4&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;          &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;author_id&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;8&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;          &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;date&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1766187900&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;          &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;encrypted_data&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;T25lIHllYXIgYW5uaXZlcnNhcnkh&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;      ]
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;  ]
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;details&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;In a real-world scenario, you might have many more applications using your library, and your data types could have numerous fields requiring customization. With the original design of Serde, achieving this deep level of customization across nested data types would be quite challenging. Typically, a type like &lt;code&gt;EncryptedMessage&lt;&#x2F;code&gt; would have a single, fixed &lt;code&gt;Serialize&lt;&#x2F;code&gt; implementation. Even Serde’s powerful &lt;a href=&quot;https:&#x2F;&#x2F;serde.rs&#x2F;remote-derive.html&quot;&gt;remote derive&lt;&#x2F;a&gt; feature would require defining ad-hoc serialization for every data type involved.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;wiring-of-serializer-components&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#wiring-of-serializer-components&quot; aria-label=&quot;Anchor link for: wiring-of-serializer-components&quot;&gt;Wiring of serializer components&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;With &lt;code&gt;cgp-serde&lt;&#x2F;code&gt;, it is straightforward to define custom application contexts that can deeply customize how each field in our data structures is serialized. For instance, we can define an &lt;code&gt;AppA&lt;&#x2F;code&gt; context for Application A like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;AppA;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;delegate_components! {
&lt;&#x2F;span&gt;&lt;span&gt;    AppA {
&lt;&#x2F;span&gt;&lt;span&gt;        ValueSerializerComponent:
&lt;&#x2F;span&gt;&lt;span&gt;            UseDelegate&amp;lt;new SerializerComponentsA &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;                &amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;#39;a&lt;&#x2F;span&gt;&lt;span&gt;, T&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;#39;a&lt;&#x2F;span&gt;&lt;span&gt; T:
&lt;&#x2F;span&gt;&lt;span&gt;                    SerializeDeref,
&lt;&#x2F;span&gt;&lt;span&gt;                [
&lt;&#x2F;span&gt;&lt;span&gt;                    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u64&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;                    String,
&lt;&#x2F;span&gt;&lt;span&gt;                ]:
&lt;&#x2F;span&gt;&lt;span&gt;                    UseSerde,
&lt;&#x2F;span&gt;&lt;span&gt;                Vec&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u8&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;:
&lt;&#x2F;span&gt;&lt;span&gt;                    SerializeHex,
&lt;&#x2F;span&gt;&lt;span&gt;                DateTime&amp;lt;Utc&amp;gt;:
&lt;&#x2F;span&gt;&lt;span&gt;                    SerializeRfc3339Date,
&lt;&#x2F;span&gt;&lt;span&gt;                [
&lt;&#x2F;span&gt;&lt;span&gt;                    Vec&amp;lt;EncryptedMessage&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;                    Vec&amp;lt;MessagesByTopic&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;                ]:
&lt;&#x2F;span&gt;&lt;span&gt;                    SerializeIterator,
&lt;&#x2F;span&gt;&lt;span&gt;                [
&lt;&#x2F;span&gt;&lt;span&gt;                    MessagesArchive,
&lt;&#x2F;span&gt;&lt;span&gt;                    MessagesByTopic,
&lt;&#x2F;span&gt;&lt;span&gt;                    EncryptedMessage,
&lt;&#x2F;span&gt;&lt;span&gt;                ]:
&lt;&#x2F;span&gt;&lt;span&gt;                    SerializeFields,
&lt;&#x2F;span&gt;&lt;span&gt;            }&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In the code above, we use the &lt;code&gt;delegate_components!&lt;&#x2F;code&gt; macro to create effective &lt;strong&gt;type-level lookup tables&lt;&#x2F;strong&gt; that configure the specific provider implementations used by &lt;code&gt;AppA&lt;&#x2F;code&gt;. The &lt;strong&gt;component key&lt;&#x2F;strong&gt;, &lt;code&gt;ValueSerializerComponent&lt;&#x2F;code&gt;, tells the compiler that we are configuring the provider for the &lt;code&gt;CanSerializeValue&lt;&#x2F;code&gt; trait within &lt;code&gt;AppA&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;The value assigned to this entry is &lt;code&gt;UseDelegate&lt;&#x2F;code&gt;, followed by an &lt;em&gt;inner&lt;&#x2F;em&gt; table named &lt;code&gt;SerializerComponentsA&lt;&#x2F;code&gt;. This inner table is used for &lt;strong&gt;static dispatch&lt;&#x2F;strong&gt; of the provider implementation based on the &lt;code&gt;Value&lt;&#x2F;code&gt; type being serialized. For example, the key &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;&#x2F;code&gt; is mapped to the value &lt;code&gt;SerializeHex&lt;&#x2F;code&gt;, indicating that the &lt;code&gt;SerializeHex&lt;&#x2F;code&gt; provider is used whenever &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;&#x2F;code&gt; needs to be serialized.&lt;&#x2F;p&gt;
&lt;p&gt;The &lt;code&gt;delegate_components!&lt;&#x2F;code&gt; macro also includes shorthands for mapping multiple keys to the same value. For instance, both &lt;code&gt;u64&lt;&#x2F;code&gt; and &lt;code&gt;String&lt;&#x2F;code&gt; are dispatched to the generic &lt;code&gt;UseSerde&lt;&#x2F;code&gt; provider, which is neatly grouped using an array syntax. We can also set &lt;strong&gt;generic keys&lt;&#x2F;strong&gt; in the table, such as mapping all &lt;code&gt;&amp;amp;&#x27;a T&lt;&#x2F;code&gt; references to the &lt;code&gt;SerializeDeref&lt;&#x2F;code&gt; provider.&lt;&#x2F;p&gt;
&lt;p&gt;We will cover more details about the mechanics of this type-level lookup table in later sections. For now, let us look at how we implement &lt;code&gt;AppB&lt;&#x2F;code&gt; to perform the serialization required for Application B:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;AppB;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;delegate_components! {
&lt;&#x2F;span&gt;&lt;span&gt;    AppB {
&lt;&#x2F;span&gt;&lt;span&gt;        ValueSerializerComponent:
&lt;&#x2F;span&gt;&lt;span&gt;            UseDelegate&amp;lt;new SerializerComponentsB &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;                &amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;#39;a&lt;&#x2F;span&gt;&lt;span&gt;, T&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;#39;a&lt;&#x2F;span&gt;&lt;span&gt; T:
&lt;&#x2F;span&gt;&lt;span&gt;                    SerializeDeref,
&lt;&#x2F;span&gt;&lt;span&gt;                [
&lt;&#x2F;span&gt;&lt;span&gt;                    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;i64&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;                    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u64&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;                    String,
&lt;&#x2F;span&gt;&lt;span&gt;                ]:
&lt;&#x2F;span&gt;&lt;span&gt;                    UseSerde,
&lt;&#x2F;span&gt;&lt;span&gt;                Vec&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u8&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;:
&lt;&#x2F;span&gt;&lt;span&gt;                    SerializeBase64,
&lt;&#x2F;span&gt;&lt;span&gt;                DateTime&amp;lt;Utc&amp;gt;:
&lt;&#x2F;span&gt;&lt;span&gt;                    SerializeTimestamp,
&lt;&#x2F;span&gt;&lt;span&gt;                [
&lt;&#x2F;span&gt;&lt;span&gt;                    Vec&amp;lt;EncryptedMessage&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;                    Vec&amp;lt;MessagesByTopic&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;                ]:
&lt;&#x2F;span&gt;&lt;span&gt;                    SerializeIterator,
&lt;&#x2F;span&gt;&lt;span&gt;                [
&lt;&#x2F;span&gt;&lt;span&gt;                    MessagesArchive,
&lt;&#x2F;span&gt;&lt;span&gt;                    MessagesByTopic,
&lt;&#x2F;span&gt;&lt;span&gt;                    EncryptedMessage,
&lt;&#x2F;span&gt;&lt;span&gt;                ]:
&lt;&#x2F;span&gt;&lt;span&gt;                    SerializeFields,
&lt;&#x2F;span&gt;&lt;span&gt;            }&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;If we meticulously compare the &lt;code&gt;delegate_components!&lt;&#x2F;code&gt; entries in both &lt;code&gt;AppA&lt;&#x2F;code&gt; and &lt;code&gt;AppB&lt;&#x2F;code&gt;, we discover that the only substantive differences are in the following entries:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;The serialization for &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;&#x2F;code&gt; is handled by &lt;code&gt;SerializeHex&lt;&#x2F;code&gt; in &lt;code&gt;AppA&lt;&#x2F;code&gt;, but is switched to &lt;code&gt;SerializeBase64&lt;&#x2F;code&gt; in &lt;code&gt;AppB&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;The serialization for &lt;code&gt;DateTime&amp;lt;Utc&amp;gt;&lt;&#x2F;code&gt; is handled by &lt;code&gt;SerializeRfc3339Date&lt;&#x2F;code&gt; in &lt;code&gt;AppA&lt;&#x2F;code&gt;, but is replaced by &lt;code&gt;SerializeTimestamp&lt;&#x2F;code&gt; in &lt;code&gt;AppB&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;An additional serialization entry for &lt;code&gt;i64&lt;&#x2F;code&gt; is included for &lt;code&gt;AppB&lt;&#x2F;code&gt; to specifically handle the serialization of Unix timestamps in &lt;code&gt;i64&lt;&#x2F;code&gt; format.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;As we can clearly observe, changing the serialization format only required a &lt;strong&gt;few lines of configuration changes&lt;&#x2F;strong&gt; in the wiring. This dramatically demonstrates the flexibility of CGP to make application implementations highly configurable and easily adaptable.&lt;&#x2F;p&gt;
&lt;p&gt;In practice, there are further CGP patterns available for &lt;code&gt;AppA&lt;&#x2F;code&gt; and &lt;code&gt;AppB&lt;&#x2F;code&gt; to share their &lt;em&gt;common&lt;&#x2F;em&gt; &lt;code&gt;delegate_components!&lt;&#x2F;code&gt; entries through a powerful &lt;strong&gt;preset&lt;&#x2F;strong&gt; mechanism. However, we will omit those details here for brevity.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;serialization-with-serde-json&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#serialization-with-serde-json&quot; aria-label=&quot;Anchor link for: serialization-with-serde-json&quot;&gt;Serialization with &lt;code&gt;serde_json&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;A key feature of &lt;code&gt;cgp-serde&lt;&#x2F;code&gt; is its continued &lt;strong&gt;backward compatibility&lt;&#x2F;strong&gt; with the existing Serde ecosystem. This means we can effortlessly reuse established libraries like &lt;code&gt;serde_json&lt;&#x2F;code&gt; to serialize our encrypted message archive payloads into JSON.&lt;&#x2F;p&gt;
&lt;p&gt;However, since &lt;code&gt;serde_json&lt;&#x2F;code&gt; strictly operates on types that implement the original &lt;code&gt;Serialize&lt;&#x2F;code&gt; trait, &lt;code&gt;cgp-serde&lt;&#x2F;code&gt; provides the &lt;code&gt;SerializeWithContext&lt;&#x2F;code&gt; wrapper. This wrapper wraps the value to be serialized together with the application context, providing a context-aware implementation of &lt;code&gt;Serialize&lt;&#x2F;code&gt;. Using it, we can serialize our data to JSON like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; app_a = AppA { &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;... &lt;&#x2F;span&gt;&lt;span&gt;};
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; archive = MessagesArchive { &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;... &lt;&#x2F;span&gt;&lt;span&gt;};
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; serialized_a = serde_json::to_string(
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;SerializeWithContext::new(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;app_a, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;archive)
&lt;&#x2F;span&gt;&lt;span&gt;).unwrap()
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We first use &lt;code&gt;SerializeWithContext::new&lt;&#x2F;code&gt; to wrap the application context and the target value together. We then pass this wrapper to &lt;code&gt;serde_json::to_string&lt;&#x2F;code&gt;, which accepts &lt;code&gt;SerializeWithContext&lt;&#x2F;code&gt; because it provides a wrapped &lt;code&gt;Serialize&lt;&#x2F;code&gt; implementation.&lt;&#x2F;p&gt;
&lt;p&gt;Similarly, we can generate the entirely different JSON output simply by using &lt;code&gt;AppB&lt;&#x2F;code&gt; as the application context:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; app_b = AppB { &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;... &lt;&#x2F;span&gt;&lt;span&gt;};
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; serialized_b = serde_json::to_string(
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;SerializeWithContext::new(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;app_b, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;archive)
&lt;&#x2F;span&gt;&lt;span&gt;).unwrap()
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;As illustrated, &lt;code&gt;cgp-serde&lt;&#x2F;code&gt; makes it remarkably easy to customize the serialization of &lt;em&gt;any&lt;&#x2F;em&gt; field, regardless of how deeply it is nested within other data types. By merely changing the application context, we are able to generate JSON output in fundamentally different formats with minimal effort.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;derive-free-serialization-with-derive-cgpdata&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#derive-free-serialization-with-derive-cgpdata&quot; aria-label=&quot;Anchor link for: derive-free-serialization-with-derive-cgpdata&quot;&gt;Derive-free serialization with &lt;code&gt;#[derive(CgpData)]&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Beyond the deep customization we have just explored, another critical feature to highlight is that there is virtually no need to use derive macros to generate any serialization-specific implementation for custom data types. If you look back at the definition of types like &lt;code&gt;EncryptedMessage&lt;&#x2F;code&gt;, you will notice that it only uses the general &lt;code&gt;#[derive(CgpData)]&lt;&#x2F;code&gt; macro provided by the base CGP library.&lt;&#x2F;p&gt;
&lt;p&gt;Behind the scenes, &lt;code&gt;#[derive(CgpData)]&lt;&#x2F;code&gt; generates the necessary support traits for &lt;a href=&quot;https:&#x2F;&#x2F;contextgeneric.dev&#x2F;blog&#x2F;extensible-datatypes-part-1&#x2F;&quot;&gt;extensible data types&lt;&#x2F;a&gt;, which enables our data types to naturally work with CGP traits like &lt;code&gt;CanSerializeValue&lt;&#x2F;code&gt; without requiring library-specific derivation. This is made possible, because CGP enables &lt;code&gt;cgp-serde&lt;&#x2F;code&gt; to implement a generic &lt;code&gt;SerializeFields&lt;&#x2F;code&gt; provider that can work with any struct that derives &lt;code&gt;CgpData&lt;&#x2F;code&gt;, without being restricted by the overlapping constraints.&lt;&#x2F;p&gt;
&lt;p&gt;This mechanism shows how &lt;code&gt;cgp-serde&lt;&#x2F;code&gt; fundamentally solves the orphan implementation problem: it avoids requiring library authors to derive library-specific implementations on their data types at all. For instance, our encrypted messaging library does not even need to include &lt;code&gt;cgp-serde&lt;&#x2F;code&gt; or &lt;code&gt;serde&lt;&#x2F;code&gt; as a dependency. As long as the library uses the base &lt;code&gt;cgp&lt;&#x2F;code&gt; crate to derive &lt;code&gt;CgpData&lt;&#x2F;code&gt;, we can serialize its data types using the &lt;code&gt;SerializeFields&lt;&#x2F;code&gt; provider.&lt;&#x2F;p&gt;
&lt;p&gt;Furthermore, the use of extensible data types applies not only to the traits in &lt;code&gt;cgp-serde&lt;&#x2F;code&gt;. A general derivation of &lt;code&gt;CgpData&lt;&#x2F;code&gt; will automatically enable the library’s data types to work with &lt;em&gt;other&lt;&#x2F;em&gt; CGP traits in the same way they work with &lt;code&gt;cgp-serde&lt;&#x2F;code&gt;. Because of this universal applicability, CGP can shield library authors from endless external requests to apply derive macros for every popular trait on their data types, simply to work around the archaic orphan rules in Rust.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;full-example&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#full-example&quot; aria-label=&quot;Anchor link for: full-example&quot;&gt;Full Example&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;The complete working example of this customized serialization is available on &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;contextgeneric&#x2F;cgp-serde&#x2F;blob&#x2F;main&#x2F;crates&#x2F;cgp-serde-tests&#x2F;src&#x2F;tests&#x2F;messages.rs&quot;&gt;GitHub&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h1 id=&quot;capabilities-enabled-deserialization-demo&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#capabilities-enabled-deserialization-demo&quot; aria-label=&quot;Anchor link for: capabilities-enabled-deserialization-demo&quot;&gt;Capabilities-Enabled Deserialization Demo&lt;&#x2F;a&gt;&lt;&#x2F;h1&gt;
&lt;p&gt;Now that we have demonstrated how &lt;code&gt;cgp-serde&lt;&#x2F;code&gt; enables highly modular serialization, let us turn our attention to how it unlocks new use cases for deserialization. Specifically, we will show how &lt;code&gt;cgp-serde&lt;&#x2F;code&gt; enables the use case explained in the &lt;a href=&quot;https:&#x2F;&#x2F;tmandry.gitlab.io&#x2F;blog&#x2F;posts&#x2F;2021-12-21-context-capabilities&#x2F;&quot;&gt;&lt;strong&gt;context and capabilities&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt; proposal. We will demonstrate implementing a deserializer for the borrowed type &lt;code&gt;&amp;amp;&#x27;a T&lt;&#x2F;code&gt; using an arena allocator that is retrieved via &lt;strong&gt;dependency injection&lt;&#x2F;strong&gt; from the context itself.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;coordinate-arena&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#coordinate-arena&quot; aria-label=&quot;Anchor link for: coordinate-arena&quot;&gt;Coordinate Arena&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;To illustrate the use of an arena deserializer, let us devise an example application: storing a massive quantity of 3D coordinates, perhaps for rendering complex 3D graphics. We can define our basic coordinate structure as follows:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[derive(CgpData)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;Coord {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;x: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u64&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;y: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u64&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;z: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u64&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In this demo, the &lt;code&gt;Coord&lt;&#x2F;code&gt; struct is minimal, but imagine its actual size is much larger. If we were to use &lt;code&gt;Box&amp;lt;Coord&amp;gt;&lt;&#x2F;code&gt; to allocate every coordinate on the heap, the frequent calls to &lt;code&gt;Box::new(coord)&lt;&#x2F;code&gt; could lead to severe memory pressure and fragmentation. Instead, we want to employ an &lt;a href=&quot;https:&#x2F;&#x2F;manishearth.github.io&#x2F;blog&#x2F;2021&#x2F;03&#x2F;15&#x2F;arenas-in-rust&#x2F;&quot;&gt;&lt;strong&gt;arena allocator&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt; to allocate all coordinates into a single, fixed memory region. This setup allows all coordinates to be easily deallocated with a single operation when the function scope exits.&lt;&#x2F;p&gt;
&lt;p&gt;When using arena allocators, our base coordinate value will be &lt;code&gt;&amp;amp;&#x27;a Coord&lt;&#x2F;code&gt;, a borrowed type with a specific lifetime. We can then store these borrowed coordinates in other data structures, such as a cluster:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[derive(CgpData)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;Cluster&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;#39;a&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;id: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u64&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;coords: Vec&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;#39;a&lt;&#x2F;span&gt;&lt;span&gt; Coord&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;With our data structures defined, a major challenge emerges: how do we deserialize a cluster of coordinates from a format like JSON and ensure the coordinates are allocated using a custom arena allocator provided by us?&lt;&#x2F;p&gt;
&lt;h2 id=&quot;arena-deserializer&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#arena-deserializer&quot; aria-label=&quot;Anchor link for: arena-deserializer&quot;&gt;Arena Deserializer&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;To tackle the arena allocator use case, we will utilize the popular &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;typed-arena&#x2F;latest&#x2F;typed_arena&#x2F;&quot;&gt;&lt;code&gt;typed-arena&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; crate, specifically leveraging its &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;typed-arena&#x2F;latest&#x2F;typed_arena&#x2F;struct.Arena.html&quot;&gt;&lt;code&gt;Arena&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; type for memory allocation.&lt;&#x2F;p&gt;
&lt;p&gt;First, we define an &lt;em&gt;auto getter&lt;&#x2F;em&gt; trait to retrieve an &lt;code&gt;Arena&lt;&#x2F;code&gt; from our context:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_auto_getter]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;HasArena&amp;lt;&amp;#39;a, T: &amp;#39;a&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;arena(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;amp;&amp;#39;a &lt;&#x2F;span&gt;&lt;span&gt;Arena&amp;lt;T&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;HasArena&lt;&#x2F;code&gt; trait is automatically implemented for any &lt;code&gt;Context&lt;&#x2F;code&gt; type, provided it derives &lt;code&gt;HasField&lt;&#x2F;code&gt; and contains an &lt;code&gt;arena&lt;&#x2F;code&gt; field of the type &lt;code&gt;&amp;amp;&#x27;a Arena&amp;lt;T&amp;gt;&lt;&#x2F;code&gt;. The nested reference (&lt;code&gt;&amp;amp;&amp;amp;&#x27;a&lt;&#x2F;code&gt;) is required here, since &lt;code&gt;#[cgp_auto_getter]&lt;&#x2F;code&gt; by default returns a reference to a field value in the context, but our field value itself is an explicit reference &lt;code&gt;&amp;amp;&#x27;a Arena&amp;lt;T&amp;gt;&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Next, we leverage &lt;code&gt;HasArena&lt;&#x2F;code&gt; to retrieve the arena allocator from a generic context within our &lt;code&gt;ValueDeserializer&lt;&#x2F;code&gt; implementation:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_impl(new DeserializeAndAllocate)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;#39;de&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;#39;a&lt;&#x2F;span&gt;&lt;span&gt;, Context, Value&amp;gt; ValueDeserializer&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;#39;de&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;#39;a&lt;&#x2F;span&gt;&lt;span&gt; Value&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;Context
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;    Context: HasArena&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;#39;a&lt;&#x2F;span&gt;&lt;span&gt;, Value&amp;gt; + CanDeserializeValue&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;#39;de&lt;&#x2F;span&gt;&lt;span&gt;, Value&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;deserialize&amp;lt;D&amp;gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self, deserializer: D) -&amp;gt; Result&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;#39;a&lt;&#x2F;span&gt;&lt;span&gt; Value, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;D::&lt;&#x2F;span&gt;&lt;span&gt;Error&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;        D: serde::Deserializer&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;#39;de&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; owned_value = self.deserialize(deserializer)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;?&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; borrowed_value = self.arena().alloc(owned_value);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        Ok(borrowed_value)
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We define a new provider, &lt;code&gt;DeserializeAndAllocate&lt;&#x2F;code&gt;, which implements &lt;code&gt;ValueDeserializer&lt;&#x2F;code&gt; specifically for the borrowed &lt;code&gt;&amp;amp;&#x27;a Value&lt;&#x2F;code&gt; type. To support this, it requires the &lt;code&gt;Context&lt;&#x2F;code&gt; to implement &lt;code&gt;HasArena&amp;lt;&#x27;a, Value&amp;gt;&lt;&#x2F;code&gt; to get the allocator &lt;code&gt;&amp;amp;&#x27;a Arena&lt;&#x2F;code&gt;. Additionally, it also requires &lt;code&gt;Context&lt;&#x2F;code&gt; to implement &lt;code&gt;CanDeserializeValue&lt;&#x2F;code&gt; for the &lt;em&gt;owned&lt;&#x2F;em&gt; &lt;code&gt;Value&lt;&#x2F;code&gt; type, to perform the initial deserialization on the stack before moving it into the arena.&lt;&#x2F;p&gt;
&lt;p&gt;Inside the method body, we first use the context to deserialize an owned version of the value on the stack. We then call &lt;code&gt;self.arena()&lt;&#x2F;code&gt; to retrieve the arena allocator and use its &lt;code&gt;alloc&lt;&#x2F;code&gt; method to move and allocate the value onto the arena.&lt;&#x2F;p&gt;
&lt;p&gt;As you can see, with the generalized dependency injection capability provided by CGP, we are able to retrieve any necessary value or type from the context during deserialization. This effectively allows us to emulate the &lt;code&gt;with&lt;&#x2F;code&gt; clause in the seminal &lt;a href=&quot;https:&#x2F;&#x2F;tmandry.gitlab.io&#x2F;blog&#x2F;posts&#x2F;2021-12-21-context-capabilities&#x2F;&quot;&gt;Context and Capabilities&lt;&#x2F;a&gt; proposal and provide any required capability during the deserialization process.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;deserialization-context&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#deserialization-context&quot; aria-label=&quot;Anchor link for: deserialization-context&quot;&gt;Deserialization Context&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Using &lt;code&gt;cgp-serde&lt;&#x2F;code&gt;, defining a deserializer context that includes an arena allocator is refreshingly straightforward. We begin by defining the context structure as follows:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[derive(HasField)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;App&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;#39;a&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;arena: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;#39;a &lt;&#x2F;span&gt;&lt;span&gt;Arena&amp;lt;Coord&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Our &lt;code&gt;App&lt;&#x2F;code&gt; context is explicitly parameterized by a lifetime &lt;code&gt;&#x27;a&lt;&#x2F;code&gt;. It contains an &lt;code&gt;arena&lt;&#x2F;code&gt; field that holds a reference to an &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;typed-arena&#x2F;latest&#x2F;typed_arena&#x2F;struct.Arena.html&quot;&gt;&lt;code&gt;Arena&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; that lives for the duration of &lt;code&gt;&#x27;a&lt;&#x2F;code&gt;, and is specialized for the object type &lt;code&gt;Coord&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;The explicit lifetime &lt;code&gt;&#x27;a&lt;&#x2F;code&gt; is necessary here because the &lt;code&gt;alloc&lt;&#x2F;code&gt; method returns a &lt;code&gt;&amp;amp;&#x27;a Coord&lt;&#x2F;code&gt; value that shares this same lifetime. By being explicit, we accurately inform the Rust compiler that the allocated coordinates will live exactly as long as &lt;code&gt;&#x27;a&lt;&#x2F;code&gt;, which may outlive &lt;code&gt;App&lt;&#x2F;code&gt; itself.&lt;&#x2F;p&gt;
&lt;p&gt;We also derive &lt;code&gt;HasField&lt;&#x2F;code&gt; on &lt;code&gt;App&lt;&#x2F;code&gt;, which enables &lt;code&gt;App&lt;&#x2F;code&gt; to automatically implement &lt;code&gt;HasArena&amp;lt;&#x27;a, Coord&amp;gt;&lt;&#x2F;code&gt;. This is made possible, because the &lt;code&gt;arena&lt;&#x2F;code&gt; field in &lt;code&gt;App&lt;&#x2F;code&gt; matches the format expected by the blanket implementation generated by &lt;code&gt;#[cgp_auto_getter]&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;With the &lt;code&gt;App&lt;&#x2F;code&gt; context defined, let us examine the component wiring for the &lt;code&gt;ValueDeserializer&lt;&#x2F;code&gt; providers:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;delegate_components! {
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;#39;s&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; App&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;#39;s&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;        ValueDeserializerComponent:
&lt;&#x2F;span&gt;&lt;span&gt;            UseDelegate&amp;lt;new DeserializeComponents &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u64&lt;&#x2F;span&gt;&lt;span&gt;: UseSerde,
&lt;&#x2F;span&gt;&lt;span&gt;                [
&lt;&#x2F;span&gt;&lt;span&gt;                    Coord,
&lt;&#x2F;span&gt;&lt;span&gt;                    &amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;#39;a&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; Cluster&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;#39;a&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;                ]:
&lt;&#x2F;span&gt;&lt;span&gt;                    DeserializeRecordFields,
&lt;&#x2F;span&gt;&lt;span&gt;                &amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;#39;a&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;#39;a&lt;&#x2F;span&gt;&lt;span&gt; Coord:
&lt;&#x2F;span&gt;&lt;span&gt;                    DeserializeAndAllocate,
&lt;&#x2F;span&gt;&lt;span&gt;                &amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;#39;a&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; Vec&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;#39;a&lt;&#x2F;span&gt;&lt;span&gt; Coord&amp;gt;:
&lt;&#x2F;span&gt;&lt;span&gt;                    DeserializeExtend,
&lt;&#x2F;span&gt;&lt;span&gt;            }&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        ErrorTypeProviderComponent:
&lt;&#x2F;span&gt;&lt;span&gt;            UseAnyhowError,
&lt;&#x2F;span&gt;&lt;span&gt;        ErrorRaiserComponent:
&lt;&#x2F;span&gt;&lt;span&gt;            RaiseAnyhowError,
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Similar to the serialization lookup tables, here we are configuring the &lt;code&gt;ValueDeserializer&lt;&#x2F;code&gt; providers for &lt;code&gt;App&lt;&#x2F;code&gt; via the &lt;code&gt;ValueDeserializerComponent&lt;&#x2F;code&gt; key and the &lt;code&gt;UseDelegate&lt;&#x2F;code&gt; dispatcher. Notice that this table contains several keys with generic lifetimes, &lt;code&gt;&amp;lt;&#x27;a&amp;gt;&lt;&#x2F;code&gt;, reflecting the use of structs with explicit lifetimes.&lt;&#x2F;p&gt;
&lt;p&gt;As evident in the table, for the value types &lt;code&gt;Coord&lt;&#x2F;code&gt; and &lt;code&gt;Cluster&amp;lt;&#x27;a&amp;gt;&lt;&#x2F;code&gt;, we use a special provider called &lt;code&gt;DeserializeRecordFields&lt;&#x2F;code&gt; to deserialize the structs using the &lt;strong&gt;extensible data types&lt;&#x2F;strong&gt; facility derived from &lt;code&gt;#[derive(CgpData)]&lt;&#x2F;code&gt;. Crucially, for &lt;code&gt;&amp;amp;&#x27;a Coord&lt;&#x2F;code&gt;, we select the &lt;code&gt;DeserializeAndAllocate&lt;&#x2F;code&gt; provider we defined earlier.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;error-handling&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#error-handling&quot; aria-label=&quot;Anchor link for: error-handling&quot;&gt;Error Handling&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Besides the &lt;code&gt;ValueDeserializerComponent&lt;&#x2F;code&gt;, our &lt;code&gt;App&lt;&#x2F;code&gt; context is also configured with &lt;strong&gt;error handling&lt;&#x2F;strong&gt; components provided by CGP. This is essential because we plan to use &lt;code&gt;serde_json&lt;&#x2F;code&gt; to deserialize the value, which may naturally return errors.&lt;&#x2F;p&gt;
&lt;p&gt;For simplicity, we choose to use the &lt;code&gt;cgp-error-anyhow&lt;&#x2F;code&gt; crate to handle errors using the highly flexible &lt;a href=&quot;https:&#x2F;&#x2F;crates.io&#x2F;crates&#x2F;anyhow&quot;&gt;&lt;code&gt;anyhow&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; crate. In the entry for &lt;code&gt;ErrorTypeProviderComponent&lt;&#x2F;code&gt;, we use the &lt;code&gt;UseAnyhowError&lt;&#x2F;code&gt; provider to select the type &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;anyhow&#x2F;latest&#x2F;anyhow&#x2F;struct.Error.html&quot;&gt;&lt;code&gt;anyhow::Error&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; as the primary error type for &lt;code&gt;App&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Subsequently, in the entry for &lt;code&gt;ErrorRaiserComponent&lt;&#x2F;code&gt;, we use &lt;code&gt;RaiseAnyhowError&lt;&#x2F;code&gt; to correctly promote source errors, like &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;serde_json&#x2F;latest&#x2F;serde_json&#x2F;struct.Error.html&quot;&gt;&lt;code&gt;serde_json::Error&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;, into &lt;code&gt;anyhow::Error&lt;&#x2F;code&gt; using its standard &lt;code&gt;From&lt;&#x2F;code&gt; implementation.&lt;&#x2F;p&gt;
&lt;p&gt;This clearly demonstrates the flexibility afforded by CGP in error handling: the concrete error type is chosen by the application context, and it can also customize how each source error is gracefully handled.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;deserializing-json&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#deserializing-json&quot; aria-label=&quot;Anchor link for: deserializing-json&quot;&gt;Deserializing JSON&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Now that the component wiring for &lt;code&gt;App&lt;&#x2F;code&gt; is complete, let us attempt to use &lt;code&gt;serde_json&lt;&#x2F;code&gt; to deserialize a JSON string. First, we create a mock JSON string representing a cluster of coordinates:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; serialized = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;r&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;#&amp;quot;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;    &amp;quot;id&amp;quot;: 8,
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;    &amp;quot;coords&amp;quot;: [
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;        { &amp;quot;x&amp;quot;: 1, &amp;quot;y&amp;quot;: 2, &amp;quot;z&amp;quot;: 3 },
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;        { &amp;quot;x&amp;quot;: 4, &amp;quot;y&amp;quot;: 5, &amp;quot;z&amp;quot;: 6 }
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;    ]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;#&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Next, we instantiate our arena and the application context:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; arena = Arena::new();
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; app = App { arena: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;arena };
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In the case of deserialization, there is a minor complication: we cannot directly use the simple &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;serde_json&#x2F;latest&#x2F;serde_json&#x2F;fn.from_str.html&quot;&gt;&lt;code&gt;serde_json::from_str&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; with our &lt;code&gt;App&lt;&#x2F;code&gt; context. This is because unlike serialization, &lt;code&gt;serde_json::from_str&lt;&#x2F;code&gt; doesn&#x27;t accept additional parameters that we can use to &quot;pass&quot; around the &lt;code&gt;app&lt;&#x2F;code&gt; value. Instead, &lt;code&gt;cgp-serde&lt;&#x2F;code&gt; works with the lower-level &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;serde_json&#x2F;latest&#x2F;serde_json&#x2F;de&#x2F;struct.Deserializer.html&quot;&gt;&lt;code&gt;Deserializer&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; implementation in &lt;code&gt;serde_json&lt;&#x2F;code&gt;, allowing us to pass &lt;code&gt;serde_json&lt;&#x2F;code&gt;&#x27;s deserializer directly to the &lt;code&gt;CanDeserializeValue::deserialize&lt;&#x2F;code&gt; method, together with the &lt;code&gt;app&lt;&#x2F;code&gt; context.&lt;&#x2F;p&gt;
&lt;p&gt;Fortunately, these low-level implementation details are neatly abstracted away by &lt;code&gt;cgp-serde&lt;&#x2F;code&gt;, and all we need to do is call the convenient &lt;code&gt;deserialize_json_string&lt;&#x2F;code&gt; method on our &lt;code&gt;App&lt;&#x2F;code&gt; context:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; deserialized: Cluster&amp;lt;&amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;_&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; = app
&lt;&#x2F;span&gt;&lt;span&gt;    .deserialize_json_string(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;serialized)
&lt;&#x2F;span&gt;&lt;span&gt;    .unwrap();
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;As we can see, we have successfully utilized the custom arena allocator provided by our &lt;code&gt;App&lt;&#x2F;code&gt; context to perform the deserialization, resulting in a borrowed &lt;code&gt;Cluster&lt;&#x2F;code&gt; where the coordinates live in the arena.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;full-example-1&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#full-example-1&quot; aria-label=&quot;Anchor link for: full-example-1&quot;&gt;Full Example&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;The full working example of the arena allocator deserialization is available on &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;contextgeneric&#x2F;cgp-serde&#x2F;blob&#x2F;main&#x2F;crates&#x2F;cgp-serde-tests&#x2F;src&#x2F;tests&#x2F;arena_simplified.rs&quot;&gt;GitHub&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h1 id=&quot;implementation-details&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#implementation-details&quot; aria-label=&quot;Anchor link for: implementation-details&quot;&gt;Implementation Details&lt;&#x2F;a&gt;&lt;&#x2F;h1&gt;
&lt;p&gt;In this section, we will delve into the underlying implementation details of CGP that make the impressive level of modularity in &lt;code&gt;cgp-serde&lt;&#x2F;code&gt; possible. For audiences who are new to Context-Generic Programming, this is your chance to quickly grasp the essential concepts of CGP required to confidently use &lt;code&gt;cgp-serde&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;provider-traits-1&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#provider-traits-1&quot; aria-label=&quot;Anchor link for: provider-traits-1&quot;&gt;Provider Traits&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;When the &lt;code&gt;#[cgp_component]&lt;&#x2F;code&gt; macro is applied to a consumer trait, such as &lt;code&gt;CanSerializeValue&lt;&#x2F;code&gt;, it automatically generates a companion &lt;strong&gt;provider trait&lt;&#x2F;strong&gt; called &lt;code&gt;ValueSerializer&lt;&#x2F;code&gt;. This generated trait looks like the following:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;ValueSerializer&amp;lt;Context, Value: ?Sized&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;serialize&amp;lt;S&amp;gt;(
&lt;&#x2F;span&gt;&lt;span&gt;        context: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;Context,
&lt;&#x2F;span&gt;&lt;span&gt;        value: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;Value,
&lt;&#x2F;span&gt;&lt;span&gt;        serializer: S,
&lt;&#x2F;span&gt;&lt;span&gt;    ) -&amp;gt; Result&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;S::&lt;&#x2F;span&gt;&lt;span&gt;Ok, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;S::&lt;&#x2F;span&gt;&lt;span&gt;Error&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;        S: serde::Serializer;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Compared to the consumer trait &lt;code&gt;CanSerializeValue&lt;&#x2F;code&gt;, the provider trait &lt;code&gt;ValueSerializer&lt;&#x2F;code&gt; shifts the original &lt;code&gt;Self&lt;&#x2F;code&gt; type into a new &lt;code&gt;Context&lt;&#x2F;code&gt; generic parameter. Consequently, all references to &lt;code&gt;self&lt;&#x2F;code&gt; and &lt;code&gt;Self&lt;&#x2F;code&gt; are appropriately replaced with &lt;code&gt;context&lt;&#x2F;code&gt; and &lt;code&gt;Context&lt;&#x2F;code&gt;. The &lt;code&gt;Self&lt;&#x2F;code&gt; type in a provider trait is instead used as the &lt;strong&gt;provider name&lt;&#x2F;strong&gt;, which are the unique, dummy structs - like &lt;code&gt;UseSerde&lt;&#x2F;code&gt; or &lt;code&gt;SerializeHex&lt;&#x2F;code&gt; - that are defined and owned by the library module. This is the core trick: CGP circumvents Rust’s coherence restrictions by guaranteeing that we always own a unique provider type when implementing a provider trait.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;desugaring-of-cgp-impl&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#desugaring-of-cgp-impl&quot; aria-label=&quot;Anchor link for: desugaring-of-cgp-impl&quot;&gt;Desugaring of &lt;code&gt;#[cgp_impl]&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;The ability to define overlapping provider implementations, such as &lt;code&gt;UseSerde&lt;&#x2F;code&gt; and &lt;code&gt;SerializeWithDisplay&lt;&#x2F;code&gt;, is achieved through the clever use of the &lt;code&gt;ValueSerializer&lt;&#x2F;code&gt; provider trait. While these implementations look like forbidden blanket implementations, a provider implementation like &lt;code&gt;SerializeWithDisplay&lt;&#x2F;code&gt; is actually &lt;strong&gt;desugared&lt;&#x2F;strong&gt; by the &lt;code&gt;#[cgp_impl]&lt;&#x2F;code&gt; macro into this form:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;Context, Value&amp;gt; ValueSerializer&amp;lt;Context, Value&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;SerializeWithDisplay
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;    Context: CanSerializeValue&amp;lt;String&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    Value: Display,
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;serialize&amp;lt;S&amp;gt;(
&lt;&#x2F;span&gt;&lt;span&gt;        context: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;Context,
&lt;&#x2F;span&gt;&lt;span&gt;        value: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;Value,
&lt;&#x2F;span&gt;&lt;span&gt;        serializer: S,
&lt;&#x2F;span&gt;&lt;span&gt;    ) -&amp;gt; Result&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;S::&lt;&#x2F;span&gt;&lt;span&gt;Ok, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;S::&lt;&#x2F;span&gt;&lt;span&gt;Error&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;        S: Serializer,
&lt;&#x2F;span&gt;&lt;span&gt;    {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; str_value = value.to_string();
&lt;&#x2F;span&gt;&lt;span&gt;        context.serialize(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;str_value, serializer)
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;As clearly shown, &lt;code&gt;#[cgp_impl]&lt;&#x2F;code&gt; shifts the &lt;code&gt;Context&lt;&#x2F;code&gt; parameter away from the &lt;code&gt;Self&lt;&#x2F;code&gt; position to become the first generic parameter of &lt;code&gt;ValueSerializer&lt;&#x2F;code&gt;. The &lt;code&gt;Self&lt;&#x2F;code&gt; type for the implementation instead becomes &lt;code&gt;SerializeWithDisplay&lt;&#x2F;code&gt;, the unique dummy struct that we defined. Because the implementing library owns &lt;code&gt;SerializeWithDisplay&lt;&#x2F;code&gt;, the Rust compiler permits the trait implementation even if it is otherwise overlapping on the &lt;code&gt;Context&lt;&#x2F;code&gt; and &lt;code&gt;Value&lt;&#x2F;code&gt; types. This is the central mechanism that allows CGP to define both overlapping and orphan implementations. Next, we will examine how these provider implementations are statically &lt;em&gt;wired&lt;&#x2F;em&gt; to a concrete application context.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;type-level-lookup-tables&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#type-level-lookup-tables&quot; aria-label=&quot;Anchor link for: type-level-lookup-tables&quot;&gt;Type-Level Lookup Tables&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;In the &lt;a href=&quot;https:&#x2F;&#x2F;www.contextgeneric.dev&#x2F;blog&#x2F;cgp-serde-release&#x2F;#wiring-of-serializer-components&quot;&gt;serialization example&lt;&#x2F;a&gt; for &lt;code&gt;AppA&lt;&#x2F;code&gt;, when the &lt;code&gt;delegate_components!&lt;&#x2F;code&gt; macro is invoked, it is conceptually equivalent to building a &lt;strong&gt;type-level lookup table&lt;&#x2F;strong&gt; for that context. This table effectively configures the dispatch mechanism at compile time:&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Name&lt;&#x2F;th&gt;&lt;th&gt;Value&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;ValueSerializerComponent&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;UseDelegate&amp;lt;SerializerComponentsA&amp;gt;&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;In the example, the type-level table for &lt;code&gt;AppA&lt;&#x2F;code&gt; only contains one entry, with &lt;code&gt;ValueSerializerComponent&lt;&#x2F;code&gt; as the key. This entry is used by the &lt;code&gt;CanSerializeValue&lt;&#x2F;code&gt; trait to look up for the provider implementation.&lt;&#x2F;p&gt;
&lt;p&gt;In the entry value, the use of the &lt;code&gt;new SerializerComponentsA { ... }&lt;&#x2F;code&gt; constructs an &lt;strong&gt;inner table&lt;&#x2F;strong&gt;, &lt;code&gt;SerializerComponentsA&lt;&#x2F;code&gt;, which holds further mapping of providers based on the serialization value type:&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Name&lt;&#x2F;th&gt;&lt;th&gt;Value&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;&amp;amp;&#x27;a T&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;SerializeDeref&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;u64&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;UseSerde&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;String&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;UseSerde&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;SerializeHex&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;DateTime&amp;lt;Utc&amp;gt;&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;SerializeRfc3339Date&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;Vec&amp;lt;EncryptedMessage&amp;gt;&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;SerializeIterator&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;Vec&amp;lt;MessagesByTopic&amp;gt;&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;SerializeIterator&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;MessagesArchive&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;SerializeFields&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;MessagesByTopic&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;SerializeFields&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;EncryptedMessage&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;SerializeFields&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;This table is passed as the &lt;code&gt;SerializerComponentsA&lt;&#x2F;code&gt; type to &lt;code&gt;UseDelegate&lt;&#x2F;code&gt;, which performs the actual dispatch based on the value type.&lt;&#x2F;p&gt;
&lt;p&gt;When the trait system must look up an implementation, such as for serializing &lt;code&gt;Vec&amp;lt;EncryptedMessage&amp;gt;&lt;&#x2F;code&gt;, it follows a precise, recursive path:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;The system begins by checking if &lt;code&gt;AppA&lt;&#x2F;code&gt; implements &lt;code&gt;CanSerializeValue&amp;lt;Vec&amp;lt;EncryptedMessage&amp;gt;&amp;gt;&lt;&#x2F;code&gt;. This requires looking up the &lt;code&gt;ValueSerializerComponent&lt;&#x2F;code&gt; key in the &lt;code&gt;AppA&lt;&#x2F;code&gt; table.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;AppA&lt;&#x2F;code&gt;&#x27;s table returns &lt;code&gt;UseDelegate&amp;lt;SerializerComponentsA&amp;gt;&lt;&#x2F;code&gt;. This value must now implement &lt;code&gt;ValueSerializer&amp;lt;AppA, Vec&amp;lt;EncryptedMessage&amp;gt;&amp;gt;&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;UseDelegate&lt;&#x2F;code&gt; implements &lt;code&gt;ValueSerializer&lt;&#x2F;code&gt; by performing a secondary lookup on the &lt;code&gt;SerializerComponentsA&lt;&#x2F;code&gt; table, using &lt;code&gt;Vec&amp;lt;EncryptedMessage&amp;gt;&lt;&#x2F;code&gt; as the key.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;SerializerComponentsA&lt;&#x2F;code&gt; returns the value &lt;code&gt;SerializeIterator&lt;&#x2F;code&gt;. This means &lt;code&gt;SerializeIterator&lt;&#x2F;code&gt; must now implement &lt;code&gt;ValueSerializer&amp;lt;AppA, Vec&amp;lt;EncryptedMessage&amp;gt;&amp;gt;&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;For &lt;code&gt;SerializeIterator&lt;&#x2F;code&gt; to satisfy this requirement, it requests a new constraint: that &lt;code&gt;AppA&lt;&#x2F;code&gt; must implement &lt;code&gt;CanSerializeValue&amp;lt;EncryptedMessage&amp;gt;&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;The entire lookup process is repeated from the beginning for the inner type, &lt;code&gt;EncryptedMessage&lt;&#x2F;code&gt;, until it eventually points to the concrete provider &lt;code&gt;SerializeFields&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;This table lookup process, while seem complicated, works conceptually similarly to how &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Virtual_method_table&quot;&gt;vtable lookups&lt;&#x2F;a&gt; are performed for &lt;a href=&quot;https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=pNA-XAIrDTk&quot;&gt;&lt;code&gt;dyn&lt;&#x2F;code&gt; traits in Rust&lt;&#x2F;a&gt; and in object-oriented languages like Java. The fundamental difference, and a major selling point, is that CGP’s lookup tables are fully implemented at the &lt;strong&gt;type level&lt;&#x2F;strong&gt;. This means the tables are resolved entirely at compile time, resulting in &lt;strong&gt;zero runtime overhead&lt;&#x2F;strong&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;implementation-of-lookup-tables&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#implementation-of-lookup-tables&quot; aria-label=&quot;Anchor link for: implementation-of-lookup-tables&quot;&gt;Implementation of Lookup Tables&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Behind the scenes, the &lt;code&gt;delegate_components!&lt;&#x2F;code&gt; macro constructs these type-level lookup tables using the &lt;code&gt;DelegateComponent&lt;&#x2F;code&gt; trait, which is defined by the base &lt;code&gt;cgp&lt;&#x2F;code&gt; crate as follows:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;DelegateComponent&amp;lt;Name: ?Sized&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Delegate&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In essence, &lt;code&gt;DelegateComponent&lt;&#x2F;code&gt; allows any type to serve as a table. By implementing the trait, we effectively set a &quot;value&quot; (&lt;code&gt;Delegate&lt;&#x2F;code&gt;) for a specific &quot;key&quot; (&lt;code&gt;Name&lt;&#x2F;code&gt;) in that table. For instance, the &lt;code&gt;ValueSerializerComponent&lt;&#x2F;code&gt; entry in &lt;code&gt;AppA&lt;&#x2F;code&gt; is set through this implementation:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;DelegateComponent&amp;lt;ValueSerializerComponent&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;AppA {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Delegate &lt;&#x2F;span&gt;&lt;span&gt;= UseDelegate&amp;lt;SerializerComponentsA&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Similarly, the &lt;code&gt;Vec&amp;lt;EncryptedMessage&amp;gt;&lt;&#x2F;code&gt; entry in the &lt;code&gt;SerializerComponentsA&lt;&#x2F;code&gt; table is defined through the following implementation:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;DelegateComponent&amp;lt;Vec&amp;lt;EncryptedMessage&amp;gt;&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;SerializerComponentsA {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Delegate &lt;&#x2F;span&gt;&lt;span&gt;= SerializeIterator;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;CGP then generates essential &lt;strong&gt;blanket implementations&lt;&#x2F;strong&gt; on the consumer and provider traits. These implementations utilize the &lt;code&gt;DelegateComponent&lt;&#x2F;code&gt; entries to resolve the correct provider implementation at compile time.&lt;&#x2F;p&gt;
&lt;p&gt;For example, the initial lookup mechanism for the consumer trait &lt;code&gt;CanSerializeValue&lt;&#x2F;code&gt; is implemented via this blanket implementation:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;Context, Value: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;?&lt;&#x2F;span&gt;&lt;span&gt;Sized&amp;gt; CanSerializeValue&amp;lt;Value&amp;gt; for Context
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;    Context: DelegateComponent&amp;lt;ValueSerializerComponent&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Context::&lt;&#x2F;span&gt;&lt;span&gt;Delegate: ValueSerializer&amp;lt;Context, Value&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;serialize&amp;lt;S&amp;gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self, value: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;Value, serializer: S) -&amp;gt; Result&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;S::&lt;&#x2F;span&gt;&lt;span&gt;Ok, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;S::&lt;&#x2F;span&gt;&lt;span&gt;Error&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;        S: serde::Serializer,
&lt;&#x2F;span&gt;&lt;span&gt;    {
&lt;&#x2F;span&gt;&lt;span&gt;        Context::Delegate::serialize(self, value, serializer)
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The consumer trait &lt;code&gt;CanSerializeValue&lt;&#x2F;code&gt; is thus implemented for a context like &lt;code&gt;AppA&lt;&#x2F;code&gt; if &lt;code&gt;AppA&lt;&#x2F;code&gt; contains a lookup table entry where &lt;code&gt;ValueSerializerComponent&lt;&#x2F;code&gt; is the key and the resulting &lt;code&gt;Delegate&lt;&#x2F;code&gt; &quot;value&quot; successfully implements &lt;code&gt;ValueSerializer&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Similarly, a blanket implementation is generated for &lt;code&gt;ValueSerializer&lt;&#x2F;code&gt; as follows:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_impl(Provider)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;Context, Value: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;?&lt;&#x2F;span&gt;&lt;span&gt;Sized, Provider&amp;gt; ValueSerializer&amp;lt;Value&amp;gt; for Context
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;    Provider: DelegateComponent&amp;lt;ValueSerializerComponent&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Provider::&lt;&#x2F;span&gt;&lt;span&gt;Delegate: ValueSerializer&amp;lt;Context, Value&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;serialize&amp;lt;S&amp;gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self, value: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;Value, serializer: S) -&amp;gt; Result&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;S::&lt;&#x2F;span&gt;&lt;span&gt;Ok, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;S::&lt;&#x2F;span&gt;&lt;span&gt;Error&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;        S: serde::Serializer,
&lt;&#x2F;span&gt;&lt;span&gt;    {
&lt;&#x2F;span&gt;&lt;span&gt;        Provider::Delegate::serialize(self, value, serializer)
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The blanket implementation above looks almost identical as before, except that the delegation lookup is done on the &lt;code&gt;Provider&lt;&#x2F;code&gt; type. This essentially allows a provider to delegate its provider implementation to &lt;em&gt;another&lt;&#x2F;em&gt; provider.&lt;&#x2F;p&gt;
&lt;p&gt;Following that, the special provider &lt;code&gt;UseDelegate&lt;&#x2F;code&gt; has the following blanket implementation:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_impl(UseDelegate&amp;lt;Components&amp;gt;)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;Context, Value&amp;gt; ValueSerializer&amp;lt;Value&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;Context
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;    Components: DelegateComponent&amp;lt;Value&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Components::&lt;&#x2F;span&gt;&lt;span&gt;Delegate: ValueSerializer&amp;lt;Context, Value&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;serialize&amp;lt;S&amp;gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self, value: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;Value, serializer: S) -&amp;gt; Result&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;S::&lt;&#x2F;span&gt;&lt;span&gt;Ok, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;S::&lt;&#x2F;span&gt;&lt;span&gt;Error&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;        S: serde::Serializer,
&lt;&#x2F;span&gt;&lt;span&gt;    {
&lt;&#x2F;span&gt;&lt;span&gt;        Components::Delegate::serialize(self, value, serializer)
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This implementation shows that &lt;code&gt;UseDelegate&lt;&#x2F;code&gt; uses the &lt;code&gt;Value&lt;&#x2F;code&gt; type as the lookup &quot;key&quot; in a given components table, such as &lt;code&gt;SerializerComponentsA&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;If we carefully compare the three versions of the blanket implementations, we would observe that the key differences lie in which type is used as the type-level lookup table, and which type is used as the key for the lookup.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h1 id=&quot;future-work&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#future-work&quot; aria-label=&quot;Anchor link for: future-work&quot;&gt;Future Work&lt;&#x2F;a&gt;&lt;&#x2F;h1&gt;
&lt;p&gt;The initial release of &lt;code&gt;cgp-serde&lt;&#x2F;code&gt; serves as a compelling proof of concept, demonstrating how CGP can be used to solve the coherence problem in Rust. While you can certainly begin experimenting with &lt;code&gt;cgp-serde&lt;&#x2F;code&gt; today for modular serialization in your applications, there are still a few rough edges that need polishing before it reaches the quality level suitable for mission-critical production use.&lt;&#x2F;p&gt;
&lt;p&gt;This section highlights the areas we plan to address, and what you might want to wait for before fully committing to &lt;code&gt;cgp-serde&lt;&#x2F;code&gt; for your main projects.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;serialization-providers-for-extensible-variants&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#serialization-providers-for-extensible-variants&quot; aria-label=&quot;Anchor link for: serialization-providers-for-extensible-variants&quot;&gt;Serialization providers for extensible variants&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Currently, &lt;code&gt;cgp-serde&lt;&#x2F;code&gt; has implemented providers like &lt;code&gt;SerializeFields&lt;&#x2F;code&gt; and &lt;code&gt;DeserializeRecordFields&lt;&#x2F;code&gt; to enable datatype-generic serialization for any struct that uses &lt;code&gt;#[derive(CgpData)]&lt;&#x2F;code&gt;. This decoupling of serialization logic from data type definitions is key to reducing the derive bloat caused by orphan rule restrictions.&lt;&#x2F;p&gt;
&lt;p&gt;However, the equivalent providers for Rust &lt;em&gt;enums&lt;&#x2F;em&gt; and &lt;em&gt;extensible variants&lt;&#x2F;em&gt; have not yet been implemented. This means that you cannot currently use the modular serialization features of &lt;code&gt;cgp-serde&lt;&#x2F;code&gt; to serialize enum types in your application. This limitation is purely due to time constraints; I was unable to dedicate enough time to finish the implementation for extensible variants before this initial release.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;helpers-for-json-deserialization&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#helpers-for-json-deserialization&quot; aria-label=&quot;Anchor link for: helpers-for-json-deserialization&quot;&gt;Helpers for JSON deserialization&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;At the moment, &lt;code&gt;cgp-serde&lt;&#x2F;code&gt; only provides the &lt;code&gt;deserialize_json_string&lt;&#x2F;code&gt; helper method to deserialize a JSON string using a context. Crucially, I have not yet implemented other common helper methods, such as &lt;code&gt;from_slice&lt;&#x2F;code&gt; and &lt;code&gt;from_value&lt;&#x2F;code&gt;. If you need the functionality equivalent to these methods, you would currently have to study the internals of &lt;code&gt;deserialize_json_string&lt;&#x2F;code&gt; and write your own deserialization wrappers.&lt;&#x2F;p&gt;
&lt;p&gt;The need for additional wrappers during deserialization arises because functions like &lt;code&gt;serde_json::from_str&lt;&#x2F;code&gt; do not accept any argument where we can &quot;pass&quot; around the deserialization context. Therefore we must explicitly work around this by constructing library-specific deserializers like &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;serde_json&#x2F;latest&#x2F;serde_json&#x2F;struct.Deserializer.html&quot;&gt;&lt;code&gt;serde_json::Deserializer&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; and then passing it along with the context to the &lt;code&gt;CanDeserializeValue::deserialize&lt;&#x2F;code&gt; method.&lt;&#x2F;p&gt;
&lt;p&gt;Fortunately, library functions like &lt;code&gt;serde::from_str&lt;&#x2F;code&gt; are generally lightweight wrappers around library-specific deserializers. This makes re-creating similar, easy-to-use helpers for &lt;code&gt;cgp-serde&lt;&#x2F;code&gt; a relatively straightforward task. The challenge here is simply a matter of time: I need to properly survey the common deserialization methods used in the wild and aim to support as many as possible. On the plus side, these wrapper implementations are low-hanging fruit and represent simple tasks for newcomers to contribute to the project. If you are interested in helping, please do submit a &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;contextgeneric&#x2F;cgp-serde&#x2F;pulls&quot;&gt;pull request&lt;&#x2F;a&gt;!&lt;&#x2F;p&gt;
&lt;h2 id=&quot;helpers-for-other-serialization-formats&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#helpers-for-other-serialization-formats&quot; aria-label=&quot;Anchor link for: helpers-for-other-serialization-formats&quot;&gt;Helpers for other serialization formats&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Just as custom deserialization wrappers are required for &lt;code&gt;serde_json&lt;&#x2F;code&gt;, we will likely need similar wrappers for other popular serialization formats, such as &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;toml&#x2F;latest&#x2F;toml&#x2F;&quot;&gt;&lt;code&gt;toml&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;In principle, serialization &lt;em&gt;from&lt;&#x2F;em&gt; &lt;code&gt;cgp-serde&lt;&#x2F;code&gt; should work almost immediately. If you use the &lt;code&gt;SerializeWithContext&lt;&#x2F;code&gt; wrapper with any serialization format, it should, theoretically, integrate seamlessly. However, this has not yet been thoroughly tested, so more verification is required. Assuming serialization works out of the box, the main task needed to support other formats will be implementing deserialization wrappers similar to what we have done for &lt;code&gt;serde_json&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;documentation&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#documentation&quot; aria-label=&quot;Anchor link for: documentation&quot;&gt;Documentation&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;A significant area for improvement is documentation. Both CGP and &lt;code&gt;cgp-serde&lt;&#x2F;code&gt; are currently severely lacking in comprehensive documentation. To make &lt;code&gt;cgp-serde&lt;&#x2F;code&gt; truly usable for the broader community, we will need to write far more documentation and tutorials explaining how to effectively use it for modular serialization.&lt;&#x2F;p&gt;
&lt;p&gt;With my time being extremely limited, I will likely only prioritize documenting &lt;code&gt;cgp-serde&lt;&#x2F;code&gt; over further developing CGP if there is real, demonstrable demand from developers wanting to use it for their applications. While I strongly believe the modular serialization provided by &lt;code&gt;cgp-serde&lt;&#x2F;code&gt; will be incredibly useful, my experience with developing CGP suggests that the community may not yet fully grasp or care about modular serialization as much as I do. Therefore, if the use cases presented by &lt;code&gt;cgp-serde&lt;&#x2F;code&gt; are important to you, please communicate your feedback so I can properly prioritize my development efforts!&lt;&#x2F;p&gt;
&lt;h2 id=&quot;performance-benchmark&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#performance-benchmark&quot; aria-label=&quot;Anchor link for: performance-benchmark&quot;&gt;Performance benchmark&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Since &lt;code&gt;cgp-serde&lt;&#x2F;code&gt; exclusively employs static dispatch, I am highly confident that the serialization performance should align closely with the original &lt;code&gt;serde&lt;&#x2F;code&gt; implementation. However, I have not yet had the time to conduct a proper benchmark, so we currently lack concrete evidence of &lt;code&gt;cgp-serde&lt;&#x2F;code&gt;&#x27;s performance characteristics.&lt;&#x2F;p&gt;
&lt;p&gt;In addition to validation, there are potential optimizations that could further boost &lt;code&gt;cgp-serde&lt;&#x2F;code&gt;&#x27;s speed. Once proper benchmarking is done, I can apply targeted optimizations if any performance bottlenecks are clearly identified.&lt;&#x2F;p&gt;
&lt;p&gt;The primary point of contention in benchmarking will likely be the serialization and deserialization performance of struct fields. This is because &lt;code&gt;cgp-serde&lt;&#x2F;code&gt; uses extensible data types to provide a &lt;strong&gt;generic&lt;&#x2F;strong&gt; implementation of serialize and deserialize for any struct. In contrast, &lt;code&gt;serde&lt;&#x2F;code&gt; uses derive macros to generate &lt;strong&gt;specific&lt;&#x2F;strong&gt; implementations of &lt;code&gt;Serialize&lt;&#x2F;code&gt; and &lt;code&gt;Deserialize&lt;&#x2F;code&gt; tailored to each struct. The critical question, then, is whether our generic implementation can run as fast as the macro-generated, highly specific implementations.&lt;&#x2F;p&gt;
&lt;p&gt;There are a few reasons why the macro-generated implementation by &lt;code&gt;serde&lt;&#x2F;code&gt; might be faster, particularly during deserialization. &lt;code&gt;serde&lt;&#x2F;code&gt; generates a &lt;code&gt;match&lt;&#x2F;code&gt; statement on &lt;em&gt;string literals&lt;&#x2F;em&gt; to determine which field it needs to deserialize. Conversely, &lt;code&gt;cgp-serde&lt;&#x2F;code&gt; must perform a sequential string comparison of an incoming field key against each field&#x27;s string tag and then choose the correct branch if a match is found. The Rust compiler can likely generate much more efficient, string-based pattern matching for &lt;code&gt;serde&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;We can only confirm if this gap exists by conducting a proper benchmark, specifically comparing scenarios like deserializing structs with many fields or fields with similar prefixes, to see if &lt;code&gt;cgp-serde&lt;&#x2F;code&gt;&#x27;s performance significantly worsens. If the performance difference is substantial, I will dedicate time to optimizing it. But if the difference is negligible, the current implementation is likely good enough.&lt;&#x2F;p&gt;
&lt;p&gt;One potential optimization I have considered is building a similar fast string matching table lazily using &lt;code&gt;LazyLock&lt;&#x2F;code&gt; when the first deserialization call occurs. We would need to build this table at runtime because our generic code can only inspect one field at a time, making it impossible to generate the same multi-string-literal &lt;code&gt;match&lt;&#x2F;code&gt; statement as a macro.&lt;&#x2F;p&gt;
&lt;p&gt;In any case, if you are interested in benchmarking or optimizing &lt;code&gt;cgp-serde&lt;&#x2F;code&gt;, your contributions to the project are highly welcome!&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h1 id=&quot;conclusion&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#conclusion&quot; aria-label=&quot;Anchor link for: conclusion&quot;&gt;Conclusion&lt;&#x2F;a&gt;&lt;&#x2F;h1&gt;
&lt;p&gt;In this article, we have provided a comprehensive preview of the powerful modular serialization features unlocked by &lt;code&gt;cgp-serde&lt;&#x2F;code&gt;. The most exciting part of this entire design is that almost nothing in &lt;code&gt;cgp-serde&lt;&#x2F;code&gt; is specifically engineered just for Serde or for serialization. Instead, everything you have learned here — from custom overlapping implementations to capabilities-enabled deserialization — is a direct result of the general design patterns offered by Context-Generic Programming for building any kind of application or library. This means you can easily take the same patterns used in &lt;code&gt;cgp-serde&lt;&#x2F;code&gt; and re-apply them to other traits and challenges within your own projects.&lt;&#x2F;p&gt;
&lt;p&gt;If this deep dive has piqued your interest in learning more about the fundamental concepts of CGP, please be sure to check out our &lt;a href=&quot;&#x2F;&quot;&gt;project homepage&lt;&#x2F;a&gt;. In particular, we encourage you to read our articles on how CGP can be used to solve the famous &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Expression_problem&quot;&gt;&lt;strong&gt;Expression Problem&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt; and how it enables the use of &lt;a href=&quot;&#x2F;blog&#x2F;extensible-datatypes-part-1&#x2F;&quot;&gt;&lt;strong&gt;extensible records and variants&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt; in stable Rust. You can also explore how CGP is utilized to implement &lt;a href=&quot;&#x2F;blog&#x2F;hypershell-release&#x2F;&quot;&gt;&lt;strong&gt;type-level DSLs&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;, using shell scripting as a practical example domain-specific language.&lt;&#x2F;p&gt;
&lt;p&gt;CGP is still in the early stages of development, so keep a close eye on the project&#x27;s updates and progress. We are just getting started on redefining modularity in Rust!&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>CGP v0.6.0 Release - Major ergonomic improvements for provider and context implementations</title>
        <published>2025-10-26T00:00:00+00:00</published>
        <updated>2025-10-26T00:00:00+00:00</updated>
        
        <author>
          <name>
            Soares Chen
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://www.contextgeneric.dev/blog/v0-6-0-release/"/>
        <id>https://www.contextgeneric.dev/blog/v0-6-0-release/</id>
        
        <content type="html" xml:base="https://www.contextgeneric.dev/blog/v0-6-0-release/">&lt;h1 id=&quot;overview&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#overview&quot; aria-label=&quot;Anchor link for: overview&quot;&gt;Overview&lt;&#x2F;a&gt;&lt;&#x2F;h1&gt;
&lt;p&gt;It has only been two weeks since &lt;a href=&quot;&#x2F;blog&#x2F;v0-5-0-release&#x2F;&quot;&gt;v0.5.0 was released&lt;&#x2F;a&gt;, yet we are already introducing another major update. &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;contextgeneric&#x2F;cgp&#x2F;releases&#x2F;tag&#x2F;v0.6.0&quot;&gt;&lt;strong&gt;CGP v0.6.0&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt; brings significant improvements to the ergonomics of implementing providers and contexts, making it easier and more intuitive for developers to build on top of CGP.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;simplified-provider-implementation-with-cgp-impl&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#simplified-provider-implementation-with-cgp-impl&quot; aria-label=&quot;Anchor link for: simplified-provider-implementation-with-cgp-impl&quot;&gt;Simplified provider implementation with &lt;code&gt;#[cgp_impl]&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;&lt;&#x2F;h1&gt;
&lt;p&gt;The highlight of v0.6.0 is the introduction of the new &lt;code&gt;#[cgp_impl]&lt;&#x2F;code&gt; macro, which replaces &lt;code&gt;#[cgp_provider]&lt;&#x2F;code&gt; and greatly simplifies the way provider traits are implemented in CGP.&lt;&#x2F;p&gt;
&lt;p&gt;Essentially, &lt;code&gt;#[cgp_impl]&lt;&#x2F;code&gt; lets you write a provider trait implementation as if it were a blanket implementation for the consumer trait. This makes implementing CGP providers feel as natural as working with regular Rust traits, reducing boilerplate and making the intent clearer.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;example&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#example&quot; aria-label=&quot;Anchor link for: example&quot;&gt;Example&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Consider the following example trait:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_component(HttpRequestFetcher)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;CanFetchHttpRequest: HasErrorType {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;fetch_http_request(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self, request: Request) -&amp;gt; Result&amp;lt;Response, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;Error&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;With &lt;code&gt;#[cgp_impl]&lt;&#x2F;code&gt;, you can now implement a provider like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_impl(new FetchWithHttpClient)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;Context&amp;gt; HttpRequestFetcher &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;Context
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self&lt;&#x2F;span&gt;&lt;span&gt;: HasHttpClient + HasErrorType,
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;fetch_http_request(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self, request: Request) -&amp;gt; Result&amp;lt;Response, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;Error&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Previously, the same functionality required using &lt;code&gt;#[cgp_provider]&lt;&#x2F;code&gt;, which looked like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_new_provider]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;Context&amp;gt; HttpRequestFetcher&amp;lt;Context&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;FetchWithHttpClient
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;    Context: HasHttpClient + HasErrorType,
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;fetch_http_request(context: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;Context, request: Request) -&amp;gt; Result&amp;lt;Response, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Context::&lt;&#x2F;span&gt;&lt;span&gt;Error&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;As shown above, &lt;code&gt;#[cgp_impl]&lt;&#x2F;code&gt; produces syntax that is much closer to standard Rust trait implementations, making provider definitions easier to read and write.&lt;&#x2F;p&gt;
&lt;p&gt;Behind the scenes, &lt;code&gt;#[cgp_impl]&lt;&#x2F;code&gt; expands to the same form as a manually written provider implementation using &lt;code&gt;#[cgp_provider]&lt;&#x2F;code&gt;. Understanding how provider traits work remains important, especially when debugging or exploring the generated code.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;direct-component-delegation-on-context-types&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#direct-component-delegation-on-context-types&quot; aria-label=&quot;Anchor link for: direct-component-delegation-on-context-types&quot;&gt;Direct component delegation on context types&lt;&#x2F;a&gt;&lt;&#x2F;h1&gt;
&lt;p&gt;In v0.6.0, we can now use &lt;code&gt;delegate_components!&lt;&#x2F;code&gt; directly on the context type itself, without requiring a separate provider struct. This makes it possible to write code like the following:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;App { ... }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;delegate_components! {
&lt;&#x2F;span&gt;&lt;span&gt;    App {
&lt;&#x2F;span&gt;&lt;span&gt;        FooComponent: FooProvider,
&lt;&#x2F;span&gt;&lt;span&gt;        BarComponent: BarProvider,
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Previously, it was necessary to use a separate provider for the context:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_context]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;App { ... }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;delegate_components! {
&lt;&#x2F;span&gt;&lt;span&gt;    AppComponents {
&lt;&#x2F;span&gt;&lt;span&gt;        FooComponent: FooProvider,
&lt;&#x2F;span&gt;&lt;span&gt;        BarComponent: BarProvider,
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This new approach significantly simplifies how components are wired to a concrete context. There is no longer a need to introduce an extra &lt;code&gt;AppComponents&lt;&#x2F;code&gt; struct just to serve as a type-level lookup table. The lookup table is now embedded directly in the &lt;code&gt;App&lt;&#x2F;code&gt; type itself.&lt;&#x2F;p&gt;
&lt;p&gt;This change can also yield a small improvement in compile times, since there is one fewer level of indirection for the trait solver to handle when resolving provider relationships.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;direct-implementation-of-consumer-traits&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#direct-implementation-of-consumer-traits&quot; aria-label=&quot;Anchor link for: direct-implementation-of-consumer-traits&quot;&gt;Direct implementation of consumer traits&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;A major benefit of this improvement is the ability to implement consumer traits directly on a concrete context type. For example:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_getter]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;HasName {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;name(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;str&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[cgp_getter]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;HasCount {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;count(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u32&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[derive(HasField)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;App {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;name: String,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;count: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u32&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;delegate_components! {
&lt;&#x2F;span&gt;&lt;span&gt;    App {
&lt;&#x2F;span&gt;&lt;span&gt;        NameGetterComponent: UseField&amp;lt;Symbol&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;name&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;)&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; Consumer trait can now be implemented directly
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;HasCount &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;App {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;count(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u32 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        self.count
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In earlier versions, you would have needed to write the following instead:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_provider]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;CountGetter&amp;lt;App&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;AppComponents {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;count(app: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;App) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u32 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        app.count
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This older style often made code appear verbose and confusing, particularly for newcomers. The new approach is cleaner and more intuitive, aligning better with standard Rust trait conventions.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;unlock-use-of-cgp-component-on-any-trait&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#unlock-use-of-cgp-component-on-any-trait&quot; aria-label=&quot;Anchor link for: unlock-use-of-cgp-component-on-any-trait&quot;&gt;Unlock use of &lt;code&gt;#[cgp_component]&lt;&#x2F;code&gt; on any trait&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;This simplification also enables &lt;code&gt;#[cgp_component]&lt;&#x2F;code&gt; to be applied to nearly any existing Rust trait without breaking existing code. This is a major step toward making CGP easier to adopt, since developers can start integrating it gradually without needing to first learn all its concepts.&lt;&#x2F;p&gt;
&lt;p&gt;For example, in principle it is now possible to annotate the standard library’s &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;hash&#x2F;trait.Hash.html&quot;&gt;&lt;code&gt;Hash&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; trait with &lt;code&gt;#[cgp_component]&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_component(HashProvider)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;Hash { &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;... &lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This does not affect existing code that uses or implements &lt;code&gt;Hash&lt;&#x2F;code&gt;, but it allows new overlapping implementations such as:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_impl(HashWithDisplay)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;T: Display&amp;gt; HashProvider &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;T {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;You can then reuse this implementation on any type using &lt;code&gt;delegate_components!&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;MyData { ... }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;Display &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;MyData { &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;... &lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;delegate_components! {
&lt;&#x2F;span&gt;&lt;span&gt;    MyData {
&lt;&#x2F;span&gt;&lt;span&gt;        HashProviderComponent: HashWithDisplay,
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;With this capability, CGP can now enhance any existing Rust trait without changing how those traits are implemented. By supporting overlapping and orphan implementations safely, CGP v0.6.0 makes it far easier and more appealing for developers to experiment with the framework, since the onboarding cost is now significantly lower.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;removal-of-hascgpprovider-trait&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#removal-of-hascgpprovider-trait&quot; aria-label=&quot;Anchor link for: removal-of-hascgpprovider-trait&quot;&gt;Removal of &lt;code&gt;HasCgpProvider&lt;&#x2F;code&gt; trait&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Consumer traits can now be implemented directly because CGP has removed the &lt;code&gt;HasCgpProvider&lt;&#x2F;code&gt; trait. Instead of relying on &lt;code&gt;HasCgpProvider&lt;&#x2F;code&gt;, blanket implementations for consumer traits now use &lt;code&gt;DelegateComponent&lt;&#x2F;code&gt;, just as provider traits do.&lt;&#x2F;p&gt;
&lt;p&gt;For example, the &lt;code&gt;HasName&lt;&#x2F;code&gt; trait introduced earlier now expands into the following blanket implementation:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;Context&amp;gt; HasName &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;Context
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;    Context: DelegateComponent&amp;lt;NameGetterComponent&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Context::&lt;&#x2F;span&gt;&lt;span&gt;Delegate: NameGetter&amp;lt;Context&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;name(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;str &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        Context::Delegate::name(self)
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Previously, the generated code looked like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;Context&amp;gt; HasName &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;Context
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;    Context: HasCgpProvider,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Context::&lt;&#x2F;span&gt;&lt;span&gt;CgpProvider: NameGetter&amp;lt;Context&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;name(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;str &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        Context::CgpProvider::name(self)
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The old design had an important limitation: any type implementing &lt;code&gt;HasCgpProvider&lt;&#x2F;code&gt; could not also implement the corresponding consumer trait directly, because the blanket implementation would already cover it. With the new approach, this restriction no longer applies. A type that implements &lt;code&gt;DelegateComponent&lt;&#x2F;code&gt; can still define its own consumer trait implementation, as long as there is no conflicting implementation for the same component key. This means developers can freely implement consumer traits on their context types without running into conflicts, as long as the delegation remains unambiguous.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;backward-compatibility&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#backward-compatibility&quot; aria-label=&quot;Anchor link for: backward-compatibility&quot;&gt;Backward Compatibility&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Since many projects already use CGP, removing context providers entirely could cause extensive breakage. To avoid this, the new version modifies the behavior of &lt;code&gt;#[cgp_context]&lt;&#x2F;code&gt; so that it automatically provides blanket &lt;code&gt;DelegateComponent&amp;lt;Name&amp;gt;&lt;&#x2F;code&gt; implementations for all component names, preserving compatibility with existing code.&lt;&#x2F;p&gt;
&lt;p&gt;For instance, consider the following context definition:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_context]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;App { ... }
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The macro now generates the following code:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;AppComponents;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;Name&amp;gt; DelegateComponent&amp;lt;Name&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;App {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Delegate &lt;&#x2F;span&gt;&lt;span&gt;= AppComponents;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This bulk delegation plays the same role that &lt;code&gt;HasCgpProvider&lt;&#x2F;code&gt; once did, ensuring that older codebases continue to function correctly. Previously, the generated code would have looked like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;AppComponents;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;HasCgpProvider &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;App {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;CgpProvider &lt;&#x2F;span&gt;&lt;span&gt;= AppComponents;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;By automatically generating the bulk delegation, CGP v0.6.0 maintains backward compatibility while adopting a cleaner and more flexible design.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;background&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#background&quot; aria-label=&quot;Anchor link for: background&quot;&gt;Background&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;To understand why &lt;code&gt;HasCgpProvider&lt;&#x2F;code&gt; was used in the first place, it helps to look back at CGP’s early design. The original idea was to allow multiple concrete contexts to share a single provider “table.” For example:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;AppComponents;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;AppA { ... }
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;AppB { ... }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;HasCgpProvider &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;AppA {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;CgpProvider &lt;&#x2F;span&gt;&lt;span&gt;= AppComponents;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;HasCgpProvider &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;AppB {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;CgpProvider &lt;&#x2F;span&gt;&lt;span&gt;= AppComponents;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In this design, different applications could reuse the same wiring setup without reconfiguring components each time. However, in practice, many contexts shared most of their wiring but required small customizations. This need for partial reuse led to the introduction of the &lt;em&gt;preset&lt;&#x2F;em&gt; feature, which provided the same flexibility without the drawbacks of shared context providers.&lt;&#x2F;p&gt;
&lt;p&gt;Over time, the &lt;code&gt;HasCgpProvider&lt;&#x2F;code&gt; system became a remnant of CGP’s early architecture. It persisted mainly out of concern for backward compatibility. After reevaluating the issue, it became clear that generating &lt;code&gt;DelegateComponent&lt;&#x2F;code&gt; implementations through &lt;code&gt;#[cgp_context]&lt;&#x2F;code&gt; could preserve compatibility while removing unnecessary complexity. This realization made it possible to remove &lt;code&gt;HasCgpProvider&lt;&#x2F;code&gt; entirely in v0.6.0, simplifying the design and improving flexibility without disrupting existing users.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;introduce-cgp-inherit-macro&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#introduce-cgp-inherit-macro&quot; aria-label=&quot;Anchor link for: introduce-cgp-inherit-macro&quot;&gt;Introduce &lt;code&gt;#[cgp_inherit]&lt;&#x2F;code&gt; macro&lt;&#x2F;a&gt;&lt;&#x2F;h1&gt;
&lt;p&gt;With the deprecation of &lt;code&gt;#[cgp_context]&lt;&#x2F;code&gt;, CGP v0.6.0 introduces a new and clearer way for concrete contexts to inherit from a preset. The new &lt;code&gt;#[cgp_inherit]&lt;&#x2F;code&gt; macro provides this functionality directly, allowing a context to build upon a preset without the need for an additional provider type.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;example-1&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#example-1&quot; aria-label=&quot;Anchor link for: example-1&quot;&gt;Example&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Given the following:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_inherit(MyPreset)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;App { ... }
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;is roughly equivalent to the previous way of expressing preset inheritance with &lt;code&gt;#[cgp_context]&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_context(AppComponents: MyPreset)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;App { ... }
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The key difference is that with &lt;code&gt;#[cgp_inherit]&lt;&#x2F;code&gt;, the preset inheritance happens directly on the &lt;code&gt;App&lt;&#x2F;code&gt; context itself. There is no need to generate an intermediary &lt;code&gt;AppComponents&lt;&#x2F;code&gt; provider type that inherits from &lt;code&gt;MyPreset&lt;&#x2F;code&gt;. This makes the inheritance mechanism simpler and more transparent.&lt;&#x2F;p&gt;
&lt;p&gt;Behind the scenes, &lt;code&gt;#[cgp_inherit]&lt;&#x2F;code&gt; generates code similar to the following:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;Name&amp;gt; DelegateComponent&amp;lt;Name&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;App
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;MyPreset::&lt;&#x2F;span&gt;&lt;span&gt;IsPreset&amp;lt;Name&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;MyPreset::&lt;&#x2F;span&gt;&lt;span&gt;Components: DelegateComponent&amp;lt;Name&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Delegate &lt;&#x2F;span&gt;&lt;span&gt;= &amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;MyPreset::&lt;&#x2F;span&gt;&lt;span&gt;Components &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as &lt;&#x2F;span&gt;&lt;span&gt;DelegateComponent&amp;lt;Name&amp;gt;&amp;gt;::Delegate;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This generated implementation delegates component resolution to the preset whenever the component key is part of that preset. At the same time, the design allows for flexibility: even with these blanket implementations, you can still implement consumer traits directly on the &lt;code&gt;App&lt;&#x2F;code&gt; context for any component keys that are not provided by the preset.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;migration-guide&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#migration-guide&quot; aria-label=&quot;Anchor link for: migration-guide&quot;&gt;Migration Guide&lt;&#x2F;a&gt;&lt;&#x2F;h1&gt;
&lt;p&gt;In most cases, upgrading to v0.6.0 should not require any changes to existing code. The update has been designed with backward compatibility in mind, allowing projects to transition smoothly while taking advantage of the new ergonomic improvements.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;removal-of-hascgpprovider-trait-1&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#removal-of-hascgpprovider-trait-1&quot; aria-label=&quot;Anchor link for: removal-of-hascgpprovider-trait-1&quot;&gt;Removal of &lt;code&gt;HasCgpProvider&lt;&#x2F;code&gt; trait&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;The most significant breaking change in v0.6.0 is the removal of the &lt;code&gt;HasCgpProvider&lt;&#x2F;code&gt; trait and the change in how consumer trait blanket implementations are generated. However, most CGP users do not directly interact with these internal constructs, so existing code should continue to compile without modification. The change primarily affects macro-generated code and internal delegation logic rather than user-defined traits or providers.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;deprecation-of-cgp-context&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#deprecation-of-cgp-context&quot; aria-label=&quot;Anchor link for: deprecation-of-cgp-context&quot;&gt;Deprecation of &lt;code&gt;#[cgp_context]&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;The &lt;code&gt;#[cgp_context]&lt;&#x2F;code&gt; macro has been retained for backward compatibility, ensuring that existing projects using context providers will continue to function as before. However, it is strongly recommended to remove &lt;code&gt;#[cgp_context]&lt;&#x2F;code&gt; when upgrading to v0.6.0. Doing so allows your context types to directly implement consumer traits, taking full advantage of the simplified delegation system and cleaner trait relationships introduced in this release.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;deprecation-of-cgp-provider&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#deprecation-of-cgp-provider&quot; aria-label=&quot;Anchor link for: deprecation-of-cgp-provider&quot;&gt;Deprecation of &lt;code&gt;#[cgp_provider]&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;The introduction of the &lt;code&gt;#[cgp_impl]&lt;&#x2F;code&gt; macro replaces the need for &lt;code&gt;#[cgp_provider]&lt;&#x2F;code&gt; when defining provider implementations. Existing uses of &lt;code&gt;#[cgp_provider]&lt;&#x2F;code&gt; will still compile and function correctly in v0.6.0, but developers are encouraged to migrate to &lt;code&gt;#[cgp_impl]&lt;&#x2F;code&gt; for new code. The new syntax is closer to standard Rust trait implementations, making provider definitions easier to read and reason about.&lt;&#x2F;p&gt;
&lt;p&gt;It is also advisable to migrate all existing provider implementations to use &lt;code&gt;#[cgp_impl]&lt;&#x2F;code&gt;, especially in projects with multiple contributors. Mixing both macros can lead to confusion among developers unfamiliar with CGP, as they may wonder why two different styles exist. In contrast, &lt;code&gt;#[cgp_impl]&lt;&#x2F;code&gt; is intuitive to Rust users, since it effectively represents a named blanket implementation and requires no prior knowledge of CGP’s internal model.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h1 id=&quot;updates&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#updates&quot; aria-label=&quot;Anchor link for: updates&quot;&gt;Updates&lt;&#x2F;a&gt;&lt;&#x2F;h1&gt;
&lt;h2 id=&quot;rustlab-presentation&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#rustlab-presentation&quot; aria-label=&quot;Anchor link for: rustlab-presentation&quot;&gt;RustLab Presentation&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;blog&#x2F;images&#x2F;rustlab-2025.png&quot; alt=&quot;RustLab 2025&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;The time is drawing near, and I will be presenting &lt;a href=&quot;https:&#x2F;&#x2F;rustlab.it&#x2F;talks&#x2F;how-to-stop-fighting-with-coherence-and-start-writing-context-generic-trait-impls&quot;&gt;&lt;strong&gt;How to Stop Fighting with Coherence and Start Writing Context-Generic Trait Impls&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt; at RustLab on November 3rd. I look forward to meeting everyone attending the conference!&lt;&#x2F;p&gt;
&lt;h2 id=&quot;acknowledgement&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#acknowledgement&quot; aria-label=&quot;Anchor link for: acknowledgement&quot;&gt;Acknowledgement&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Thank you April Gonçalves and Dzmitry Lahoda for &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;sponsors&#x2F;soareschen&quot;&gt;sponsoring&lt;&#x2F;a&gt; the development of CGP!&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>CGP v0.5.0 Release - Auto dispatchers, extensible datatype improvements, monadic computation, RTN emulation, modular serde, and more</title>
        <published>2025-10-12T00:00:00+00:00</published>
        <updated>2025-10-12T00:00:00+00:00</updated>
        
        <author>
          <name>
            Soares Chen
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://www.contextgeneric.dev/blog/v0-5-0-release/"/>
        <id>https://www.contextgeneric.dev/blog/v0-5-0-release/</id>
        
        <content type="html" xml:base="https://www.contextgeneric.dev/blog/v0-5-0-release/">&lt;h1 id=&quot;overview&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#overview&quot; aria-label=&quot;Anchor link for: overview&quot;&gt;Overview&lt;&#x2F;a&gt;&lt;&#x2F;h1&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;crates.io&#x2F;crates&#x2F;cgp&#x2F;0.5.0&quot;&gt;CGP v0.5.0&lt;&#x2F;a&gt; has been released, bringing a range of new features and some breaking changes as part of the ongoing effort toward stabilization. This version introduces several improvements to make CGP more practical, expressive, and easier to use in real-world Rust projects.&lt;&#x2F;p&gt;
&lt;p&gt;The highlights of this major release are summarized below. Also check out the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;contextgeneric&#x2F;cgp&#x2F;releases&#x2F;tag&#x2F;v0.5.0&quot;&gt;changelog&lt;&#x2F;a&gt; for the full list of changes.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h1 id=&quot;new-features&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#new-features&quot; aria-label=&quot;Anchor link for: new-features&quot;&gt;New Features&lt;&#x2F;a&gt;&lt;&#x2F;h1&gt;
&lt;h2 id=&quot;derive-cgpdata-macro&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#derive-cgpdata-macro&quot; aria-label=&quot;Anchor link for: derive-cgpdata-macro&quot;&gt;&lt;code&gt;#[derive(CgpData)]&lt;&#x2F;code&gt; Macro&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;The new &lt;code&gt;#[derive(CgpData)]&lt;&#x2F;code&gt; macro provides a unified way to turn any struct or enum into an extensible data type.&lt;&#x2F;p&gt;
&lt;p&gt;For example, given:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[derive(CgpData)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;Person {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;name: String,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;age: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u8&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[derive(CgpData)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub enum &lt;&#x2F;span&gt;&lt;span&gt;User {
&lt;&#x2F;span&gt;&lt;span&gt;    Known(Person),
&lt;&#x2F;span&gt;&lt;span&gt;    Anonymous(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u64&lt;&#x2F;span&gt;&lt;span&gt;),
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This macro automatically derives all the extensible data traits for you, including &lt;code&gt;HasField&lt;&#x2F;code&gt;, &lt;code&gt;FromVariant&lt;&#x2F;code&gt;, &lt;code&gt;HasFields&lt;&#x2F;code&gt;, &lt;code&gt;BuildField&lt;&#x2F;code&gt;, and &lt;code&gt;ExtractField&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Before v0.5.0, you had to derive these traits separately, as shown below:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[derive(HasField, HasFields, BuildField)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;Person {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;name: String,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;age: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u8&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[derive(FromVariant, HasFields, ExtractField)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub enum &lt;&#x2F;span&gt;&lt;span&gt;User {
&lt;&#x2F;span&gt;&lt;span&gt;    Known(Person),
&lt;&#x2F;span&gt;&lt;span&gt;    Anonymous(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u64&lt;&#x2F;span&gt;&lt;span&gt;),
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;With &lt;code&gt;#[derive(CgpData)]&lt;&#x2F;code&gt;, the process is now simpler, cleaner, and less tedious.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;cgp-auto-dispatch-macro&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#cgp-auto-dispatch-macro&quot; aria-label=&quot;Anchor link for: cgp-auto-dispatch-macro&quot;&gt;&lt;code&gt;#[cgp_auto_dispatch]&lt;&#x2F;code&gt; Macro&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;The new &lt;code&gt;#[cgp_auto_dispatch]&lt;&#x2F;code&gt; macro allows automatic dispatch of trait implementations for enums when all their variants implement the same trait.&lt;&#x2F;p&gt;
&lt;p&gt;Consider the following example with a &lt;code&gt;Shape&lt;&#x2F;code&gt; enum:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[derive(CgpData)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub enum &lt;&#x2F;span&gt;&lt;span&gt;Shape {
&lt;&#x2F;span&gt;&lt;span&gt;    Circle(Circle),
&lt;&#x2F;span&gt;&lt;span&gt;    Rectangle(Rectangle),
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;Circle {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;radius: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;f64&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;Rectangle {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;width: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;f64&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;height: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;f64&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Suppose we want to define a trait &lt;code&gt;HasArea&lt;&#x2F;code&gt; for computing the area of shapes. We can define and implement it as follows:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_auto_dispatch]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;HasArea {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;area(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;f64&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;HasArea &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;Circle {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;area(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;f64 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;PI &lt;&#x2F;span&gt;&lt;span&gt;* self.radius * self.radius
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;HasArea &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;Rectangle {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;area(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;f64 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        self.width * self.height
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;With this setup, &lt;code&gt;HasArea&lt;&#x2F;code&gt; is now automatically implemented for &lt;code&gt;Shape&lt;&#x2F;code&gt; without the need to manually write any additional &lt;code&gt;impl&lt;&#x2F;code&gt; blocks.&lt;&#x2F;p&gt;
&lt;p&gt;Behind the scenes, the &lt;code&gt;#[cgp_auto_dispatch]&lt;&#x2F;code&gt; macro generates a blanket implementation of &lt;code&gt;HasArea&lt;&#x2F;code&gt; using &lt;a href=&quot;&#x2F;blog&#x2F;extensible-datatypes-part-4&#x2F;&quot;&gt;extensible visitors&lt;&#x2F;a&gt; to dispatch calls to the appropriate variant. Because &lt;code&gt;Shape&lt;&#x2F;code&gt; uses &lt;code&gt;#[derive(CgpData)]&lt;&#x2F;code&gt;, it already includes the extensible variant constructs needed for the blanket implementation.&lt;&#x2F;p&gt;
&lt;p&gt;An important detail is that &lt;code&gt;#[derive(CgpData)]&lt;&#x2F;code&gt; and &lt;code&gt;#[cgp_auto_dispatch]&lt;&#x2F;code&gt; work seamlessly across crate boundaries. The trait and the enum do not need to know about each other for the blanket implementation to take effect. Everything just works.&lt;&#x2F;p&gt;
&lt;p&gt;A deeper explanation of how &lt;code&gt;#[cgp_auto_dispatch]&lt;&#x2F;code&gt; operates will be covered in a future blog post. For now, you can experiment with it directly in your projects. Even if you are not yet using the rest of CGP, this macro can simplify your code right away.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;updatefield-trait&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#updatefield-trait&quot; aria-label=&quot;Anchor link for: updatefield-trait&quot;&gt;&lt;code&gt;UpdateField&lt;&#x2F;code&gt; Trait&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;A new &lt;code&gt;UpdateField&lt;&#x2F;code&gt; trait has been introduced to generalize the process of updating extensible records:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;UpdateField&amp;lt;Tag, M: MapType&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Value&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Mapper&lt;&#x2F;span&gt;&lt;span&gt;: MapType;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Output&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;update_field(
&lt;&#x2F;span&gt;&lt;span&gt;        self,
&lt;&#x2F;span&gt;&lt;span&gt;        _tag: PhantomData&amp;lt;Tag&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        value: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;M::&lt;&#x2F;span&gt;&lt;span&gt;Map&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;Value&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    ) -&amp;gt; (&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;Mapper &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as&lt;&#x2F;span&gt;&lt;span&gt; MapType&amp;gt;::Map&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;Value&amp;gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;Output);
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;UpdateField&lt;&#x2F;code&gt; trait allows you to replace a &lt;em&gt;wrapped&lt;&#x2F;em&gt; value within a partial record with another wrapped value. It is automatically derived by &lt;code&gt;#[derive(CgpData)]&lt;&#x2F;code&gt;, which means that field update operations can rely on &lt;code&gt;UpdateField&lt;&#x2F;code&gt; without requiring any manual derivation.&lt;&#x2F;p&gt;
&lt;p&gt;For instance, the &lt;a href=&quot;&#x2F;blog&#x2F;extensible-datatypes-part-3&#x2F;#buildfield-trait&quot;&gt;&lt;code&gt;BuildField&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; trait is now implemented as a blanket implementation that builds upon &lt;code&gt;UpdateField&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;BuildField&amp;lt;Tag&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Value&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Output&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;build_field(self, _tag: PhantomData&amp;lt;Tag&amp;gt;, value: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;Value) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;Output;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;Context, Tag&amp;gt; BuildField&amp;lt;Tag&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;Context
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;    Context: UpdateField&amp;lt;Tag, IsPresent, Mapper = IsNothing&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Value &lt;&#x2F;span&gt;&lt;span&gt;= Context::Value;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Output &lt;&#x2F;span&gt;&lt;span&gt;= Context::Output;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;build_field(self, tag: PhantomData&amp;lt;Tag&amp;gt;, value: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;Value) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;Output {
&lt;&#x2F;span&gt;&lt;span&gt;        self.update_field(tag, value).&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In essence, &lt;code&gt;BuildField&lt;&#x2F;code&gt; is implemented by transforming a field that is initially &lt;code&gt;IsNothing&lt;&#x2F;code&gt; in a partial record into an &lt;code&gt;IsPresent&lt;&#x2F;code&gt; field, using &lt;code&gt;UpdateField&lt;&#x2F;code&gt; as the underlying mechanism.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;finalize-extensible-builder-with-default-values&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#finalize-extensible-builder-with-default-values&quot; aria-label=&quot;Anchor link for: finalize-extensible-builder-with-default-values&quot;&gt;Finalize extensible builder with default values&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;The &lt;a href=&quot;&#x2F;blog&#x2F;extensible-datatypes-part-1&#x2F;&quot;&gt;extensible builder pattern&lt;&#x2F;a&gt; now supports finalizing a partial record by filling in any uninitialized fields using their &lt;code&gt;Default&lt;&#x2F;code&gt; values. This functionality is provided by the new &lt;code&gt;finalize_with_default&lt;&#x2F;code&gt; method.&lt;&#x2F;p&gt;
&lt;p&gt;For example, consider the following extensible record:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[derive(CgpData)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;FooBar {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;foo: String,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;bar: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u64&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;You can now construct a &lt;code&gt;FooBar&lt;&#x2F;code&gt; instance while letting the &lt;code&gt;bar&lt;&#x2F;code&gt; field fall back to its default value of &lt;code&gt;0&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; foo_bar = FooBar::builder() &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; __PartialFooBar&amp;lt;IsNothing, IsNothing&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    .build_field(PhantomData::&amp;lt;Symbol&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;foo&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;)&amp;gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;foo&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;.to_owned()) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; __PartialFooBar&amp;lt;IsPresent, IsNothing&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    .finalize_with_default(); &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; FooBar
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Behind the scene, &lt;code&gt;finalize_with_default&lt;&#x2F;code&gt; works by using the &lt;code&gt;UpdateField&lt;&#x2F;code&gt; trait to perform a &lt;em&gt;natural transformation&lt;&#x2F;em&gt; on each field modifier. It applies the &lt;code&gt;Default&lt;&#x2F;code&gt; implementation to convert &lt;code&gt;IsNothing&lt;&#x2F;code&gt; fields into &lt;code&gt;IsPresent&lt;&#x2F;code&gt;, completing the record automatically.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;extensible-builder-with-optional-field-status&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#extensible-builder-with-optional-field-status&quot; aria-label=&quot;Anchor link for: extensible-builder-with-optional-field-status&quot;&gt;Extensible builder with optional field status&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;The original design of the extensible builder uses the &lt;strong&gt;typestate pattern&lt;&#x2F;strong&gt; to track whether each field in a partial record has been set. In this pattern, &lt;code&gt;IsPresent&lt;&#x2F;code&gt; indicates that a field has been assigned a value, while &lt;code&gt;IsNothing&lt;&#x2F;code&gt; indicates that it has not.&lt;&#x2F;p&gt;
&lt;p&gt;Although this approach provides strong compile-time guarantees, it also means that each state of the partial record has a distinct type. For example, &lt;code&gt;__PartialFooBar&amp;lt;IsPresent, IsNothing&amp;gt;&lt;&#x2F;code&gt; and &lt;code&gt;__PartialFooBar&amp;lt;IsNothing, IsPresent&amp;gt;&lt;&#x2F;code&gt; are considered different types. This can be inconvenient in scenarios where the builder needs to maintain a single type throughout the build process, such as when dynamically deserializing JSON data into a partial record.&lt;&#x2F;p&gt;
&lt;p&gt;To address this limitation, a new &lt;code&gt;IsOptional&lt;&#x2F;code&gt; field state has been introduced. It allows a partial record to retain the same type even as fields are updated. This is achieved by mapping field values to &lt;code&gt;Option&lt;&#x2F;code&gt;, so that the status of each field is determined at runtime. Using this approach, a partial record like &lt;code&gt;__PartialFooBar&amp;lt;IsOptional, IsOptional&amp;gt;&lt;&#x2F;code&gt; can serve as an optional builder.&lt;&#x2F;p&gt;
&lt;p&gt;You can create and use an optional builder with the &lt;code&gt;optional_builder&lt;&#x2F;code&gt;, &lt;code&gt;set&lt;&#x2F;code&gt;, and &lt;code&gt;finalize_optional&lt;&#x2F;code&gt; methods as shown below:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; foo_bar = FooBar::optional_builder() &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; __PartialFooBar&amp;lt;IsOptional, IsOptional&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    .set(PhantomData::&amp;lt;Symbol&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;foo&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;)&amp;gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;foo&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;.to_owned()) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; __PartialFooBar&amp;lt;IsOptional, IsOptional&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    .set(PhantomData::&amp;lt;Symbol&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;bar&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;)&amp;gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;42&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; __PartialFooBar&amp;lt;IsOptional, IsOptional&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    .finalize_optional() &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; Result&amp;lt;FooBar, String&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    .unwrap() &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; FooBar
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Unlike the original typestate builder, the type of the builder remains &lt;code&gt;__PartialFooBar&amp;lt;IsOptional, IsOptional&amp;gt;&lt;&#x2F;code&gt; after each call to &lt;code&gt;set&lt;&#x2F;code&gt;. The &lt;code&gt;finalize_optional&lt;&#x2F;code&gt; method returns a &lt;code&gt;Result&lt;&#x2F;code&gt;, producing an error if any field contains a &lt;code&gt;None&lt;&#x2F;code&gt; value. This check is necessary because, without the typestate guarantees, the compiler cannot ensure at compile time that all fields are initialized.&lt;&#x2F;p&gt;
&lt;p&gt;You can also use the optional builder with &lt;code&gt;finalize_with_default&lt;&#x2F;code&gt; if all fields in the extensible record implement &lt;code&gt;Default&lt;&#x2F;code&gt;. In that case, you can safely finalize the record without handling a potential error:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; foo_bar = FooBar::optional_builder() &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; __PartialFooBar&amp;lt;IsOptional, IsOptional&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    .set(PhantomData::&amp;lt;Symbol&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;foo&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;)&amp;gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;foo&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;.to_owned()) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; __PartialFooBar&amp;lt;IsOptional, IsOptional&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    .finalize_with_default(); &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; FooBar
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The optional builder is used by &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;contextgeneric&#x2F;cgp-serde&#x2F;blob&#x2F;46ff47fce3aa3e57700340a05833b404b9d59ddf&#x2F;crates&#x2F;cgp-serde&#x2F;src&#x2F;providers&#x2F;record.rs#L49-L65&quot;&gt;&lt;code&gt;cgp-serde&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; to implement generic deserialization for extensible records.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;extensible-visitor-dispatchers&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#extensible-visitor-dispatchers&quot; aria-label=&quot;Anchor link for: extensible-visitor-dispatchers&quot;&gt;Extensible visitor dispatchers&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;The extensible visitor providers have been redesigned to support a wider range of use cases. The library now includes the following dispatchers:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;MatchWithValueHandlers&lt;&#x2F;code&gt; – matches and dispatches on an owned input &lt;code&gt;Value&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;MatchWithValueHandlersRef&lt;&#x2F;code&gt; – matches and dispatches on a borrowed input &lt;code&gt;&amp;amp;Value&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;MatchWithValueHandlersMut&lt;&#x2F;code&gt; – matches and dispatches on a mutably borrowed input &lt;code&gt;&amp;amp;mut Value&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;These dispatchers are compatible with both the owned and borrowed variants of the handler traits, such as &lt;code&gt;Computer&lt;&#x2F;code&gt; and &lt;code&gt;ComputerRef&lt;&#x2F;code&gt;. Within &lt;code&gt;Computer&lt;&#x2F;code&gt;, the borrowed value, including the reference, is used as the &lt;code&gt;Input&lt;&#x2F;code&gt; parameter. For example:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;MatchWithValueHandlersRef: Computer&amp;lt;Context, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;Value&amp;gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;and also:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;MatchWithValueHandlersRef: ComputerRef&amp;lt;Context, Value&amp;gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In addition, tuple variants of the matchers have been introduced to handle input values alongside additional arguments:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;MatchFirstWithValueHandlers&lt;&#x2F;code&gt; – matches and dispatches on an owned &lt;code&gt;Value&lt;&#x2F;code&gt; within an input &lt;code&gt;(Value, Args)&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;MatchFirstWithValueHandlersRef&lt;&#x2F;code&gt; – matches and dispatches on a borrowed &lt;code&gt;&amp;amp;Value&lt;&#x2F;code&gt; within an input &lt;code&gt;(&amp;amp;Value, Args)&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;MatchFirstWithValueHandlersMut&lt;&#x2F;code&gt; – matches and dispatches on a mutably borrowed &lt;code&gt;&amp;amp;mut Value&lt;&#x2F;code&gt; within an input &lt;code&gt;(&amp;amp;mut Value, Args)&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;These matchers are designed to support the implementation of &lt;code&gt;#[cgp_auto_dispatch]&lt;&#x2F;code&gt;, enabling extra arguments to be passed through the dispatchers without being directly matched on. They can also be used in advanced extensible visitor scenarios where additional arguments need to be forwarded to the visitors.&lt;&#x2F;p&gt;
&lt;p&gt;It is important to note that the handlers do not implement the reference variants of the handler traits. For instance:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;MatchFirstWithValueHandlersRef: Computer&amp;lt;Context, (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;Value, Args)&amp;gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;is implemented, but &lt;strong&gt;not&lt;&#x2F;strong&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;MatchFirstWithValueHandlersRef: ComputerRef&amp;lt;Context, (Value, Args)&amp;gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This is because &lt;code&gt;ComputerRef&lt;&#x2F;code&gt; converts the entire input type into a reference, making it difficult to pass an owned value within &lt;code&gt;Args&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;This distinction highlights that the &lt;code&gt;Computer&lt;&#x2F;code&gt; trait is more flexible than &lt;code&gt;ComputerRef&lt;&#x2F;code&gt;, since it can work with borrowed values as input types. By contrast, &lt;code&gt;ComputerRef&lt;&#x2F;code&gt; is simpler for developers who are new to the framework, as it allows working with borrowed values without needing to understand higher-ranked trait bounds. For more advanced use cases that involve extra arguments, it is generally more straightforward to use &lt;code&gt;Computer&lt;&#x2F;code&gt; directly rather than extending &lt;code&gt;ComputerRef&lt;&#x2F;code&gt; to accommodate those patterns.&lt;&#x2F;p&gt;
&lt;p&gt;Internally, all dispatchers share the same core abstraction that powers extensible visitors. This means the library does not reimplement the same logic multiple times for each of the six dispatchers. It also allows advanced users to build on these abstractions to define custom dispatchers for specialized use cases.&lt;&#x2F;p&gt;
&lt;p&gt;For a detailed explanation of how these dispatchers are implemented, see the section on &lt;a href=&quot;&#x2F;blog&#x2F;extensible-datatypes-part-4&#x2F;#implementation-of-visitor-dispatcher&quot;&gt;extensible visitors&lt;&#x2F;a&gt;. Additional blog posts will follow to explore these extended features in greater depth.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;asynccomputer-trait&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#asynccomputer-trait&quot; aria-label=&quot;Anchor link for: asynccomputer-trait&quot;&gt;&lt;code&gt;AsyncComputer&lt;&#x2F;code&gt; Trait&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;A new &lt;code&gt;AsyncComputer&lt;&#x2F;code&gt; trait has been introduced as the asynchronous counterpart to &lt;code&gt;Computer&lt;&#x2F;code&gt;. It is defined as follows:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_component {
&lt;&#x2F;span&gt;&lt;span&gt;    provider: AsyncComputer,
&lt;&#x2F;span&gt;&lt;span&gt;    derive_delegate: [
&lt;&#x2F;span&gt;&lt;span&gt;        UseDelegate&amp;lt;Code&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        UseInputDelegate&amp;lt;Input&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    ],
&lt;&#x2F;span&gt;&lt;span&gt;}]
&lt;&#x2F;span&gt;&lt;span&gt;#[async_trait]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;CanComputeAsync&amp;lt;Code, Input&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Output&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    async &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;compute_async(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self, _code: PhantomData&amp;lt;Code&amp;gt;, input: Input) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;Output;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;AsyncComputer&lt;&#x2F;code&gt; trait is more general than &lt;code&gt;Handler&lt;&#x2F;code&gt; because it does not require the function to return a &lt;code&gt;Result&lt;&#x2F;code&gt;. This design creates a clearer symmetry between the synchronous and asynchronous variants of the computation traits: &lt;code&gt;AsyncComputer&lt;&#x2F;code&gt; serves as the async version of &lt;code&gt;Computer&lt;&#x2F;code&gt;, while &lt;code&gt;Handler&lt;&#x2F;code&gt; serves as the async version of &lt;code&gt;TryComputer&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;With this addition, abstractions such as extensible visitors and monadic computations now implement their asynchronous logic using &lt;code&gt;AsyncComputer&lt;&#x2F;code&gt; rather than &lt;code&gt;Handler&lt;&#x2F;code&gt;. The same promotion pattern used in the synchronous counterparts is then applied to lift these implementations to &lt;code&gt;TryComputer&lt;&#x2F;code&gt; and &lt;code&gt;Handler&lt;&#x2F;code&gt;, maintaining consistency across both sync and async components.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;monadic-computation-pipeline&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#monadic-computation-pipeline&quot; aria-label=&quot;Anchor link for: monadic-computation-pipeline&quot;&gt;Monadic computation pipeline&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;The &lt;code&gt;cgp-monad&lt;&#x2F;code&gt; crate has been introduced to provide foundational support for monadic computation. This functionality simplifies the implementation of &lt;a href=&quot;&#x2F;blog&#x2F;extensible-datatypes-part-4&#x2F;#what-is-a-monad&quot;&gt;extensible visitors&lt;&#x2F;a&gt; by introducing a structured yet flexible way to handle composable computations.&lt;&#x2F;p&gt;
&lt;p&gt;Unlike the standard definition of monads in languages such as Haskell, the monadic implementation in CGP is &lt;em&gt;retroactive&lt;&#x2F;em&gt;. This means that existing Rust types like &lt;code&gt;Result&lt;&#x2F;code&gt; and &lt;code&gt;Option&lt;&#x2F;code&gt; can be treated as monads without requiring direct trait implementations on those types.&lt;&#x2F;p&gt;
&lt;p&gt;For example, instead of defining a monad as a higher-kinded type, CGP allows the extraction of inner value types from a monadic type using a monadic provider:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;ContainsValue&amp;lt;Output&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Value&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;T, E&amp;gt; ContainsValue&amp;lt;Result&amp;lt;T, E&amp;gt;&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;ErrMonadic {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Value &lt;&#x2F;span&gt;&lt;span&gt;= T;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In this example, the &lt;code&gt;ContainsValue&lt;&#x2F;code&gt; trait matches on an &lt;code&gt;Output&lt;&#x2F;code&gt; type and yields its underlying &lt;code&gt;Value&lt;&#x2F;code&gt; type. The &lt;code&gt;ErrMonadic&lt;&#x2F;code&gt; provider implements &lt;code&gt;ContainsValue&lt;&#x2F;code&gt; by extracting the value type &lt;code&gt;T&lt;&#x2F;code&gt; from a &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Instead of relying on the standard monadic &lt;code&gt;bind&lt;&#x2F;code&gt; operation, CGP introduces a &lt;em&gt;lifting&lt;&#x2F;em&gt; mechanism that wraps the input of a &lt;code&gt;Computer&lt;&#x2F;code&gt; provider:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;Context, Code, T1, T2, E, M, Cont&amp;gt; Computer&amp;lt;Context, Code, Result&amp;lt;T1, E&amp;gt;&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;BindErr&amp;lt;M, Cont&amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;    Cont: Computer&amp;lt;Context, Code, T1&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    M: ContainsValue&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Cont::&lt;&#x2F;span&gt;&lt;span&gt;Output, Value = Result&amp;lt;T2, E&amp;gt;&amp;gt; + ...,
&lt;&#x2F;span&gt;&lt;span&gt;{ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;... &lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In this case, the provider &lt;code&gt;BindErr&amp;lt;ErrMonadic, Cont&amp;gt;&lt;&#x2F;code&gt; wraps a provider &lt;code&gt;Cont&lt;&#x2F;code&gt; that implements &lt;code&gt;Computer&lt;&#x2F;code&gt; with an input type of &lt;code&gt;T1&lt;&#x2F;code&gt; and an output type of &lt;code&gt;Result&amp;lt;T2, E&amp;gt;&lt;&#x2F;code&gt;. It transforms it into a &lt;code&gt;Computer&lt;&#x2F;code&gt; provider that accepts &lt;code&gt;Result&amp;lt;T1, E&amp;gt;&lt;&#x2F;code&gt; as input and produces &lt;code&gt;Result&amp;lt;T2, E&amp;gt;&lt;&#x2F;code&gt; as output.&lt;&#x2F;p&gt;
&lt;p&gt;Conceptually, this corresponds to the following Haskell signature:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;bind :: (a -&amp;gt; m b) -&amp;gt; m a -&amp;gt; m b
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;which reverses the argument order of the standard bind operator &lt;code&gt;(&amp;gt;&amp;gt;=)&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;(&amp;gt;&amp;gt;=) :: m a -&amp;gt; (a -&amp;gt; m b) -&amp;gt; m b
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;By reversing the argument order, CGP effectively turns the bind operator into a higher-order function that &lt;em&gt;lifts&lt;&#x2F;em&gt; monadic functions, allowing them to be composed afterward through ordinary function composition.&lt;&#x2F;p&gt;
&lt;p&gt;At present, CGP’s monadic implementation requires separate bind implementations for synchronous and asynchronous computations. This limitation exists because stable Rust does not yet support &lt;a href=&quot;https:&#x2F;&#x2F;rust-lang.github.io&#x2F;impl-trait-initiative&#x2F;explainer&#x2F;tait.html&quot;&gt;impl trait in type aliases&lt;&#x2F;a&gt;, which prevents us to name anonymous &lt;code&gt;impl Future&lt;&#x2F;code&gt; as the &lt;code&gt;Output&lt;&#x2F;code&gt; type in &lt;code&gt;Computer&lt;&#x2F;code&gt;. Once this feature becomes stable, CGP will be able to extend monadic support to opaque types behind &lt;code&gt;impl Trait&lt;&#x2F;code&gt;, including &lt;code&gt;Future&lt;&#x2F;code&gt;, &lt;code&gt;Stream&lt;&#x2F;code&gt;, and &lt;code&gt;Iterator&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;A complete introduction to monadic computation within CGP deserves its own dedicated article. For now, the key takeaway is that CGP v0.5.0 establishes a foundational monadic layer that enables the development of more advanced abstractions, such as those seen in extensible visitors, and paves the way for future extensions of the framework.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;generate-static-str-from-symbols&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#generate-static-str-from-symbols&quot; aria-label=&quot;Anchor link for: generate-static-str-from-symbols&quot;&gt;Generate &lt;code&gt;&amp;amp;&#x27;static str&lt;&#x2F;code&gt; from symbols&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;The type produced by the &lt;code&gt;Symbol!&lt;&#x2F;code&gt; macro can now generically produce a &lt;code&gt;&amp;amp;&#x27;static str&lt;&#x2F;code&gt; value that can be used within generic code. For example:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;const &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;HELLO&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;#39;static str &lt;&#x2F;span&gt;&lt;span&gt;= &amp;lt;Symbol&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;hello&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as&lt;&#x2F;span&gt;&lt;span&gt; StaticString&amp;gt;::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;VALUE&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This functionality is provided through the &lt;code&gt;StaticString&lt;&#x2F;code&gt; trait along with a blanket implementation, defined as follows:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;StaticString {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;const &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;VALUE&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;#39;static str&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This represents a major breakthrough, as it allows actual &lt;code&gt;&amp;amp;&#x27;static str&lt;&#x2F;code&gt; values to be “passed” as types through generic parameters by encapsulating them in CGP symbol types, without requiring ad hoc implementations to be written.&lt;&#x2F;p&gt;
&lt;p&gt;Internally, a symbol such as &lt;code&gt;Symbol!(&quot;abc&quot;)&lt;&#x2F;code&gt; is expanded into:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;ψ&amp;lt;3, ζ&amp;lt;&amp;#39;a&amp;#39;, ζ&amp;lt;&amp;#39;b&amp;#39;, ζ&amp;lt;&amp;#39;c&amp;#39;, ε&amp;gt;&amp;gt;&amp;gt;&amp;gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;or, in a more human-readable form:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;Symbol&amp;lt;3, Chars&amp;lt;&amp;#39;a&amp;#39;, Chars&amp;lt;&amp;#39;b&amp;#39;, Chars&amp;lt;&amp;#39;c&amp;#39;, Nil&amp;gt;&amp;gt;&amp;gt;&amp;gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The value &lt;code&gt;3&lt;&#x2F;code&gt; in the first position represents the length of the symbol. This metadata is generated by the &lt;code&gt;Symbol!&lt;&#x2F;code&gt; macro starting from v0.5.0, enabling the reconstruction of the corresponding &lt;code&gt;&amp;amp;&#x27;static str&lt;&#x2F;code&gt; value during const evaluation.&lt;&#x2F;p&gt;
&lt;p&gt;This approach is necessary because, without it, full const generics support would be required to “count” the number of characters in a type, which is not yet available in stable Rust. By precomputing the length inside the &lt;code&gt;Symbol!&lt;&#x2F;code&gt; macro, it becomes possible to construct an array of the correct size and iterate within const evaluation to recreate the string value.&lt;&#x2F;p&gt;
&lt;p&gt;The ability to produce static strings is particularly valuable in generic code that needs to pass &lt;code&gt;&amp;amp;str&lt;&#x2F;code&gt; values to other functions, such as in &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;contextgeneric&#x2F;cgp-serde&#x2F;blob&#x2F;d7a08cf99f3a741e6eb16ae58f61af5fb5e5253c&#x2F;crates&#x2F;cgp-serde&#x2F;src&#x2F;providers&#x2F;fields.rs#L33-L59&quot;&gt;&lt;code&gt;cgp-serde&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;. Without this feature, a new &lt;code&gt;String&lt;&#x2F;code&gt; value would have to be reconstructed every time a function is called, which would significantly impact the performance of using symbols as string values.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h1 id=&quot;breaking-changes&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#breaking-changes&quot; aria-label=&quot;Anchor link for: breaking-changes&quot;&gt;Breaking Changes&lt;&#x2F;a&gt;&lt;&#x2F;h1&gt;
&lt;p&gt;Alongside the new features, v0.5.0 introduces several breaking changes. These updates are part of the ongoing effort to prepare for eventual v1 stabilization, ensuring that any necessary breaking changes are made early rather than later.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;removal-of-async-and-send-bounds-for-async-constructs&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#removal-of-async-and-send-bounds-for-async-constructs&quot; aria-label=&quot;Anchor link for: removal-of-async-and-send-bounds-for-async-constructs&quot;&gt;Removal of &lt;code&gt;Async&lt;&#x2F;code&gt; and &lt;code&gt;Send&lt;&#x2F;code&gt; bounds for async constructs&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;The most significant breaking change in this release is the removal of the &lt;code&gt;Async&lt;&#x2F;code&gt; trait, which was previously defined as:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;Async: Send + Sync {}
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;T: Send &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;+ &lt;&#x2F;span&gt;&lt;span&gt;Sync&amp;gt; Async &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;T {}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In earlier versions of CGP, the &lt;code&gt;Async&lt;&#x2F;code&gt; trait served as an alias for &lt;code&gt;Send + Sync&lt;&#x2F;code&gt;. It was used in trait bounds for abstract types and generic parameters to ensure that the &lt;code&gt;Future&lt;&#x2F;code&gt; returned by generic async functions could implement &lt;code&gt;Send&lt;&#x2F;code&gt;. This requirement is common in functions such as &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;tokio&#x2F;latest&#x2F;tokio&#x2F;task&#x2F;fn.spawn.html&quot;&gt;&lt;code&gt;tokio::spawn&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;, and it has traditionally been one of the main reasons Rust developers annotate &lt;code&gt;Send + Sync&lt;&#x2F;code&gt; throughout their code.&lt;&#x2F;p&gt;
&lt;p&gt;In order to support Send-able futures, CGP code used to be full of boilerplate of the use of Async. It also makes it more complicated to support both async and sync use cases in CGP.&lt;&#x2F;p&gt;
&lt;p&gt;Prior to v0.5.0, CGP’s codebase relied heavily on &lt;code&gt;Async&lt;&#x2F;code&gt; bounds to helps ensure that generic async functions can be called within &lt;code&gt;tokio::spawn&lt;&#x2F;code&gt;, but it also introduced considerable boilerplate. It also made it cumbersome for CGP to support both synchronous and asynchronous use cases, requiring traits such as &lt;code&gt;HasAsyncErrorType&lt;&#x2F;code&gt; to act as aliases for &lt;code&gt;HasErrorType&amp;lt;Error: Async&amp;gt; + Async&lt;&#x2F;code&gt;. Maintaining both async and sync versions of similar traits was necessary so that non-async users could instantiate abstract types like &lt;code&gt;Error&lt;&#x2F;code&gt; with values that were not &lt;code&gt;Send&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;To improve ergonomics around &lt;code&gt;Send&lt;&#x2F;code&gt;-able futures, the Rust compiler team has been developing &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;issues&#x2F;109417&quot;&gt;Return Type Notation (RTN)&lt;&#x2F;a&gt;. RTN will allow developers to impose the &lt;code&gt;Send&lt;&#x2F;code&gt; bound on a &lt;code&gt;Future&lt;&#x2F;code&gt; retroactively, at the point where it is actually needed, such as when passing it to &lt;code&gt;tokio::spawn&lt;&#x2F;code&gt;. With RTN, async code using CGP could avoid the need for pervasive &lt;code&gt;Send + Sync&lt;&#x2F;code&gt; annotations.&lt;&#x2F;p&gt;
&lt;p&gt;However, RTN does not appear to be close to stabilization. As a result, CGP originally planned to keep the &lt;code&gt;Async&lt;&#x2F;code&gt; constructs for compatibility in the short term. The good news is that an alternative approach has been found to retroactively add the &lt;code&gt;Send&lt;&#x2F;code&gt; bound to futures &lt;em&gt;without&lt;&#x2F;em&gt; relying on RTN. This allows CGP to simplify its design and remove the redundant &lt;code&gt;Async&lt;&#x2F;code&gt; abstractions entirely, while still maintaining compatibility with common async workflows.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;emulating-rtn&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#emulating-rtn&quot; aria-label=&quot;Anchor link for: emulating-rtn&quot;&gt;Emulating RTN&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;The key idea is to introduce a second proxy trait that provides the same method as the original, but with the returned &lt;code&gt;Future&lt;&#x2F;code&gt; implementing &lt;code&gt;Send&lt;&#x2F;code&gt;. This proxy trait must be implemented manually by a concrete context, outside of CGP, but the implementation can forward to the original trait, which can still be implemented using CGP.&lt;&#x2F;p&gt;
&lt;p&gt;A complete example demonstrating the use of &lt;code&gt;tokio::spawn&lt;&#x2F;code&gt; is available &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;contextgeneric&#x2F;cgp&#x2F;blob&#x2F;a4878587d221af141bc238fb34e08e373239b4d3&#x2F;crates&#x2F;cgp-tests&#x2F;src&#x2F;tests&#x2F;async&#x2F;spawn.rs&quot;&gt;here&lt;&#x2F;a&gt; and &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;contextgeneric&#x2F;cgp-examples&#x2F;blob&#x2F;4469aa38fce125c0c50f2bf05ac5502f820076e7&#x2F;transfer&#x2F;src&#x2F;contexts&#x2F;app.rs#L125-L133&quot;&gt;here&lt;&#x2F;a&gt;. The example uses the &lt;code&gt;CanRun&lt;&#x2F;code&gt; trait, defined as:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_component(Runner)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;CanRun: HasErrorType {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;run(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self) -&amp;gt; impl Future&amp;lt;Output = Result&amp;lt;(), &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;Error&amp;gt;&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;To use &lt;code&gt;run&lt;&#x2F;code&gt; inside &lt;code&gt;tokio::spawn&lt;&#x2F;code&gt;, we define a proxy trait that adds the &lt;code&gt;Send&lt;&#x2F;code&gt; bound to the returned &lt;code&gt;Future&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_component(SendRunner)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;CanSendRun: Send + HasErrorType {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;send_run(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self) -&amp;gt; impl Future&amp;lt;Output = Result&amp;lt;(), &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;Error&amp;gt;&amp;gt; + Send;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;Runner&lt;&#x2F;code&gt; trait can still be used to implement context-generic providers, so we do not need to require &lt;code&gt;Send&lt;&#x2F;code&gt; on generic types. For example:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_new_provider]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;Context&amp;gt; Runner&amp;lt;Context&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;RunWithFooBar
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;    Context: HasFooBar, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; don&amp;#39;t need to require Context::FooBar:Send
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    async &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;run(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self) { &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;... &lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;If we need to call &lt;code&gt;CanRun&lt;&#x2F;code&gt; inside &lt;code&gt;tokio::spawn&lt;&#x2F;code&gt; within generic code, we can instead use &lt;code&gt;CanSendRun&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;spawn_and_run_foo_bar&amp;lt;
&lt;&#x2F;span&gt;&lt;span&gt;    Context: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;#39;static + &lt;&#x2F;span&gt;&lt;span&gt;CanSendRun&amp;lt;RunFooBar&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;(context: Context) {
&lt;&#x2F;span&gt;&lt;span&gt;    tokio::spawn(async &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;move &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let _ &lt;&#x2F;span&gt;&lt;span&gt;= context.send_run(PhantomData).await;
&lt;&#x2F;span&gt;&lt;span&gt;    })
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;When implementing a concrete context, we delegate &lt;code&gt;Runner&lt;&#x2F;code&gt; to &lt;code&gt;RunWithFooBar&lt;&#x2F;code&gt; and manually implement &lt;code&gt;SendRunner&lt;&#x2F;code&gt; by forwarding to &lt;code&gt;Runner&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_context]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;App { ... }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;delegate_components! {
&lt;&#x2F;span&gt;&lt;span&gt;    AppComponents {
&lt;&#x2F;span&gt;&lt;span&gt;        RunnerComponent:
&lt;&#x2F;span&gt;&lt;span&gt;            RunWithFooBar,
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[cgp_provider]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;SendRunner&amp;lt;App&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;AppComponents {
&lt;&#x2F;span&gt;&lt;span&gt;    async &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;send_run(context: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;App) -&amp;gt; Result&amp;lt;(), Error&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;        context.run(code).await
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;By directly implementing &lt;code&gt;SendRunner&lt;&#x2F;code&gt; for &lt;code&gt;App&lt;&#x2F;code&gt;, the trait system can access the concrete type and its associated types, allowing it to retroactively determine that the future returned by &lt;code&gt;run&lt;&#x2F;code&gt; implements &lt;code&gt;Send&lt;&#x2F;code&gt;. This effectively emulates RTN by implementing the proxy trait at the top level.&lt;&#x2F;p&gt;
&lt;p&gt;Using this approach, CGP is able remove all uses of &lt;code&gt;Async&lt;&#x2F;code&gt; without waiting for RTN to stabilize. Meanwhile, users who need &lt;code&gt;Send&lt;&#x2F;code&gt;-bound futures can rely on the proxy trait technique to recover the &lt;code&gt;Send&lt;&#x2F;code&gt; bound through the concrete context.&lt;&#x2F;p&gt;
&lt;p&gt;This hack is expected to be temporary. Once RTN is stabilized, the proxy traits can be eliminated entirely. Migrating to the proxy trait approach now is simpler than retaining &lt;code&gt;Async&lt;&#x2F;code&gt; long-term, and it avoids a potentially painful migration in the future if CGP becomes widely adopted.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;migration-advice&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#migration-advice&quot; aria-label=&quot;Anchor link for: migration-advice&quot;&gt;Migration Advice&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;For existing codebases that still rely on &lt;code&gt;Async&lt;&#x2F;code&gt; and the &lt;code&gt;Send&lt;&#x2F;code&gt;-safe variants such as &lt;code&gt;HasAsyncErrorType&lt;&#x2F;code&gt;, you can copy these definitions locally to continue using them in your projects.&lt;&#x2F;p&gt;
&lt;p&gt;Although CGP has removed the &lt;code&gt;Async&lt;&#x2F;code&gt; constructs, this does not prevent developers from enforcing &lt;code&gt;Send&lt;&#x2F;code&gt; bounds in their own code. The main impact is that all async traits officially defined by the &lt;code&gt;cgp&lt;&#x2F;code&gt; crate no longer impose a &lt;code&gt;Send&lt;&#x2F;code&gt; bound on the returned &lt;code&gt;Future&lt;&#x2F;code&gt;. If your project defines traits that require returned futures to implement &lt;code&gt;Send&lt;&#x2F;code&gt;, you may encounter issues when calling CGP’s async traits. In other words, the split between &lt;code&gt;Send&lt;&#x2F;code&gt; and non-&lt;code&gt;Send&lt;&#x2F;code&gt; only becomes an issue if your project aims to interop with the remaining CGP ecosystem.&lt;&#x2F;p&gt;
&lt;p&gt;In the short term, the easiest way to address this is to remove all &lt;code&gt;Send&lt;&#x2F;code&gt; bounds of async functions in your own codebase. If that is not practical, the simplest workaround is to define your own versions of the relevant CGP traits that explicitly include &lt;code&gt;Send&lt;&#x2F;code&gt; in the returned &lt;code&gt;Future&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Currently, there are only a small number of async traits in CGP, such as &lt;code&gt;CanRun&lt;&#x2F;code&gt;, &lt;code&gt;CanComputeAsync&lt;&#x2F;code&gt;, and &lt;code&gt;CanHandle&lt;&#x2F;code&gt;. Unless your project heavily relies on these abstractions, redefining these traits locally to include &lt;code&gt;Send&lt;&#x2F;code&gt; should be straightforward and require minimal effort.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;desugaring-of-symbols&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#desugaring-of-symbols&quot; aria-label=&quot;Anchor link for: desugaring-of-symbols&quot;&gt;Desugaring of &lt;code&gt;Symbols!&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;The &lt;code&gt;symbol!&lt;&#x2F;code&gt; macro has been renamed to &lt;code&gt;Symbol!&lt;&#x2F;code&gt; to better indicate that it desugars to a type rather than a value. In addition to the renaming, the macro now desugars to a different form.&lt;&#x2F;p&gt;
&lt;p&gt;Before v0.5.0, &lt;code&gt;symbol!(&quot;abc&quot;)&lt;&#x2F;code&gt; desugared to:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;ι&amp;lt;&amp;#39;a&amp;#39;, ι&amp;lt;&amp;#39;b&amp;#39;, ι&amp;lt;&amp;#39;c&amp;#39;, ε&amp;gt;&amp;gt;&amp;gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Starting from v0.5.0, it desugars to:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;ψ&amp;lt;3, ζ&amp;lt;&amp;#39;a&amp;#39;, ζ&amp;lt;&amp;#39;b&amp;#39;, ζ&amp;lt;&amp;#39;c&amp;#39;, ε&amp;gt;&amp;gt;&amp;gt;&amp;gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;ι&lt;&#x2F;code&gt; identifier has been replaced with &lt;code&gt;ζ&lt;&#x2F;code&gt; because using &lt;code&gt;ι&lt;&#x2F;code&gt; could trigger Rust’s &lt;code&gt;confusable_idents&lt;&#x2F;code&gt; warning if the variable &lt;code&gt;i&lt;&#x2F;code&gt; appears elsewhere in the code. Choosing &lt;code&gt;ζ&lt;&#x2F;code&gt; reduces the likelihood of such warnings.&lt;&#x2F;p&gt;
&lt;p&gt;Additionally, &lt;code&gt;ψ&lt;&#x2F;code&gt; is added at the head of the symbol type along with the length metadata. This enables the implementation of &lt;code&gt;StaticString&lt;&#x2F;code&gt;, allowing the construction of a &lt;code&gt;&amp;amp;&#x27;static str&lt;&#x2F;code&gt; without waiting for full const-generic support in Rust.&lt;&#x2F;p&gt;
&lt;p&gt;Finally, the &lt;code&gt;Char&lt;&#x2F;code&gt; type, previously an alias for &lt;code&gt;ζ&lt;&#x2F;code&gt;, has been renamed to &lt;code&gt;Chars&lt;&#x2F;code&gt; to better reflect that it represents a list of characters rather than a single character.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;reorganize-exports-in-cgp-field&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#reorganize-exports-in-cgp-field&quot; aria-label=&quot;Anchor link for: reorganize-exports-in-cgp-field&quot;&gt;Reorganize exports in &lt;code&gt;cgp-field&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;The &lt;code&gt;cgp-field&lt;&#x2F;code&gt; crate has grown significantly, so the exports have been reorganized into several submodules. For example, the &lt;code&gt;HasField&lt;&#x2F;code&gt; trait is now exported from &lt;code&gt;cgp::fields::traits::HasField&lt;&#x2F;code&gt; instead of the top-level path &lt;code&gt;cgp::fields::HasField&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;add-partial-prefix-to-derived-partial-data-types&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#add-partial-prefix-to-derived-partial-data-types&quot; aria-label=&quot;Anchor link for: add-partial-prefix-to-derived-partial-data-types&quot;&gt;Add &lt;code&gt;__Partial&lt;&#x2F;code&gt; prefix to derived partial data types&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Partial data types generated by extensible data type macros now receive a &lt;code&gt;__Partial&lt;&#x2F;code&gt; prefix. This makes them effectively hidden and reduces the likelihood of name conflicts with user-defined structs.&lt;&#x2F;p&gt;
&lt;p&gt;For example, given:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[derive(CgpData)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;Person {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;name: String,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;age: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u8&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The derived partial data type is now named &lt;code&gt;__PartialPerson&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;__PartialPerson&amp;lt;F0: MapType, F1: MapType&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;name: F0::Map&amp;lt;String&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;age: F1::Map&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u8&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Prior to v0.5.0, the partial type was named &lt;code&gt;PartialPerson&lt;&#x2F;code&gt;, which could easily conflict with a user-defined struct of the same name in the same module.&lt;&#x2F;p&gt;
&lt;p&gt;This breaking change should not affect most existing code, as partial data types are not intended to be used directly by end users.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;add-code-parameter-to-canrun&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#add-code-parameter-to-canrun&quot; aria-label=&quot;Anchor link for: add-code-parameter-to-canrun&quot;&gt;Add &lt;code&gt;Code&lt;&#x2F;code&gt; parameter to &lt;code&gt;CanRun&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;The &lt;code&gt;CanRun&lt;&#x2F;code&gt; trait has been updated to include a &lt;code&gt;Code&lt;&#x2F;code&gt; parameter:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_component {
&lt;&#x2F;span&gt;&lt;span&gt;    provider: Runner,
&lt;&#x2F;span&gt;&lt;span&gt;    derive_delegate: UseDelegate&amp;lt;Code&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}]
&lt;&#x2F;span&gt;&lt;span&gt;#[async_trait]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;CanRun&amp;lt;Code&amp;gt;: HasErrorType {
&lt;&#x2F;span&gt;&lt;span&gt;    async &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;run(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self, _code: PhantomData&amp;lt;Code&amp;gt;) -&amp;gt; Result&amp;lt;(), &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;Error&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Prior to v0.5.0, the trait was defined as:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_component(Runner)]
&lt;&#x2F;span&gt;&lt;span&gt;#[async_trait]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;CanRun: HasErrorType {
&lt;&#x2F;span&gt;&lt;span&gt;    async &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;run(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self) -&amp;gt; Result&amp;lt;(), &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;Error&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;Code&lt;&#x2F;code&gt; parameter allows embedding type-level DSLs for running top-level functions, similar to how &lt;code&gt;Code&lt;&#x2F;code&gt; is used in &lt;code&gt;Computer&lt;&#x2F;code&gt; and &lt;code&gt;Handler&lt;&#x2F;code&gt; for DSLs like &lt;a href=&quot;&#x2F;blog&#x2F;hypershell-release&#x2F;&quot;&gt;Hypershell&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;For existing users who wish to continue using the original &lt;code&gt;CanRun&lt;&#x2F;code&gt; trait without migrating, you can copy the previous definition into your project and continue using it locally.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;removal-of-hasinner-trait&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#removal-of-hasinner-trait&quot; aria-label=&quot;Anchor link for: removal-of-hasinner-trait&quot;&gt;Removal of &lt;code&gt;HasInner&lt;&#x2F;code&gt; trait&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;The &lt;code&gt;HasInner&lt;&#x2F;code&gt; trait has been removed, along with the &lt;code&gt;cgp-inner&lt;&#x2F;code&gt; crate. It was previously defined as:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_component {
&lt;&#x2F;span&gt;&lt;span&gt;    name: InnerComponent,
&lt;&#x2F;span&gt;&lt;span&gt;    provider: ProvideInner,
&lt;&#x2F;span&gt;&lt;span&gt;}]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;HasInner {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Inner&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;inner(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;Self::&lt;&#x2F;span&gt;&lt;span&gt;Inner;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The functionality provided by &lt;code&gt;HasInner&lt;&#x2F;code&gt; has largely been superseded by the &lt;code&gt;UseField&lt;&#x2F;code&gt; pattern, which enables more flexible composition of multiple contexts.&lt;&#x2F;p&gt;
&lt;p&gt;For existing users who wish to continue using the original &lt;code&gt;HasInner&lt;&#x2F;code&gt; trait without migrating, you can copy its previous definition into your project and use it locally.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;improvements&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#improvements&quot; aria-label=&quot;Anchor link for: improvements&quot;&gt;Improvements&lt;&#x2F;a&gt;&lt;&#x2F;h1&gt;
&lt;p&gt;Several improvements have been made to existing constructs in CGP. Here are some highlights.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;allow-non-self-argument-in-getter-methods&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#allow-non-self-argument-in-getter-methods&quot; aria-label=&quot;Anchor link for: allow-non-self-argument-in-getter-methods&quot;&gt;Allow non-self argument in getter methods&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;It is now possible to use &lt;code&gt;#[cgp_getter]&lt;&#x2F;code&gt; and &lt;code&gt;#[cgp_auto_getter]&lt;&#x2F;code&gt; with target types other than &lt;code&gt;Self&lt;&#x2F;code&gt;. For example, you can now define a trait like:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_getter]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;HasFooBar: HasFooType + HasBarType {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;foo_bar(foo: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;Self::&lt;&#x2F;span&gt;&lt;span&gt;Foo) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;Self::&lt;&#x2F;span&gt;&lt;span&gt;Bar;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;With this, the provider &lt;code&gt;UseField&amp;lt;Symbol!(&quot;bar&quot;)&amp;gt;&lt;&#x2F;code&gt; would implement &lt;code&gt;FooBarGetter&amp;lt;Context&amp;gt;&lt;&#x2F;code&gt; if &lt;code&gt;Context::Foo&lt;&#x2F;code&gt; implements &lt;code&gt;HasField&amp;lt;Symbol!(&quot;bar&quot;), Value = Context::Bar&amp;gt;&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;support-use-of-lifetime-parameters-inside-cgp-traits&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#support-use-of-lifetime-parameters-inside-cgp-traits&quot; aria-label=&quot;Anchor link for: support-use-of-lifetime-parameters-inside-cgp-traits&quot;&gt;Support use of lifetime parameters inside CGP traits&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Lifetimes can now be included inside component trait parameters. For instance, &lt;code&gt;cgp-serde&lt;&#x2F;code&gt; defines a component corresponding to &lt;code&gt;serde&lt;&#x2F;code&gt;&#x27;s &lt;code&gt;Deserialize&lt;&#x2F;code&gt; as follows:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_component {
&lt;&#x2F;span&gt;&lt;span&gt;    provider: ValueDeserializer,
&lt;&#x2F;span&gt;&lt;span&gt;    derive_delegate: UseDelegate&amp;lt;Value&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;CanDeserializeValue&amp;lt;&amp;#39;de, Value&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;deserialize&amp;lt;D&amp;gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self, deserializer: D) -&amp;gt; Result&amp;lt;Value, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;D::&lt;&#x2F;span&gt;&lt;span&gt;Error&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;        D: serde::Deserializer&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;#39;de&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Within the type parameters of &lt;code&gt;IsProviderFor&lt;&#x2F;code&gt;, the lifetime &lt;code&gt;&#x27;de&lt;&#x2F;code&gt; is captured as &lt;code&gt;Life&amp;lt;&#x27;de&amp;gt;&lt;&#x2F;code&gt;, which is defined as:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;Life&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;#39;a&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;(pub PhantomData&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*mut &amp;amp;&amp;#39;a &lt;&#x2F;span&gt;&lt;span&gt;()&amp;gt;);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Using &lt;code&gt;Life&lt;&#x2F;code&gt;, the lifetime can be referred to inside &lt;code&gt;check_components!&lt;&#x2F;code&gt;, as in the following example:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;check_components! {
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;#39;de&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; CanDeserializeApp &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt; App {
&lt;&#x2F;span&gt;&lt;span&gt;        ValueDeserializerComponent: [
&lt;&#x2F;span&gt;&lt;span&gt;            (Life&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;#39;de&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u64&lt;&#x2F;span&gt;&lt;span&gt;),
&lt;&#x2F;span&gt;&lt;span&gt;            (Life&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;#39;de&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;, String),
&lt;&#x2F;span&gt;&lt;span&gt;        ]
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;shortcut-for-overriding-provider-names-in-cgp-type-and-cgp-getter&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#shortcut-for-overriding-provider-names-in-cgp-type-and-cgp-getter&quot; aria-label=&quot;Anchor link for: shortcut-for-overriding-provider-names-in-cgp-type-and-cgp-getter&quot;&gt;Shortcut for overriding provider names in &lt;code&gt;#[cgp_type]&lt;&#x2F;code&gt; and &lt;code&gt;#[cgp_getter]&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;You can now customize only the name of the provider trait in &lt;code&gt;#[cgp_type]&lt;&#x2F;code&gt; and &lt;code&gt;#[cgp_getter]&lt;&#x2F;code&gt; without using the fully qualified key-value syntax.&lt;&#x2F;p&gt;
&lt;p&gt;For example:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_type(FooTypeProviderComponent)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;HasFooType {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Foo&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[cgp_getter(FooGettterComponent)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;HasFoo: HasFooType {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;foo(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;Self::&lt;&#x2F;span&gt;&lt;span&gt;Foo;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;is equivalent to:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_type {
&lt;&#x2F;span&gt;&lt;span&gt;    provider: FooTypeProviderComponent,
&lt;&#x2F;span&gt;&lt;span&gt;}]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;HasFooType {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Foo&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[cgp_getter {
&lt;&#x2F;span&gt;&lt;span&gt;    provider: FooGettterComponent,
&lt;&#x2F;span&gt;&lt;span&gt;}]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;HasFoo: HasFooType {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;foo(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;Self::&lt;&#x2F;span&gt;&lt;span&gt;Foo;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;hr &#x2F;&gt;
&lt;h1 id=&quot;bug-fixes&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#bug-fixes&quot; aria-label=&quot;Anchor link for: bug-fixes&quot;&gt;Bug Fixes&lt;&#x2F;a&gt;&lt;&#x2F;h1&gt;
&lt;h2 id=&quot;fix-use-of-new-in-delegate-components-when-keys-array-is-used&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#fix-use-of-new-in-delegate-components-when-keys-array-is-used&quot; aria-label=&quot;Anchor link for: fix-use-of-new-in-delegate-components-when-keys-array-is-used&quot;&gt;Fix use of &lt;code&gt;new&lt;&#x2F;code&gt; in &lt;code&gt;delegate_components!&lt;&#x2F;code&gt; when keys array is used&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;A bug in &lt;code&gt;delegate_components!&lt;&#x2F;code&gt; has been fixed that occurred when value expressions like &lt;code&gt;UseDelegate&amp;lt;new InnerComponents { ... }&amp;gt;&lt;&#x2F;code&gt; were used with multiple keys in a list.&lt;&#x2F;p&gt;
&lt;p&gt;For example:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;delegate_components! {
&lt;&#x2F;span&gt;&lt;span&gt;    MyAppComponents {
&lt;&#x2F;span&gt;&lt;span&gt;        [
&lt;&#x2F;span&gt;&lt;span&gt;            FooComponent,
&lt;&#x2F;span&gt;&lt;span&gt;            BarComponent,
&lt;&#x2F;span&gt;&lt;span&gt;        ]:
&lt;&#x2F;span&gt;&lt;span&gt;            UseDelegate&amp;lt;new InnerComponents &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u64&lt;&#x2F;span&gt;&lt;span&gt;: HandleNumber,
&lt;&#x2F;span&gt;&lt;span&gt;                String: HandleString,
&lt;&#x2F;span&gt;&lt;span&gt;            }&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Previously, the inner struct &lt;code&gt;InnerComponents&lt;&#x2F;code&gt; would be expanded twice. With this fix, &lt;code&gt;InnerComponents&lt;&#x2F;code&gt; is expanded only once, regardless of the number of keys in the delegate entry.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;other-updates&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#other-updates&quot; aria-label=&quot;Anchor link for: other-updates&quot;&gt;Other Updates&lt;&#x2F;a&gt;&lt;&#x2F;h1&gt;
&lt;h2 id=&quot;rustlab-presentation&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#rustlab-presentation&quot; aria-label=&quot;Anchor link for: rustlab-presentation&quot;&gt;RustLab Presentation&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Next month in November, I will be presenting about CGP at &lt;a href=&quot;https:&#x2F;&#x2F;rustlab.it&#x2F;talks&#x2F;how-to-stop-fighting-with-coherence-and-start-writing-context-generic-trait-impls&quot;&gt;RustLab&lt;&#x2F;a&gt; in Florence. The presentation is titled &lt;a href=&quot;https:&#x2F;&#x2F;rustlab.it&#x2F;talks&#x2F;how-to-stop-fighting-with-coherence-and-start-writing-context-generic-trait-impls&quot;&gt;How to Stop Fighting with Coherence and Start Writing Context-Generic Trait Impls&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;If you are interested in attending, you can use the discount code &lt;code&gt;SP20FR&lt;&#x2F;code&gt; for a 20% discount.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;cgp-serde&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#cgp-serde&quot; aria-label=&quot;Anchor link for: cgp-serde&quot;&gt;&lt;code&gt;cgp-serde&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Alongside the RustLab presentation, I am working on &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;contextgeneric&#x2F;cgp-serde&quot;&gt;&lt;code&gt;cgp-serde&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;, which provides an extensible version of the popular &lt;code&gt;serde&lt;&#x2F;code&gt; crate. Here is a sneak preview of its capabilities.&lt;&#x2F;p&gt;
&lt;p&gt;The crate offers context-generic versions of the &lt;code&gt;Serialize&lt;&#x2F;code&gt; and &lt;code&gt;Deserialize&lt;&#x2F;code&gt; traits:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_component {
&lt;&#x2F;span&gt;&lt;span&gt;    provider: ValueSerializer,
&lt;&#x2F;span&gt;&lt;span&gt;    derive_delegate: UseDelegate&amp;lt;Value&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;CanSerializeValue&amp;lt;Value: ?Sized&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;serialize&amp;lt;S&amp;gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self, value: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;Value, serializer: S) -&amp;gt; Result&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;S::&lt;&#x2F;span&gt;&lt;span&gt;Ok, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;S::&lt;&#x2F;span&gt;&lt;span&gt;Error&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;        S: serde::Serializer;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[cgp_component {
&lt;&#x2F;span&gt;&lt;span&gt;    provider: ValueDeserializer,
&lt;&#x2F;span&gt;&lt;span&gt;    derive_delegate: UseDelegate&amp;lt;Value&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;CanDeserializeValue&amp;lt;&amp;#39;de, Value&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;deserialize&amp;lt;D&amp;gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self, deserializer: D) -&amp;gt; Result&amp;lt;Value, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;D::&lt;&#x2F;span&gt;&lt;span&gt;Error&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;        D: serde::Deserializer&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;#39;de&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;cgp-serde&lt;&#x2F;code&gt; traits remain compatible with the original &lt;code&gt;serde&lt;&#x2F;code&gt; traits. This allows reuse of existing &lt;code&gt;serde&lt;&#x2F;code&gt; implementations without reimplementing them for &lt;code&gt;cgp-serde&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;In addition, &lt;code&gt;cgp-serde&lt;&#x2F;code&gt; allows customizing how specific field types are serialized. For example, &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;&#x2F;code&gt; or &lt;code&gt;Datetime&lt;&#x2F;code&gt; can be serialized in a custom manner without being restricted by trait coherence rules.&lt;&#x2F;p&gt;
&lt;p&gt;Another key feature of &lt;code&gt;cgp-serde&lt;&#x2F;code&gt; is that it enables the use of &lt;a href=&quot;https:&#x2F;&#x2F;tmandry.gitlab.io&#x2F;blog&#x2F;posts&#x2F;2021-12-21-context-capabilities&#x2F;&quot;&gt;context and capabilities&lt;&#x2F;a&gt; patterns with &lt;code&gt;serde&lt;&#x2F;code&gt;. For instance, here is a provider implementation that allocates memory for a value type using an arena allocator provided by the context:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_new_provider]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;#39;de&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;#39;a&lt;&#x2F;span&gt;&lt;span&gt;, Context, Value&amp;gt; ValueDeserializer&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;#39;de&lt;&#x2F;span&gt;&lt;span&gt;, Context, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;#39;a&lt;&#x2F;span&gt;&lt;span&gt; Value&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    for DeserializeAndAllocate
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;    Context: CanAlloc&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;#39;a&lt;&#x2F;span&gt;&lt;span&gt;, Value&amp;gt; + CanDeserializeValue&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;#39;de&lt;&#x2F;span&gt;&lt;span&gt;, Value&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;deserialize&amp;lt;D&amp;gt;(context: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;Context, deserializer: D) -&amp;gt; Result&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;#39;a&lt;&#x2F;span&gt;&lt;span&gt; Value, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;D::&lt;&#x2F;span&gt;&lt;span&gt;Error&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;        D: serde::Deserializer&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;#39;de&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; value = context.deserialize(deserializer)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;?&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; value = context.alloc(value);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        Ok(value)
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This allows the implementation of a deserialization context that provides an arena allocator and uses it to deserialize into a &lt;code&gt;&amp;amp;&#x27;a Value&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;An example of a deserializer context with custom deserializer providers is shown below:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[derive(CgpData)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;Payload { ... }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[cgp_context]
&lt;&#x2F;span&gt;&lt;span&gt;#[derive(HasField)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;App&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;#39;a&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;arena: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;#39;a &lt;&#x2F;span&gt;&lt;span&gt;Arena&amp;lt;Payload&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;delegate_components! {
&lt;&#x2F;span&gt;&lt;span&gt;    AppComponents {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        ValueDeserializerComponent:
&lt;&#x2F;span&gt;&lt;span&gt;            UseDelegate&amp;lt;new DeserializeComponents &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u64&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;                    UseSerde,
&lt;&#x2F;span&gt;&lt;span&gt;                Vec&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u8&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;:
&lt;&#x2F;span&gt;&lt;span&gt;                    DeserializeHex,
&lt;&#x2F;span&gt;&lt;span&gt;                Payload:
&lt;&#x2F;span&gt;&lt;span&gt;                    DeserializeRecordFields,
&lt;&#x2F;span&gt;&lt;span&gt;                &amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;#39;a&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;#39;a&lt;&#x2F;span&gt;&lt;span&gt; Payload:
&lt;&#x2F;span&gt;&lt;span&gt;                    DeserializeAndAllocate,
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;            }&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;As we can see in the above example, within the wiring for &lt;code&gt;ValueDeserializerComponent&lt;&#x2F;code&gt;, we use &lt;code&gt;UseDelegate&lt;&#x2F;code&gt; to create a table lookup for deserialization implementations corresponding to different value types. First, &lt;code&gt;UseSerde&lt;&#x2F;code&gt; is used to implement deserialization via the original &lt;code&gt;Deserialize&lt;&#x2F;code&gt; trait from &lt;code&gt;serde&lt;&#x2F;code&gt;. After that, &lt;code&gt;DeserializeHex&lt;&#x2F;code&gt; handles the conversion of a hex string into a &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Next, &lt;code&gt;DeserializeRecordFields&lt;&#x2F;code&gt; is applied to deserialize each field in the &lt;code&gt;Payload&lt;&#x2F;code&gt; struct using their respective value deserializers. This functionality is enabled by the &lt;code&gt;#[derive(CgpData)]&lt;&#x2F;code&gt; attribute on &lt;code&gt;Payload&lt;&#x2F;code&gt;. The example also illustrates that it is not necessary to derive any serialization traits on &lt;code&gt;Payload&lt;&#x2F;code&gt; to make it work with &lt;code&gt;cgp-serde&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Finally, &lt;code&gt;DeserializeAndAllocate&lt;&#x2F;code&gt; is used to deserialize a &lt;code&gt;&amp;amp;&#x27;a Payload&lt;&#x2F;code&gt; value by allocating the payload in the arena allocator provided by the context.&lt;&#x2F;p&gt;
&lt;p&gt;There are many additional details that will be explained further with the official release of &lt;code&gt;cgp-serde&lt;&#x2F;code&gt;. The crate is nearly ready, with the remaining work focused on documentation. I will also demonstrate &lt;code&gt;cgp-serde&lt;&#x2F;code&gt; at &lt;a href=&quot;https:&#x2F;&#x2F;rustlab.it&#x2F;talks&#x2F;how-to-stop-fighting-with-coherence-and-start-writing-context-generic-trait-impls&quot;&gt;RustLab&lt;&#x2F;a&gt;. If you are interested in learning more, join the conference to see it in action.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;acknowledgement&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#acknowledgement&quot; aria-label=&quot;Anchor link for: acknowledgement&quot;&gt;Acknowledgement&lt;&#x2F;a&gt;&lt;&#x2F;h1&gt;
&lt;p&gt;Thank you April Gonçalves, Abhishek Tripathi and Dzmitry Lahoda for &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;sponsors&#x2F;soareschen&quot;&gt;sponsoring&lt;&#x2F;a&gt; the development of CGP!&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>Programming Extensible Data Types in Rust with CGP - Part 4: Implementing Extensible Variants</title>
        <published>2025-07-30T00:00:00+00:00</published>
        <updated>2025-07-30T00:00:00+00:00</updated>
        
        <author>
          <name>
            Soares Chen
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://www.contextgeneric.dev/blog/extensible-datatypes-part-4/"/>
        <id>https://www.contextgeneric.dev/blog/extensible-datatypes-part-4/</id>
        
        <content type="html" xml:base="https://www.contextgeneric.dev/blog/extensible-datatypes-part-4/">&lt;p&gt;Discuss on &lt;a href=&quot;https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;rust&#x2F;comments&#x2F;1md3emg&#x2F;the_design_and_implementation_of_extensible&#x2F;&quot;&gt;Reddit&lt;&#x2F;a&gt;, &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;orgs&#x2F;contextgeneric&#x2F;discussions&#x2F;16&quot;&gt;GitHub&lt;&#x2F;a&gt; or &lt;a href=&quot;https:&#x2F;&#x2F;discord.gg&#x2F;Hgk3rCw6pQ&quot;&gt;Discord&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;recap&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#recap&quot; aria-label=&quot;Anchor link for: recap&quot;&gt;Recap&lt;&#x2F;a&gt;&lt;&#x2F;h1&gt;
&lt;p&gt;This is the &lt;strong&gt;fourth&lt;&#x2F;strong&gt; part of the blog series on &lt;strong&gt;Programming Extensible Data Types in Rust with CGP&lt;&#x2F;strong&gt;. You can read the &lt;a href=&quot;&#x2F;blog&#x2F;extensible-datatypes-part-1&quot;&gt;first&lt;&#x2F;a&gt;, &lt;a href=&quot;&#x2F;blog&#x2F;extensible-datatypes-part-2&quot;&gt;second&lt;&#x2F;a&gt; and &lt;a href=&quot;&#x2F;blog&#x2F;extensible-datatypes-part-3&quot;&gt;third&lt;&#x2F;a&gt; parts here.&lt;&#x2F;p&gt;
&lt;p&gt;As a recap, we have covered the new release of &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;contextgeneric&#x2F;cgp&#x2F;releases&#x2F;tag&#x2F;v0.4.2&quot;&gt;&lt;strong&gt;CGP v0.4.2&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt; which now supports the use of &lt;strong&gt;extensible records and variants&lt;&#x2F;strong&gt;, allowing developers to write code that operates on &lt;em&gt;any struct containing specific fields&lt;&#x2F;em&gt; or &lt;em&gt;any enum containing specific variants&lt;&#x2F;em&gt;, without needing their concrete definition.&lt;&#x2F;p&gt;
&lt;p&gt;In the first part of the series, &lt;a href=&quot;&#x2F;blog&#x2F;extensible-datatypes-part-1&quot;&gt;&lt;strong&gt;Modular App Construction and Extensible Builders&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;, we demonstrated an example use of the &lt;strong&gt;extensible builder pattern&lt;&#x2F;strong&gt;, which uses &lt;strong&gt;extensible records&lt;&#x2F;strong&gt; to support modular construction of an application context.&lt;&#x2F;p&gt;
&lt;p&gt;Similarly, in the second part of the series, &lt;a href=&quot;&#x2F;blog&#x2F;extensible-datatypes-part-2&quot;&gt;&lt;strong&gt;Modular Interpreters and Extensible Visitors&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;, we saw how the modular visitor pattern allows us to implement evaluation and to-Lisp conversion for each variant of a language expression enum using separate visitor providers.&lt;&#x2F;p&gt;
&lt;p&gt;In the third part of the series, &lt;a href=&quot;&#x2F;blog&#x2F;extensible-datatypes-part-3&quot;&gt;&lt;strong&gt;Implementing Extensible Records&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;, we have walked through the internal implementation of extensible records, and learned about concepts such as partial records and builder dispatchers.&lt;&#x2F;p&gt;
&lt;p&gt;In this final fourth part of the series, we will have the same walk through for the internal implementation details for &lt;strong&gt;extensible variants&lt;&#x2F;strong&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;acknowledgement&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#acknowledgement&quot; aria-label=&quot;Anchor link for: acknowledgement&quot;&gt;Acknowledgement&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Thank you April Gonçalves for your generous donation support on &lt;a href=&quot;https:&#x2F;&#x2F;ko-fi.com&#x2F;maybevoid&quot;&gt;Ko-fi&lt;&#x2F;a&gt;! ☺️&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h1 id=&quot;the-design-and-implementation-of-extensible-variants&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-design-and-implementation-of-extensible-variants&quot; aria-label=&quot;Anchor link for: the-design-and-implementation-of-extensible-variants&quot;&gt;The Design and Implementation of Extensible Variants&lt;&#x2F;a&gt;&lt;&#x2F;h1&gt;
&lt;p&gt;Now that we&#x27;ve covered how extensible records work in CGP, we can turn our attention to &lt;strong&gt;extensible variants&lt;&#x2F;strong&gt;. At first glance, it might seem like a completely different mechanism — but surprisingly, the approach used to implement extensible variants is very similar to that of extensible records. In fact, many of the same principles apply, just in the “opposite direction”.&lt;&#x2F;p&gt;
&lt;p&gt;This close relationship between records and variants is rooted in &lt;strong&gt;category theory&lt;&#x2F;strong&gt;. In that context, records are known as &lt;strong&gt;products&lt;&#x2F;strong&gt;, while variants (or enums) are referred to as &lt;strong&gt;sums&lt;&#x2F;strong&gt; or &lt;strong&gt;coproducts&lt;&#x2F;strong&gt;. These terms highlight a deep &lt;strong&gt;duality&lt;&#x2F;strong&gt; between the two: just as products &lt;em&gt;combine&lt;&#x2F;em&gt; values, coproducts represent a &lt;em&gt;choice&lt;&#x2F;em&gt; among alternatives. CGP embraces this theoretical foundation and leverages it to create a unified design for both extensible records and extensible variants.&lt;&#x2F;p&gt;
&lt;p&gt;This duality is not just theoretical — it has practical implications for software architecture. Our design in CGP builds directly on prior research into &lt;strong&gt;extensible data types&lt;&#x2F;strong&gt;, particularly in the context of functional programming and type systems. For more on the background, see the paper on &lt;a href=&quot;https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;10.1145&#x2F;3290325&quot;&gt;Extensible Data Types&lt;&#x2F;a&gt;, as well as this excellent &lt;a href=&quot;https:&#x2F;&#x2F;bartoszmilewski.com&#x2F;2015&#x2F;01&#x2F;07&#x2F;products-and-coproducts&#x2F;&quot;&gt;intro to category theory&lt;&#x2F;a&gt; by Bartosz Milewski.&lt;&#x2F;p&gt;
&lt;p&gt;With this in mind, we’ll now explore the CGP constructs that support extensible variants. As you go through the examples and implementation details, we encourage you to look for the parallels and contrasts with extensible records.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h1 id=&quot;base-implementation&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#base-implementation&quot; aria-label=&quot;Anchor link for: base-implementation&quot;&gt;Base Implementation&lt;&#x2F;a&gt;&lt;&#x2F;h1&gt;
&lt;h2 id=&quot;fromvariant-trait&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#fromvariant-trait&quot; aria-label=&quot;Anchor link for: fromvariant-trait&quot;&gt;&lt;code&gt;FromVariant&lt;&#x2F;code&gt; Trait&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Just as extensible records use the &lt;code&gt;HasField&lt;&#x2F;code&gt; trait to extract values from a struct, extensible variants in CGP use the &lt;code&gt;FromVariant&lt;&#x2F;code&gt; trait to &lt;em&gt;construct&lt;&#x2F;em&gt; an enum from a single variant value. The trait is defined as follows:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;FromVariant&amp;lt;Tag&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Value&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;from_variant(_tag: PhantomData&amp;lt;Tag&amp;gt;, value: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;Value) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Like &lt;code&gt;HasField&lt;&#x2F;code&gt;, the &lt;code&gt;FromVariant&lt;&#x2F;code&gt; trait is parameterized by a &lt;code&gt;Tag&lt;&#x2F;code&gt;, which identifies the name of the variant. It also defines an associated &lt;code&gt;Value&lt;&#x2F;code&gt; type, representing the data associated with that variant. Unlike &lt;code&gt;HasField&lt;&#x2F;code&gt;, which extracts a value, &lt;code&gt;from_variant&lt;&#x2F;code&gt; takes in a &lt;code&gt;Value&lt;&#x2F;code&gt; and returns an instance of the enum.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;example-deriving-fromvariant&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#example-deriving-fromvariant&quot; aria-label=&quot;Anchor link for: example-deriving-fromvariant&quot;&gt;Example: Deriving &lt;code&gt;FromVariant&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;To see how this works in practice, consider the following &lt;code&gt;Shape&lt;&#x2F;code&gt; enum:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[derive(FromVariant)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub enum &lt;&#x2F;span&gt;&lt;span&gt;Shape {
&lt;&#x2F;span&gt;&lt;span&gt;    Circle(Circle),
&lt;&#x2F;span&gt;&lt;span&gt;    Rectangle(Rectangle),
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Using the &lt;code&gt;#[derive(FromVariant)]&lt;&#x2F;code&gt; macro, the following trait implementations will be automatically generated:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;FromVariant&amp;lt;Symbol&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;(&amp;quot;Circle&amp;quot;)&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;Shape {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Value &lt;&#x2F;span&gt;&lt;span&gt;= Circle;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;from_variant(_tag: PhantomData&amp;lt;Symbol&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;(&amp;quot;Circle&amp;quot;)&amp;gt;, value: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;Value) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        Shape::Circle(value)
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;FromVariant&amp;lt;Symbol&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;(&amp;quot;Rectangle&amp;quot;)&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;Shape {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Value &lt;&#x2F;span&gt;&lt;span&gt;= Rectangle;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;from_variant(_tag: PhantomData&amp;lt;Symbol&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;(&amp;quot;Rectangle&amp;quot;)&amp;gt;, value: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;Value) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        Shape::Rectangle(value)
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This allows the &lt;code&gt;Shape&lt;&#x2F;code&gt; enum to be constructed generically using just the tag and value.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;restrictions-on-enum-shape&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#restrictions-on-enum-shape&quot; aria-label=&quot;Anchor link for: restrictions-on-enum-shape&quot;&gt;Restrictions on Enum Shape&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;To ensure ergonomics and consistency, CGP restricts the kinds of enums that can derive &lt;code&gt;FromVariant&lt;&#x2F;code&gt;. Specifically, supported enums must follow the &lt;strong&gt;sums of products&lt;&#x2F;strong&gt; pattern — each variant must contain &lt;em&gt;exactly one unnamed field&lt;&#x2F;em&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;The following forms, for example, are &lt;strong&gt;not&lt;&#x2F;strong&gt; supported:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub enum &lt;&#x2F;span&gt;&lt;span&gt;Shape {
&lt;&#x2F;span&gt;&lt;span&gt;    Circle(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;f64&lt;&#x2F;span&gt;&lt;span&gt;),
&lt;&#x2F;span&gt;&lt;span&gt;    Rectangle(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;f64&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;f64&lt;&#x2F;span&gt;&lt;span&gt;),
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub enum &lt;&#x2F;span&gt;&lt;span&gt;Shape {
&lt;&#x2F;span&gt;&lt;span&gt;    Circle {
&lt;&#x2F;span&gt;&lt;span&gt;        radius: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;f64&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    },
&lt;&#x2F;span&gt;&lt;span&gt;    Rectangle {
&lt;&#x2F;span&gt;&lt;span&gt;        width: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;f64&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        height: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;f64&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    },
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;These more complex variants are not supported because they would make it harder to represent variant fields as simple types, which would, in turn, lead to less ergonomic APIs. By restricting each variant to a single unnamed field, CGP ensures that types like &lt;code&gt;FromVariant::Value&lt;&#x2F;code&gt; remain straightforward and intuitive.&lt;&#x2F;p&gt;
&lt;p&gt;If you need to represent more complex data in a variant, we recommend wrapping that data in a dedicated struct. This way, you can still take advantage of CGP&#x27;s extensible variant system while maintaining type clarity and composability.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;partial-variants&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#partial-variants&quot; aria-label=&quot;Anchor link for: partial-variants&quot;&gt;Partial Variants&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Just as CGP supports partially constructed structs through &lt;em&gt;partial records&lt;&#x2F;em&gt;, it also enables &lt;strong&gt;partial variants&lt;&#x2F;strong&gt; to work with &lt;strong&gt;partially deconstructed&lt;&#x2F;strong&gt; enums in a similarly flexible way. Partial variants allow you to pattern match on each variant of an enum incrementally, while safely excluding any variants that have already been handled. This makes it possible to build exhaustive and type-safe match chains that evolve over time.&lt;&#x2F;p&gt;
&lt;p&gt;Consider the &lt;code&gt;Shape&lt;&#x2F;code&gt; enum we explored earlier. CGP would generate a corresponding &lt;code&gt;PartialShape&lt;&#x2F;code&gt; enum that represents the partial variant form of &lt;code&gt;Shape&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub enum &lt;&#x2F;span&gt;&lt;span&gt;PartialShape&amp;lt;F0: MapType, F1: MapType&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    Circle(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;F0&lt;&#x2F;span&gt;&lt;span&gt;::Map&amp;lt;Circle&amp;gt;),
&lt;&#x2F;span&gt;&lt;span&gt;    Rectangle(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;F1&lt;&#x2F;span&gt;&lt;span&gt;::Map&amp;lt;Rectangle&amp;gt;),
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;hasextractor-trait&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#hasextractor-trait&quot; aria-label=&quot;Anchor link for: hasextractor-trait&quot;&gt;&lt;code&gt;HasExtractor&lt;&#x2F;code&gt; trait&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;To enable the transformation from a regular enum into its partial variant form, CGP provides the &lt;code&gt;HasExtractor&lt;&#x2F;code&gt; trait. This trait defines an associated type named &lt;code&gt;Extractor&lt;&#x2F;code&gt;, which represents the full set of partial variants for a given enum, and a method &lt;code&gt;to_extractor&lt;&#x2F;code&gt;, which performs the conversion:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;HasExtractor {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Extractor&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;to_extractor(self) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;Extractor;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;For the &lt;code&gt;Shape&lt;&#x2F;code&gt; enum, an implementation of &lt;code&gt;HasExtractor&lt;&#x2F;code&gt; would look like the following:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;HasExtractor &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;Shape {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Extractor &lt;&#x2F;span&gt;&lt;span&gt;= PartialShape&amp;lt;IsPresent, IsPresent&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;to_extractor(self) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;Extractor {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;match &lt;&#x2F;span&gt;&lt;span&gt;self {
&lt;&#x2F;span&gt;&lt;span&gt;            Shape::Circle(circle) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;PartialShape::Circle(circle),
&lt;&#x2F;span&gt;&lt;span&gt;            Shape::Rectangle(rectangle) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;PartialShape::Rectangle(rectangle),
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This implementation makes it possible to work with a &lt;code&gt;Shape&lt;&#x2F;code&gt; value as a &lt;code&gt;PartialShape&lt;&#x2F;code&gt;, where each variant is wrapped in an &lt;code&gt;IsPresent&lt;&#x2F;code&gt; marker, indicating that the variant is still available to be matched.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;isvoid-type-mapper&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#isvoid-type-mapper&quot; aria-label=&quot;Anchor link for: isvoid-type-mapper&quot;&gt;&lt;code&gt;IsVoid&lt;&#x2F;code&gt; Type Mapper&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;The key distinction between partial records and partial variants lies in how we represent the &lt;strong&gt;absence&lt;&#x2F;strong&gt; of data. For partial variants, CGP introduces the &lt;code&gt;IsVoid&lt;&#x2F;code&gt; type mapper to indicate that a variant has already been extracted and is no longer available:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub enum &lt;&#x2F;span&gt;&lt;span&gt;Void {}
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;IsVoid;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;MapType &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;IsVoid {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Map&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;T&amp;gt; = Void;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;Void&lt;&#x2F;code&gt; type is defined as an empty enum with no variants. This means that it is &lt;strong&gt;impossible&lt;&#x2F;strong&gt; to construct a value of type &lt;code&gt;Void&lt;&#x2F;code&gt;, and any code that attempts to match on a &lt;code&gt;Void&lt;&#x2F;code&gt; value will be statically unreachable. This makes it a safe and expressive way to model a variant that no longer exists in a given context.&lt;&#x2F;p&gt;
&lt;p&gt;Conceptually, &lt;code&gt;Void&lt;&#x2F;code&gt; serves the same purpose as Rust’s built-in &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;reference&#x2F;types&#x2F;never.html&quot;&gt;&lt;strong&gt;never type&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt; or the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;convert&#x2F;enum.Infallible.html&quot;&gt;&lt;code&gt;Infallible&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; type from the standard library. However, CGP defines &lt;code&gt;Void&lt;&#x2F;code&gt; explicitly to distinguish its special role in the context of extensible variants.&lt;&#x2F;p&gt;
&lt;p&gt;While &lt;code&gt;IsNothing&lt;&#x2F;code&gt; is used for absent fields in partial records, we use &lt;code&gt;IsVoid&lt;&#x2F;code&gt; to represent removed or matched variants in partial variants. This ensures that once a variant has been extracted, it cannot be matched again — preserving both soundness and safety in CGP’s type-driven pattern matching.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;extractfield-trait&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#extractfield-trait&quot; aria-label=&quot;Anchor link for: extractfield-trait&quot;&gt;&lt;code&gt;ExtractField&lt;&#x2F;code&gt; Trait&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Once an enum has been converted into its partial variant form, we can begin incrementally pattern matching on each variant using the &lt;code&gt;ExtractField&lt;&#x2F;code&gt; trait. This trait enables safe, step-by-step extraction of variant values, and is defined as follows:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;ExtractField&amp;lt;Tag&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Value&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Remainder&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;extract_field(self, _tag: PhantomData&amp;lt;Tag&amp;gt;) -&amp;gt; Result&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;Value, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;Remainder&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Just like &lt;code&gt;FromVariant&lt;&#x2F;code&gt; and &lt;code&gt;HasField&lt;&#x2F;code&gt;, the &lt;code&gt;ExtractField&lt;&#x2F;code&gt; trait takes a &lt;code&gt;Tag&lt;&#x2F;code&gt; type to identify the variant, and includes an associated &lt;code&gt;Value&lt;&#x2F;code&gt; type representing the variant’s inner data. Additionally, it defines a &lt;code&gt;Remainder&lt;&#x2F;code&gt; type, which represents the &lt;strong&gt;remaining&lt;&#x2F;strong&gt; variants that have not yet been matched.&lt;&#x2F;p&gt;
&lt;p&gt;The &lt;code&gt;extract_field&lt;&#x2F;code&gt; method consumes the value and returns a &lt;code&gt;Result&lt;&#x2F;code&gt;, where a successful match yields the extracted &lt;code&gt;Value&lt;&#x2F;code&gt;, and a failed match returns the &lt;code&gt;Remainder&lt;&#x2F;code&gt;. Although this uses the &lt;code&gt;Result&lt;&#x2F;code&gt; type, the &lt;code&gt;Err&lt;&#x2F;code&gt; case is not really an error in the traditional sense — rather, it represents the remaining variants yet to be handled, much like how errors represent alternative outcomes in Rust.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;example-implementation-of-extractfield&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#example-implementation-of-extractfield&quot; aria-label=&quot;Anchor link for: example-implementation-of-extractfield&quot;&gt;Example Implementation of &lt;code&gt;ExtractField&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;To understand how &lt;code&gt;ExtractField&lt;&#x2F;code&gt; works in practice, let’s look at an implementation for extracting the &lt;code&gt;Circle&lt;&#x2F;code&gt; variant from a &lt;code&gt;PartialShape&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;F1: MapType&amp;gt; ExtractField&amp;lt;Symbol&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;(&amp;quot;Circle&amp;quot;)&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;PartialShape&amp;lt;IsPresent, F1&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Value &lt;&#x2F;span&gt;&lt;span&gt;= Circle;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Remainder &lt;&#x2F;span&gt;&lt;span&gt;= PartialShape&amp;lt;IsVoid, F1&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;extract_field(self, _tag: PhantomData&amp;lt;Symbol&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;(&amp;quot;Circle&amp;quot;)&amp;gt;) -&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;        Result&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;Value, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;Remainder&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;match &lt;&#x2F;span&gt;&lt;span&gt;self {
&lt;&#x2F;span&gt;&lt;span&gt;            PartialShape::Circle(circle) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;Ok(circle),
&lt;&#x2F;span&gt;&lt;span&gt;            PartialShape::Rectangle(rectangle) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;Err(PartialShape::Rectangle(rectangle))
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In this implementation, we are working with a &lt;code&gt;PartialShape&lt;&#x2F;code&gt; in which the &lt;code&gt;Circle&lt;&#x2F;code&gt; variant is still marked as present. The trait is also generic over &lt;code&gt;F1: MapType&lt;&#x2F;code&gt;, which corresponds to the &lt;code&gt;Rectangle&lt;&#x2F;code&gt; variant, allowing the code to remain flexible regardless of whether the rectangle has already been extracted or not.&lt;&#x2F;p&gt;
&lt;p&gt;The associated &lt;code&gt;Remainder&lt;&#x2F;code&gt; type updates the &lt;code&gt;Circle&lt;&#x2F;code&gt; variant from &lt;code&gt;IsPresent&lt;&#x2F;code&gt; to &lt;code&gt;IsVoid&lt;&#x2F;code&gt;, signifying that it has been extracted and should no longer be considered valid. The use of the &lt;code&gt;Void&lt;&#x2F;code&gt; type ensures that this variant cannot be constructed again, making it safe to ignore in further matches.&lt;&#x2F;p&gt;
&lt;p&gt;Within the method body, we match on &lt;code&gt;self&lt;&#x2F;code&gt;. If the value is a &lt;code&gt;Circle&lt;&#x2F;code&gt;, we return it in the &lt;code&gt;Ok&lt;&#x2F;code&gt; case. Otherwise, we return the remaining &lt;code&gt;PartialShape&lt;&#x2F;code&gt;, reconstructing it with the other variant. Due to the type system’s enforcement, it is impossible to incorrectly return a &lt;code&gt;Circle&lt;&#x2F;code&gt; as part of the remainder once it has been marked as &lt;code&gt;IsVoid&lt;&#x2F;code&gt;. The compiler ensures that this branch is unreachable, preserving correctness by construction.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;example-use-of-extractfield&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#example-use-of-extractfield&quot; aria-label=&quot;Anchor link for: example-use-of-extractfield&quot;&gt;Example Use of &lt;code&gt;ExtractField&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;With &lt;code&gt;ExtractField&lt;&#x2F;code&gt;, we can now incrementally extract and match against variants in a safe and ergonomic way. Here’s an example of computing the area of a shape using this approach:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;compute_area(shape: Shape) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;f64 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;match&lt;&#x2F;span&gt;&lt;span&gt; shape
&lt;&#x2F;span&gt;&lt;span&gt;        .to_extractor() &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; PartialShape&amp;lt;IsPresent, IsPresent&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;        .extract_field(PhantomData::&amp;lt;Symbol&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Circle&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;)&amp;gt;)
&lt;&#x2F;span&gt;&lt;span&gt;    {
&lt;&#x2F;span&gt;&lt;span&gt;        Ok(circle) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;PI &lt;&#x2F;span&gt;&lt;span&gt;* circle.radius * circle.radius,
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; PartialShape&amp;lt;IsVoid, IsPresent&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;        Err(remainder) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; match&lt;&#x2F;span&gt;&lt;span&gt; remainder.extract_field(PhantomData::&amp;lt;Symbol&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Rectangle&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;)&amp;gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;            Ok(rectangle) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt; rectangle.width * rectangle.height,
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; PartialShape&amp;lt;IsVoid, IsVoid&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; No need to match on `Err`
&lt;&#x2F;span&gt;&lt;span&gt;        },
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In this example, we begin by converting the &lt;code&gt;Shape&lt;&#x2F;code&gt; value into a &lt;code&gt;PartialShape&lt;&#x2F;code&gt; with all variants present using &lt;code&gt;to_extractor&lt;&#x2F;code&gt;. We then call &lt;code&gt;extract_field&lt;&#x2F;code&gt; to try extracting the &lt;code&gt;Circle&lt;&#x2F;code&gt; variant. If successful, we compute the circle&#x27;s area. If not, we receive a remainder value where the &lt;code&gt;Circle&lt;&#x2F;code&gt; variant is now marked as &lt;code&gt;IsVoid&lt;&#x2F;code&gt;. This remainder is then used to attempt extracting the &lt;code&gt;Rectangle&lt;&#x2F;code&gt; variant. If that succeeds, we compute the area accordingly.&lt;&#x2F;p&gt;
&lt;p&gt;By the time we reach the second &lt;code&gt;Err&lt;&#x2F;code&gt; case, the remainder has the type &lt;code&gt;PartialShape&amp;lt;IsVoid, IsVoid&amp;gt;&lt;&#x2F;code&gt;, which cannot contain any valid variant. Because of this, we can safely omit any further pattern matching, and the compiler guarantees that there are no unreachable or unhandled cases.&lt;&#x2F;p&gt;
&lt;p&gt;What makes this approach so powerful is that the Rust type system can statically verify that it is impossible to construct a valid value for &lt;code&gt;PartialShape&amp;lt;IsVoid, IsVoid&amp;gt;&lt;&#x2F;code&gt;. We no longer need to write boilerplate &lt;code&gt;_ =&amp;gt; unreachable!()&lt;&#x2F;code&gt; code or use runtime assertions. The type system ensures exhaustiveness and soundness entirely at compile time, enabling safer and more maintainable implementation of extensible variants.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;short-circuiting-remainder&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#short-circuiting-remainder&quot; aria-label=&quot;Anchor link for: short-circuiting-remainder&quot;&gt;Short-Circuiting Remainder&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;In our earlier implementation of &lt;code&gt;compute_area&lt;&#x2F;code&gt;, we used nested &lt;code&gt;match&lt;&#x2F;code&gt; expressions to handle the &lt;code&gt;Result&lt;&#x2F;code&gt; returned from each call to &lt;code&gt;extract_field&lt;&#x2F;code&gt;. If you are familiar with the &lt;code&gt;?&lt;&#x2F;code&gt; operator in Rust, you might be wondering why we didn’t use it here to simplify the logic.&lt;&#x2F;p&gt;
&lt;p&gt;The reason is that we want to short circuit and return the &lt;code&gt;Ok&lt;&#x2F;code&gt; variant as soon as a match succeeds, while the &lt;code&gt;Err&lt;&#x2F;code&gt; case contains a remainder type that changes with each call to &lt;code&gt;extract_field&lt;&#x2F;code&gt;. This behavior is the inverse of how &lt;code&gt;Result&lt;&#x2F;code&gt; is typically used in Rust, where the &lt;code&gt;Err&lt;&#x2F;code&gt; variant is the one that gets returned early, and the &lt;code&gt;Ok&lt;&#x2F;code&gt; type changes as the computation progresses.&lt;&#x2F;p&gt;
&lt;p&gt;To better understand what we are trying to achieve, consider the following pseudocode that illustrates the intent more clearly:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;compute_area(shape: Shape) -&amp;gt; Result&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;f64&lt;&#x2F;span&gt;&lt;span&gt;, Infallible&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; remainder = shape
&lt;&#x2F;span&gt;&lt;span&gt;        .to_extractor()
&lt;&#x2F;span&gt;&lt;span&gt;        .extract_field(PhantomData::&amp;lt;Symbol&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Circle&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;)&amp;gt;)
&lt;&#x2F;span&gt;&lt;span&gt;        .map(|circle| &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;PI &lt;&#x2F;span&gt;&lt;span&gt;* circle.radius * circle.radius)⸮;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; remainder = remainder
&lt;&#x2F;span&gt;&lt;span&gt;        .extract_field(PhantomData::&amp;lt;Symbol&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Rectangle&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;)&amp;gt;)
&lt;&#x2F;span&gt;&lt;span&gt;        .map(|rectangle| rectangle.width * rectangle.height)⸮;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;match&lt;&#x2F;span&gt;&lt;span&gt; remainder {}
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In this pseudocode, we introduce a fictional operator &lt;code&gt;⸮&lt;&#x2F;code&gt;, which behaves like the opposite of &lt;code&gt;?&lt;&#x2F;code&gt;. Instead of short circuiting on &lt;code&gt;Err&lt;&#x2F;code&gt;, it short circuits on &lt;code&gt;Ok&lt;&#x2F;code&gt;, returning the value immediately. If the result is &lt;code&gt;Err&lt;&#x2F;code&gt;, it binds the remainder to the &lt;code&gt;remainder&lt;&#x2F;code&gt; variable and continues.&lt;&#x2F;p&gt;
&lt;p&gt;In this setup, each call to &lt;code&gt;extract_field&lt;&#x2F;code&gt; uses &lt;code&gt;.map&lt;&#x2F;code&gt; to transform a successful match into the final &lt;code&gt;f64&lt;&#x2F;code&gt; result. If the match succeeds, &lt;code&gt;⸮&lt;&#x2F;code&gt; returns early. Otherwise, we continue with the remainder, which gradually becomes more constrained until it is fully uninhabited. Once all variants have been tried, the final &lt;code&gt;match remainder {}&lt;&#x2F;code&gt; statically asserts that no remaining case is possible.&lt;&#x2F;p&gt;
&lt;p&gt;This highlights a subtle but important point: the &lt;code&gt;compute_area&lt;&#x2F;code&gt; function never actually returns an &lt;code&gt;Err&lt;&#x2F;code&gt; in practice. To satisfy the function’s signature, we return a &lt;code&gt;Result&amp;lt;f64, Infallible&amp;gt;&lt;&#x2F;code&gt;, where &lt;code&gt;Infallible&lt;&#x2F;code&gt; indicates that failure is not possible.&lt;&#x2F;p&gt;
&lt;p&gt;Some readers may suggest alternative approaches, such as flipping the result to &lt;code&gt;Result&amp;lt;Remainder, Value&amp;gt;&lt;&#x2F;code&gt; so that the &lt;code&gt;?&lt;&#x2F;code&gt; operator could be used to return the value directly. While that might make the surface syntax cleaner, it reverses the intuitive meaning of the result. In this case, &lt;code&gt;Remainder&lt;&#x2F;code&gt; is the exceptional path, and &lt;code&gt;Value&lt;&#x2F;code&gt; is what we expect when the extraction succeeds.&lt;&#x2F;p&gt;
&lt;p&gt;The introduction of &lt;code&gt;⸮&lt;&#x2F;code&gt; is not meant to advocate for a new language feature. Rather, it serves to clarify the control flow and encourage you to think about how this pattern relates to existing Rust constructs like &lt;code&gt;?&lt;&#x2F;code&gt;, &lt;code&gt;.await&lt;&#x2F;code&gt;, and combinations such as &lt;code&gt;.await?&lt;&#x2F;code&gt;. In practice, we do not need to manually write functions like &lt;code&gt;compute_area&lt;&#x2F;code&gt; or invent new operators. The extensible visitor pattern we will explore later provides a mechanism that effectively captures this logic for us.&lt;&#x2F;p&gt;
&lt;p&gt;We will revisit this idea when we discuss how the visitor pattern automates this process. For now, let’s continue by looking at how to finalize an empty remainder.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;finalizeextract-trait&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#finalizeextract-trait&quot; aria-label=&quot;Anchor link for: finalizeextract-trait&quot;&gt;&lt;code&gt;FinalizeExtract&lt;&#x2F;code&gt; Trait&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;While Rust’s type system can infer that a type like &lt;code&gt;PartialShape&amp;lt;IsVoid, IsVoid&amp;gt;&lt;&#x2F;code&gt; is uninhabitable, this inference only works when the compiler has access to the fully concrete type. To support this behavior more generically within CGP’s extensible variant system, the &lt;code&gt;FinalizeExtract&lt;&#x2F;code&gt; trait is introduced. This trait provides a mechanism to &lt;em&gt;discharge&lt;&#x2F;em&gt; an empty partial variant after all possible cases have been matched:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;FinalizeExtract {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;finalize_extract&amp;lt;T&amp;gt;(self) -&amp;gt; T;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;At first glance, the &lt;code&gt;finalize_extract&lt;&#x2F;code&gt; method might appear misleading. It accepts a &lt;code&gt;self&lt;&#x2F;code&gt; value and claims to return a value of &lt;em&gt;any&lt;&#x2F;em&gt; type &lt;code&gt;T&lt;&#x2F;code&gt;. This may seem unsound, but the key detail is that it is only ever implemented for types that are &lt;em&gt;uninhabited&lt;&#x2F;em&gt; — in other words, types that can never actually exist at runtime. Examples include &lt;code&gt;Void&lt;&#x2F;code&gt; and a fully exhausted partial variant like &lt;code&gt;PartialShape&amp;lt;IsVoid, IsVoid&amp;gt;&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;The implementation is both safe and surprisingly simple:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;FinalizeExtract &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;PartialShape&amp;lt;IsVoid, IsVoid&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;finalize_extract&amp;lt;T&amp;gt;(self) -&amp;gt; T {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;match &lt;&#x2F;span&gt;&lt;span&gt;self {}
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Here, we use an empty &lt;code&gt;match&lt;&#x2F;code&gt; expression on &lt;code&gt;self&lt;&#x2F;code&gt;, which works because the compiler knows that &lt;code&gt;PartialShape&amp;lt;IsVoid, IsVoid&amp;gt;&lt;&#x2F;code&gt; has no possible value. Since it is impossible to construct such a value, the match is guaranteed to be unreachable. Rust verifies this at compile time, ensuring both safety and correctness.&lt;&#x2F;p&gt;
&lt;p&gt;By leveraging the &lt;code&gt;Void&lt;&#x2F;code&gt; type in this way, CGP allows us to exhaustively extract every variant from a partial enum and confidently conclude that no cases remain. This eliminates the need for runtime assertions, unreachable branches, or panics. Instead, the type system itself guarantees that all variants have been handled, enabling a clean and fully type-safe approach to enum decomposition.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;finalizeextractresult-trait&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#finalizeextractresult-trait&quot; aria-label=&quot;Anchor link for: finalizeextractresult-trait&quot;&gt;&lt;code&gt;FinalizeExtractResult&lt;&#x2F;code&gt; Trait&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;When working with results of type &lt;code&gt;Result&amp;lt;Output, Remainder&amp;gt;&lt;&#x2F;code&gt;, where the &lt;code&gt;Remainder&lt;&#x2F;code&gt; type is guaranteed to be inhabitable, it is often useful to have a convenient way to directly extract the &lt;code&gt;Output&lt;&#x2F;code&gt; value. To achieve this, CGP defines the &lt;code&gt;FinalizeExtractResult&lt;&#x2F;code&gt; trait, which provides a helper method to finalize and unwrap such results. Its definition includes a blanket implementation for all &lt;code&gt;Result&lt;&#x2F;code&gt; types where the error type implements &lt;code&gt;FinalizeExtract&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;FinalizeExtractResult {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Output&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;finalize_extract_result(self) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;Output;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;T, E&amp;gt; FinalizeExtractResult &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;Result&amp;lt;T, E&amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;    E: FinalizeExtract,
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Output &lt;&#x2F;span&gt;&lt;span&gt;= T;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;finalize_extract_result(self) -&amp;gt; T {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;match &lt;&#x2F;span&gt;&lt;span&gt;self {
&lt;&#x2F;span&gt;&lt;span&gt;            Ok(value) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt; value,
&lt;&#x2F;span&gt;&lt;span&gt;            Err(remainder) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt; remainder.finalize_extract(),
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;With &lt;code&gt;FinalizeExtractResult&lt;&#x2F;code&gt;, any result value can call &lt;code&gt;finalize_extract_result()&lt;&#x2F;code&gt; to obtain the &lt;code&gt;Output&lt;&#x2F;code&gt; directly, as long as the remainder type implements &lt;code&gt;FinalizeExtract&lt;&#x2F;code&gt;. This allows functions that work with extractable variants to become simpler and more readable. For example, the implementation of &lt;code&gt;compute_area&lt;&#x2F;code&gt; can be written as:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;compute_area(shape: Shape) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;f64 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;match&lt;&#x2F;span&gt;&lt;span&gt; shape
&lt;&#x2F;span&gt;&lt;span&gt;        .to_extractor()
&lt;&#x2F;span&gt;&lt;span&gt;        .extract_field(PhantomData::&amp;lt;Symbol&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Circle&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;)&amp;gt;)
&lt;&#x2F;span&gt;&lt;span&gt;    {
&lt;&#x2F;span&gt;&lt;span&gt;        Ok(circle) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;PI &lt;&#x2F;span&gt;&lt;span&gt;* circle.radius * circle.radius,
&lt;&#x2F;span&gt;&lt;span&gt;        Err(remainder) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; rectangle = remainder
&lt;&#x2F;span&gt;&lt;span&gt;                .extract_field(PhantomData::&amp;lt;Symbol&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Rectangle&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;)&amp;gt;)
&lt;&#x2F;span&gt;&lt;span&gt;                .finalize_extract_result();
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;            rectangle.width * rectangle.height
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;When handling the remainder after the &lt;code&gt;Circle&lt;&#x2F;code&gt; variant was extracted, we use &lt;code&gt;finalize_extract_result&lt;&#x2F;code&gt; after calling &lt;code&gt;remainder.extract_field()&lt;&#x2F;code&gt; to get the &lt;code&gt;Rectangle&lt;&#x2F;code&gt; variant.&lt;&#x2F;p&gt;
&lt;p&gt;This trait provides a small but valuable ergonomic improvement, especially when performing generic extractions and finalizations. It allows developers to avoid repetitive pattern matching and ensures that the final output can be obtained with a single, clear method call.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h1 id=&quot;implementation-of-casts&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#implementation-of-casts&quot; aria-label=&quot;Anchor link for: implementation-of-casts&quot;&gt;Implementation of Casts&lt;&#x2F;a&gt;&lt;&#x2F;h1&gt;
&lt;p&gt;With the foundational traits for extensible variants in place, we can now explore how to implement the &lt;code&gt;CanUpcast&lt;&#x2F;code&gt; and &lt;code&gt;CanDowncast&lt;&#x2F;code&gt; traits. These traits enable safe and generic upcasting and downcasting between enums that share compatible variants.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;hasfields-implementation&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#hasfields-implementation&quot; aria-label=&quot;Anchor link for: hasfields-implementation&quot;&gt;&lt;code&gt;HasFields&lt;&#x2F;code&gt; Implementation&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Just as extensible records rely on &lt;code&gt;HasFields&lt;&#x2F;code&gt; for iterating over their fields, extensible variants use a similar mechanism to iterate over their variants. This allows the generic casting implementation to iterate over each variant of an enum.&lt;&#x2F;p&gt;
&lt;p&gt;For example, the &lt;code&gt;HasFields&lt;&#x2F;code&gt; implementation for the &lt;code&gt;Shape&lt;&#x2F;code&gt; enum is defined as follows:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;HasFields &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;Shape {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Fields &lt;&#x2F;span&gt;&lt;span&gt;= Sum&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;[
&lt;&#x2F;span&gt;&lt;span&gt;        Field&amp;lt;Symbol&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Circle&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;), Circle&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        Field&amp;lt;Symbol&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Rectangle&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;), Rectangle&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    ];
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Here, instead of using the &lt;code&gt;Product!&lt;&#x2F;code&gt; macro (which is used for structs), we use the &lt;code&gt;Sum!&lt;&#x2F;code&gt; macro to build a &lt;em&gt;type-level sum&lt;&#x2F;em&gt; representing all variants in the enum. The &lt;code&gt;Sum!&lt;&#x2F;code&gt; macro expands to a nested structure of &lt;code&gt;Either&lt;&#x2F;code&gt;, similar to how &lt;code&gt;Product!&lt;&#x2F;code&gt; expands into a chain of &lt;code&gt;Cons&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;For example, the &lt;code&gt;Sum!&lt;&#x2F;code&gt; expression above desugars to:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;HasFields &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;Shape {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Fields &lt;&#x2F;span&gt;&lt;span&gt;= Either&amp;lt;
&lt;&#x2F;span&gt;&lt;span&gt;        Field&amp;lt;Symbol&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;(&amp;quot;Circle&amp;quot;), Circle&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        Either&amp;lt;
&lt;&#x2F;span&gt;&lt;span&gt;            Field&amp;lt;Symbol&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;(&amp;quot;Rectangle&amp;quot;), Rectangle&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;            Void,
&lt;&#x2F;span&gt;&lt;span&gt;        &amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Where &lt;code&gt;Either&lt;&#x2F;code&gt; is defined in a similar fashion to Rust&#x27;s standard &lt;code&gt;Result&lt;&#x2F;code&gt; type, but with variant names that reflect the sum type structure:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub enum &lt;&#x2F;span&gt;&lt;span&gt;Either&amp;lt;A, B&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    Left(A),
&lt;&#x2F;span&gt;&lt;span&gt;    Right(B),
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In this way, we represent the enum&#x27;s variants as a nested sum, with &lt;code&gt;Void&lt;&#x2F;code&gt; as the terminating type to signify the end of the variant choices.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;canupcast-implementation&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#canupcast-implementation&quot; aria-label=&quot;Anchor link for: canupcast-implementation&quot;&gt;&lt;code&gt;CanUpcast&lt;&#x2F;code&gt; Implementation&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;With &lt;code&gt;HasFields&lt;&#x2F;code&gt; implemented, we are ready to define the &lt;code&gt;CanUpcast&lt;&#x2F;code&gt; trait. This trait allows a source enum to be upcasted to a target enum that is a superset of the source:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;CanUpcast&amp;lt;Target&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;upcast(self, _tag: PhantomData&amp;lt;Target&amp;gt;) -&amp;gt; Target;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The trait is generic over the &lt;code&gt;Target&lt;&#x2F;code&gt; type we wish to upcast to. The &lt;code&gt;upcast&lt;&#x2F;code&gt; method takes the original enum and converts it into the target enum, using &lt;code&gt;PhantomData&lt;&#x2F;code&gt; to assist with type inference.&lt;&#x2F;p&gt;
&lt;p&gt;The implementation is provided generically through a blanket implementation:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;Context, Source, Target, Remainder&amp;gt; CanUpcast&amp;lt;Target&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;Context
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;    Context: HasFields + HasExtractor&amp;lt;Extractor = Source&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Context::&lt;&#x2F;span&gt;&lt;span&gt;Fields: FieldsExtractor&amp;lt;Source, Target, Remainder = Remainder&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    Remainder: FinalizeExtract,
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;upcast(self, _tag: PhantomData&amp;lt;Target&amp;gt;) -&amp;gt; Target {
&lt;&#x2F;span&gt;&lt;span&gt;        Context::Fields::extract_from(self.to_extractor()).finalize_extract_result()
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Here’s how it works. First, the &lt;code&gt;Context&lt;&#x2F;code&gt; type (the source enum) must implement both &lt;code&gt;HasFields&lt;&#x2F;code&gt; and &lt;code&gt;HasExtractor&lt;&#x2F;code&gt;. The &lt;code&gt;HasFields&lt;&#x2F;code&gt; trait provides a type-level sum of variants, and &lt;code&gt;HasExtractor&lt;&#x2F;code&gt; converts the enum into its corresponding partial variants. Next, the associated &lt;code&gt;Fields&lt;&#x2F;code&gt; type must implement the helper trait &lt;code&gt;FieldsExtractor&lt;&#x2F;code&gt;, which handles the actual extraction of variants into the target type. The &lt;code&gt;Remainder&lt;&#x2F;code&gt; returned by this operation must then implement &lt;code&gt;FinalizeExtract&lt;&#x2F;code&gt;, which guarantees that all source variants have been accounted for.&lt;&#x2F;p&gt;
&lt;p&gt;In the method body, we begin by calling &lt;code&gt;self.to_extractor()&lt;&#x2F;code&gt; to convert the source enum into a value with partial variants. We then use &lt;code&gt;Fields::extract_from&lt;&#x2F;code&gt; to extract the relevant variants into the target enum. Finally, we call &lt;code&gt;finalize_extract_result()&lt;&#x2F;code&gt; to discharge the remainder in &lt;code&gt;Err&lt;&#x2F;code&gt;, and return the &lt;code&gt;Target&lt;&#x2F;code&gt; result in &lt;code&gt;Ok&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;fieldsextractor-trait&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#fieldsextractor-trait&quot; aria-label=&quot;Anchor link for: fieldsextractor-trait&quot;&gt;&lt;code&gt;FieldsExtractor&lt;&#x2F;code&gt; Trait&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;The &lt;code&gt;FieldsExtractor&lt;&#x2F;code&gt; trait serves as a helper for casting between enums. It is defined as follows:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;FieldsExtractor&amp;lt;Source, Target&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Remainder&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;extract_from(source: Source) -&amp;gt; Result&amp;lt;Target, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;Remainder&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This trait is parameterized by two types: &lt;code&gt;Source&lt;&#x2F;code&gt;, which represents the partial variants of the source enum, and &lt;code&gt;Target&lt;&#x2F;code&gt;, which is the fully constructed destination enum. It also defines a &lt;code&gt;Remainder&lt;&#x2F;code&gt; associated type to capture any variant in the source that could not be extracted into the target.&lt;&#x2F;p&gt;
&lt;p&gt;The &lt;code&gt;extract_from&lt;&#x2F;code&gt; method attempts to convert the given partial variants from the &lt;code&gt;Source&lt;&#x2F;code&gt; into a complete &lt;code&gt;Target&lt;&#x2F;code&gt;. If successful, it returns the constructed &lt;code&gt;Target&lt;&#x2F;code&gt; value. Otherwise, it returns the remainder of the &lt;code&gt;Source&lt;&#x2F;code&gt; that could not be matched.&lt;&#x2F;p&gt;
&lt;p&gt;The core implementation of &lt;code&gt;FieldsExtractor&lt;&#x2F;code&gt; operates recursively over the &lt;code&gt;Sum!&lt;&#x2F;code&gt; list of fields. For the head of the list, the implementation is written as:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;Source, Target, Tag, Value, RestFields, Remainder&amp;gt; FieldsExtractor&amp;lt;Source, Target&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    for Either&amp;lt;Field&amp;lt;Tag, Value&amp;gt;, RestFields&amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;    Source: ExtractField&amp;lt;Tag, Value = Value&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    Target: FromVariant&amp;lt;Tag, Value = Value&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    RestFields: FieldsExtractor&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Source::&lt;&#x2F;span&gt;&lt;span&gt;Remainder, Target, Remainder = Remainder&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Remainder &lt;&#x2F;span&gt;&lt;span&gt;= Remainder;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;extract_from(source: Source) -&amp;gt; Result&amp;lt;Target, Remainder&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;match&lt;&#x2F;span&gt;&lt;span&gt; source.extract_field(PhantomData) {
&lt;&#x2F;span&gt;&lt;span&gt;            Ok(field) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;Ok(Target::from_variant(PhantomData, field)),
&lt;&#x2F;span&gt;&lt;span&gt;            Err(remainder) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;RestFields::extract_from(remainder),
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In this implementation, we deconstruct the head of the sum into a &lt;code&gt;Field&amp;lt;Tag, Value&amp;gt;&lt;&#x2F;code&gt; type. We then require that the &lt;code&gt;Source&lt;&#x2F;code&gt; type supports &lt;code&gt;ExtractField&amp;lt;Tag&amp;gt;&lt;&#x2F;code&gt;, which allows us to attempt extracting the field corresponding to that tag. We also require the &lt;code&gt;Target&lt;&#x2F;code&gt; enum to support &lt;code&gt;FromVariant&amp;lt;Tag&amp;gt;&lt;&#x2F;code&gt;, so that once the field is extracted, we can reconstruct the target enum from it. In both traits, the associated &lt;code&gt;Value&lt;&#x2F;code&gt; type must be consistent.&lt;&#x2F;p&gt;
&lt;p&gt;If the extraction succeeds, we pass the value into &lt;code&gt;Target::from_variant&lt;&#x2F;code&gt; to construct the result. If it fails, we take the &lt;code&gt;Remainder&lt;&#x2F;code&gt; returned from &lt;code&gt;extract_field&lt;&#x2F;code&gt;, and recursively call &lt;code&gt;extract_from&lt;&#x2F;code&gt; on the rest of the fields. The associated &lt;code&gt;Remainder&lt;&#x2F;code&gt; type continues to track whatever remains after each recursive step.&lt;&#x2F;p&gt;
&lt;p&gt;Eventually, the recursion reaches the end of the &lt;code&gt;Sum!&lt;&#x2F;code&gt; list, which is represented by the &lt;code&gt;Void&lt;&#x2F;code&gt; type. At this point, we provide the base case:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;Source, Target&amp;gt; FieldsExtractor&amp;lt;Source, Target&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;Void {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Remainder &lt;&#x2F;span&gt;&lt;span&gt;= Source;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;extract_from(source: Source) -&amp;gt; Result&amp;lt;Target, Source&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;        Err(source)
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In this final case, the trait simply sets the entire &lt;code&gt;Source&lt;&#x2F;code&gt; as the &lt;code&gt;Remainder&lt;&#x2F;code&gt;, indicating that none of the fields matched. This implementation ends the recursive search through the variants and signals that the cast could not be completed.&lt;&#x2F;p&gt;
&lt;p&gt;This pattern allows us to generically extract variants from an extensible enum, one field at a time, while safely and efficiently handling any unmatched cases using Rust’s powerful type system.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;example-use-of-upcast&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#example-use-of-upcast&quot; aria-label=&quot;Anchor link for: example-use-of-upcast&quot;&gt;Example Use of &lt;code&gt;Upcast&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;To better understand how the &lt;code&gt;FieldsExtractor&lt;&#x2F;code&gt; operation works, let’s walk through a concrete example of an upcast. Suppose we define a new enum &lt;code&gt;ShapePlus&lt;&#x2F;code&gt; that extends the original &lt;code&gt;Shape&lt;&#x2F;code&gt; type by including an additional variant:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[derive(HasFields, FromVariant, ExtractField)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub enum &lt;&#x2F;span&gt;&lt;span&gt;ShapePlus {
&lt;&#x2F;span&gt;&lt;span&gt;    Triangle(Triangle),
&lt;&#x2F;span&gt;&lt;span&gt;    Rectangle(Rectangle),
&lt;&#x2F;span&gt;&lt;span&gt;    Circle(Circle),
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We can then perform an upcast from &lt;code&gt;Shape&lt;&#x2F;code&gt; to &lt;code&gt;ShapePlus&lt;&#x2F;code&gt; with the following code:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; shape = Shape::Circle(Circle { radius: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;5.0 &lt;&#x2F;span&gt;&lt;span&gt;});
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; shape_plus = shape.upcast(PhantomData::&amp;lt;ShapePlus&amp;gt;);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Behind the scenes, the upcast proceeds through a series of trait-based checks and operations:&lt;&#x2F;p&gt;
&lt;p&gt;First, the blanket implementation of &lt;code&gt;CanUpcast&lt;&#x2F;code&gt; verifies several conditions:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;The source type &lt;code&gt;Shape&lt;&#x2F;code&gt; must implement &lt;code&gt;HasFields&lt;&#x2F;code&gt;, with the &lt;code&gt;Fields&lt;&#x2F;code&gt; type resolving to:&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;Sum&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;[
&lt;&#x2F;span&gt;&lt;span&gt;    Field&amp;lt;Symbol&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Circle&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;), Circle&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    Field&amp;lt;Symbol&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Rectangle&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;), Rectangle&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;Shape&lt;&#x2F;code&gt; must also implement &lt;code&gt;HasExtractor&lt;&#x2F;code&gt;, with its associated &lt;code&gt;Extractor&lt;&#x2F;code&gt; type being &lt;code&gt;PartialShape&amp;lt;IsPresent, IsPresent&amp;gt;&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;The &lt;code&gt;Fields&lt;&#x2F;code&gt; type must implement &lt;code&gt;FieldsExtractor&lt;&#x2F;code&gt;, with &lt;code&gt;PartialShape&amp;lt;IsPresent, IsPresent&amp;gt;&lt;&#x2F;code&gt; as the source and &lt;code&gt;ShapePlus&lt;&#x2F;code&gt; as the target.&lt;&#x2F;li&gt;
&lt;li&gt;The result of the extraction yields a remainder of type &lt;code&gt;PartialShape&amp;lt;IsVoid, IsVoid&amp;gt;&lt;&#x2F;code&gt;, which in turn implements &lt;code&gt;FinalizeExtract&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Next, the &lt;code&gt;FieldsExtractor&lt;&#x2F;code&gt; implementation for the head of the sum begins processing:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;The current &lt;code&gt;Tag&lt;&#x2F;code&gt; is &lt;code&gt;Symbol!(&quot;Circle&quot;)&lt;&#x2F;code&gt;, and the associated &lt;code&gt;Value&lt;&#x2F;code&gt; is of type &lt;code&gt;Circle&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;The &lt;code&gt;Source&lt;&#x2F;code&gt; is &lt;code&gt;PartialShape&amp;lt;IsPresent, IsPresent&amp;gt;&lt;&#x2F;code&gt;, and the &lt;code&gt;Target&lt;&#x2F;code&gt; is &lt;code&gt;ShapePlus&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;The source implements &lt;code&gt;ExtractField&amp;lt;Symbol!(&quot;Circle&quot;)&amp;gt;&lt;&#x2F;code&gt;, which succeeds with &lt;code&gt;Circle&lt;&#x2F;code&gt; as the extracted value and &lt;code&gt;PartialShape&amp;lt;IsVoid, IsPresent&amp;gt;&lt;&#x2F;code&gt; as the remainder.&lt;&#x2F;li&gt;
&lt;li&gt;The target &lt;code&gt;ShapePlus&lt;&#x2F;code&gt; implements &lt;code&gt;FromVariant&amp;lt;Symbol!(&quot;Circle&quot;)&amp;gt;&lt;&#x2F;code&gt;, again with &lt;code&gt;Circle&lt;&#x2F;code&gt; being the &lt;code&gt;Value&lt;&#x2F;code&gt; type.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;The extractor then proceeds to the next variant in the sum:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;The current &lt;code&gt;Tag&lt;&#x2F;code&gt; is &lt;code&gt;Symbol!(&quot;Rectangle&quot;)&lt;&#x2F;code&gt;, with &lt;code&gt;Rectangle&lt;&#x2F;code&gt; as the &lt;code&gt;Value&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;The updated &lt;code&gt;Source&lt;&#x2F;code&gt; is now &lt;code&gt;PartialShape&amp;lt;IsVoid, IsPresent&amp;gt;&lt;&#x2F;code&gt;, and the &lt;code&gt;Target&lt;&#x2F;code&gt; remains &lt;code&gt;ShapePlus&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;This source implements &lt;code&gt;ExtractField&amp;lt;Symbol!(&quot;Rectangle&quot;)&amp;gt;&lt;&#x2F;code&gt;, yielding &lt;code&gt;Rectangle&lt;&#x2F;code&gt; as the value and &lt;code&gt;PartialShape&amp;lt;IsVoid, IsVoid&amp;gt;&lt;&#x2F;code&gt; as the final remainder.&lt;&#x2F;li&gt;
&lt;li&gt;The target once again supports &lt;code&gt;FromVariant&amp;lt;Symbol!(&quot;Rectangle&quot;)&amp;gt;&lt;&#x2F;code&gt; using the matching &lt;code&gt;Rectangle&lt;&#x2F;code&gt; type.&lt;&#x2F;li&gt;
&lt;li&gt;At the end of the chain, the &lt;code&gt;Void&lt;&#x2F;code&gt; variant is reached. The &lt;code&gt;FieldsExtractor&lt;&#x2F;code&gt; implementation for &lt;code&gt;Void&lt;&#x2F;code&gt; simply returns the remainder, which in this case is &lt;code&gt;PartialShape&amp;lt;IsVoid, IsVoid&amp;gt;&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;What this process shows is that the &lt;code&gt;Upcast&lt;&#x2F;code&gt; operation works by examining each variant in the source type &lt;code&gt;Shape&lt;&#x2F;code&gt;, extracting each present value, and reinserting it into the target type &lt;code&gt;ShapePlus&lt;&#x2F;code&gt;. Once all fields have been processed, the remaining variants are guaranteed to be uninhabited. At that point, we can safely discharge the remainder using the &lt;code&gt;FinalizeExtract&lt;&#x2F;code&gt; trait.&lt;&#x2F;p&gt;
&lt;p&gt;By breaking down the upcast into individual type-driven steps over extensible variants, we can implement upcasting entirely in safe Rust. Even more importantly, this implementation is fully generic and reusable. We are not writing code solely for the purpose of supporting &lt;code&gt;Upcast&lt;&#x2F;code&gt; — instead, we are building a reusable foundation that also supports operations like &lt;code&gt;Downcast&lt;&#x2F;code&gt; and other generic manipulations over extensible variants.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;candowncast-implementation&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#candowncast-implementation&quot; aria-label=&quot;Anchor link for: candowncast-implementation&quot;&gt;&lt;code&gt;CanDowncast&lt;&#x2F;code&gt; Implementation&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;With the upcast operation in place, we can now turn to the implementation of &lt;code&gt;CanDowncast&lt;&#x2F;code&gt;. The &lt;code&gt;CanDowncast&lt;&#x2F;code&gt; trait is defined as follows:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;CanDowncast&amp;lt;Target&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Remainder&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;downcast(self, _tag: PhantomData&amp;lt;Target&amp;gt;) -&amp;gt; Result&amp;lt;Target, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;Remainder&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This trait is used to convert a value of an enum type into another enum that represents a &lt;em&gt;subset&lt;&#x2F;em&gt; of its variants. Unlike &lt;code&gt;CanUpcast&lt;&#x2F;code&gt;, which guarantees success by moving into a larger enum, &lt;code&gt;CanDowncast&lt;&#x2F;code&gt; may &lt;em&gt;fail&lt;&#x2F;em&gt; if the source contains variants not present in the target. To account for this, the trait includes an associated &lt;code&gt;Remainder&lt;&#x2F;code&gt; type to capture any unmatched variants, and the &lt;code&gt;downcast&lt;&#x2F;code&gt; method returns a &lt;code&gt;Result&lt;&#x2F;code&gt; that either yields the successfully downcasted value or the remainder.&lt;&#x2F;p&gt;
&lt;p&gt;As with &lt;code&gt;CanUpcast&lt;&#x2F;code&gt;, we can define &lt;code&gt;CanDowncast&lt;&#x2F;code&gt; using a blanket implementation:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;Context, Source, Target, Remainder&amp;gt; CanDowncast&amp;lt;Target&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;Context
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;    Context: HasExtractor&amp;lt;Extractor = Source&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    Target: HasFields,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Target::&lt;&#x2F;span&gt;&lt;span&gt;Fields: FieldsExtractor&amp;lt;Source, Target, Remainder = Remainder&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Remainder &lt;&#x2F;span&gt;&lt;span&gt;= Remainder;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;downcast(self, _tag: PhantomData&amp;lt;Target&amp;gt;) -&amp;gt; Result&amp;lt;Target, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;Remainder&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;        Target::Fields::extract_from(self.to_extractor())
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;With all the foundational components from &lt;code&gt;CanUpcast&lt;&#x2F;code&gt; already in place, the implementation of &lt;code&gt;CanDowncast&lt;&#x2F;code&gt; becomes remarkably straightforward. Instead of requiring the source &lt;code&gt;Context&lt;&#x2F;code&gt; to implement &lt;code&gt;HasFields&lt;&#x2F;code&gt;, we shift that requirement to the &lt;code&gt;Target&lt;&#x2F;code&gt;. We still use the &lt;code&gt;HasExtractor&lt;&#x2F;code&gt; trait to obtain the partial variant representation of the source. From there, we iterate over the target fields using &lt;code&gt;FieldsExtractor&lt;&#x2F;code&gt;, attempting to extract a match from the source. Because we are narrowing into a smaller enum, some variants may remain unmatched. In those cases, we simply return the remainder rather than attempting to finalize it, as we did in &lt;code&gt;CanUpcast&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;This difference highlights the key distinction between upcasting and downcasting in this model. The &lt;code&gt;Upcast&lt;&#x2F;code&gt; operation extracts from all fields in the source and expects the remainder to be empty, whereas &lt;code&gt;Downcast&lt;&#x2F;code&gt; extracts only those variants present in the target and leaves the unmatched remainder intact. Yet aside from this inversion of roles between source and target, the two implementations share the same reusable machinery — including &lt;code&gt;FieldsExtractor&lt;&#x2F;code&gt; — demonstrating the flexibility and composability of the CGP approach to extensible variants.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;example-use-of-downcast&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#example-use-of-downcast&quot; aria-label=&quot;Anchor link for: example-use-of-downcast&quot;&gt;Example Use of Downcast&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;With &lt;code&gt;CanDowncast&lt;&#x2F;code&gt; in place, we can now explore how to use it in practice. Consider the following example, where we attempt to downcast from a &lt;code&gt;ShapePlus&lt;&#x2F;code&gt; enum to a &lt;code&gt;Shape&lt;&#x2F;code&gt; enum:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; shape_plus = ShapePlus::Triangle(Triangle {
&lt;&#x2F;span&gt;&lt;span&gt;    base: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;3.0&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    height: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;4.0&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;});
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; area = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;match&lt;&#x2F;span&gt;&lt;span&gt; shape_plus.downcast(PhantomData::&amp;lt;Shape&amp;gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;    Ok(shape) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; match&lt;&#x2F;span&gt;&lt;span&gt; shape {
&lt;&#x2F;span&gt;&lt;span&gt;        Shape::Circle(circle) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;PI &lt;&#x2F;span&gt;&lt;span&gt;* circle.radius * circle.radius,
&lt;&#x2F;span&gt;&lt;span&gt;        Shape::Rectangle(rectangle) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt; rectangle.width * rectangle.height,
&lt;&#x2F;span&gt;&lt;span&gt;    },
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; PartialShapePlus&amp;lt;IsPresent, IsVoid, IsVoid&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    Err(remainder) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; match&lt;&#x2F;span&gt;&lt;span&gt; remainder.extract_field(PhantomData::&amp;lt;Symbol&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Triangle&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;)&amp;gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;        Ok(triangle) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt; triangle.base * triangle.height &#x2F; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;2.0&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    },
&lt;&#x2F;span&gt;&lt;span&gt;};
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In this example, we start with a &lt;code&gt;ShapePlus&lt;&#x2F;code&gt; value that holds a &lt;code&gt;Triangle&lt;&#x2F;code&gt;. We then call &lt;code&gt;downcast&lt;&#x2F;code&gt;, attempting to convert it to a &lt;code&gt;Shape&lt;&#x2F;code&gt;, which does not include the &lt;code&gt;Triangle&lt;&#x2F;code&gt; variant. Internally, the downcast operation uses &lt;code&gt;Shape::Fields&lt;&#x2F;code&gt; to iterate over the variants defined in &lt;code&gt;Shape&lt;&#x2F;code&gt; and tries to extract each from the original &lt;code&gt;ShapePlus&lt;&#x2F;code&gt; value. If any of those variants are found — such as &lt;code&gt;Circle&lt;&#x2F;code&gt; or &lt;code&gt;Rectangle&lt;&#x2F;code&gt; — the match succeeds and we compute the corresponding area from &lt;code&gt;Shape&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;However, when the actual variant in this case is &lt;code&gt;Triangle&lt;&#x2F;code&gt;, which is not part of &lt;code&gt;Shape&lt;&#x2F;code&gt;, the downcast fails and we receive the remainder of the partial variant structure. This remainder, of type &lt;code&gt;PartialShapePlus&amp;lt;IsPresent, IsVoid, IsVoid&amp;gt;&lt;&#x2F;code&gt;, contains only the &lt;code&gt;Triangle&lt;&#x2F;code&gt; variant. We then use &lt;code&gt;extract_field&lt;&#x2F;code&gt; to retrieve the triangle and compute its area. At this point, no other variants remain to be handled.&lt;&#x2F;p&gt;
&lt;p&gt;One of the most impressive aspects of both upcast and downcast is that they work seamlessly even when the source and target enums define their variants in entirely different orders. Because the trait implementations, such as &lt;code&gt;ExtractField&lt;&#x2F;code&gt;, operate in a generic and order-independent way, the correctness and behavior of casting are preserved regardless of variant ordering. This level of flexibility makes the CGP approach to extensible variants both powerful and practical for real-world use.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h1 id=&quot;implementation-of-visitor-dispatcher&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#implementation-of-visitor-dispatcher&quot; aria-label=&quot;Anchor link for: implementation-of-visitor-dispatcher&quot;&gt;Implementation of Visitor Dispatcher&lt;&#x2F;a&gt;&lt;&#x2F;h1&gt;
&lt;p&gt;With the traits for extensible variants now in place, we can turn our attention to how CGP implements generalized &lt;strong&gt;visitor dispatchers&lt;&#x2F;strong&gt;, similar to the &lt;a href=&quot;&#x2F;blog&#x2F;extensible-datatypes-part-3&#x2F;#builder-dispatcher&quot;&gt;builder dispatchers&lt;&#x2F;a&gt; described in the previous part of this series.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;matchwithhandlers&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#matchwithhandlers&quot; aria-label=&quot;Anchor link for: matchwithhandlers&quot;&gt;&lt;code&gt;MatchWithHandlers&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;In the &lt;a href=&quot;&#x2F;blog&#x2F;extensible-datatypes-part-2&#x2F;#dispatching-eval&quot;&gt;examples from Part 2&lt;&#x2F;a&gt;, we introduced dispatchers such as &lt;code&gt;MatchWithValueHandlers&lt;&#x2F;code&gt; and &lt;code&gt;MatchWithValueHandlersRef&lt;&#x2F;code&gt;, which delegate the handling of enum variants to different visitor handlers based on the &lt;code&gt;Input&lt;&#x2F;code&gt; type. These dispatchers are built on top of a more fundamental dispatcher called &lt;code&gt;MatchWithHandlers&lt;&#x2F;code&gt;, whose implementation is shown below:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_provider]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;Context, Code, Input, Output, Remainder, Handlers&amp;gt; Computer&amp;lt;Context, Code, Input&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    for MatchWithHandlers&amp;lt;Handlers&amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;    Input: HasExtractor,
&lt;&#x2F;span&gt;&lt;span&gt;    DispatchMatchers&amp;lt;Handlers&amp;gt;:
&lt;&#x2F;span&gt;&lt;span&gt;        Computer&amp;lt;Context, Code, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Input::&lt;&#x2F;span&gt;&lt;span&gt;Extractor, Output = Result&amp;lt;Output, Remainder&amp;gt;&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    Remainder: FinalizeExtract,
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Output &lt;&#x2F;span&gt;&lt;span&gt;= Output;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;compute(context: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;Context, code: PhantomData&amp;lt;Code&amp;gt;, input: Input) -&amp;gt; Output {
&lt;&#x2F;span&gt;&lt;span&gt;        DispatchMatchers::compute(context, code, input.to_extractor()).finalize_extract_result()
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;MatchWithHandlers&lt;&#x2F;code&gt; provider is parameterized by a &lt;code&gt;Handlers&lt;&#x2F;code&gt; type, which represents a type-level list of visitor handlers responsible for processing the variants of a generic &lt;code&gt;Input&lt;&#x2F;code&gt; enum. The implementation requires &lt;code&gt;Input&lt;&#x2F;code&gt; to implement the &lt;code&gt;HasExtractor&lt;&#x2F;code&gt; trait, which provides access to its partial variants.&lt;&#x2F;p&gt;
&lt;p&gt;Within the &lt;code&gt;compute&lt;&#x2F;code&gt; method, we first convert the input into its extractor form using &lt;code&gt;input.to_extractor()&lt;&#x2F;code&gt;. This partial variant is then passed to the lower-level dispatcher &lt;code&gt;DispatchMatchers&amp;lt;Handlers&amp;gt;&lt;&#x2F;code&gt;, which attempts to match and handle each variant. It returns a &lt;code&gt;Result&amp;lt;Output, Remainder&amp;gt;&lt;&#x2F;code&gt;, where a successful match produces an &lt;code&gt;Output&lt;&#x2F;code&gt;, and an unmatched remainder is returned otherwise. But since &lt;code&gt;Remainder&lt;&#x2F;code&gt; is expected to implement &lt;code&gt;FinalizeExtract&lt;&#x2F;code&gt;, we can call &lt;code&gt;finalize_extract_result()&lt;&#x2F;code&gt; to return the &lt;code&gt;Output&lt;&#x2F;code&gt; directly.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;dispatchmatchers&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#dispatchmatchers&quot; aria-label=&quot;Anchor link for: dispatchmatchers&quot;&gt;&lt;code&gt;DispatchMatchers&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;In our earlier implementation of extensible builders via &lt;code&gt;BuildWithHandlers&lt;&#x2F;code&gt;, we &lt;a href=&quot;&#x2F;blog&#x2F;extensible-datatypes-part-3&#x2F;#buildwithhandlers-provider&quot;&gt;used &lt;code&gt;PipeHandlers&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; to compose a pipeline of builder handlers that successively filled in partial records. For extensible visitors, we follow a similar pattern with a slight variation that reflects the different control flow.&lt;&#x2F;p&gt;
&lt;p&gt;The dispatcher &lt;code&gt;DispatchMatchers&lt;&#x2F;code&gt; is defined as follows:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;DispatchMatchers&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;Providers&amp;gt; = PipeMonadic&amp;lt;OkMonadic, Providers&amp;gt;;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This definition constructs a &lt;strong&gt;monadic pipeline&lt;&#x2F;strong&gt; of visitor handlers, using &lt;code&gt;OkMonadic&lt;&#x2F;code&gt; as the monad implementation.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;what-is-a-monad&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#what-is-a-monad&quot; aria-label=&quot;Anchor link for: what-is-a-monad&quot;&gt;What is a Monad?!&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;At this point, many readers coming from a Rust background may be wondering what exactly a &lt;a href=&quot;https:&#x2F;&#x2F;wiki.haskell.org&#x2F;Monad&quot;&gt;monad&lt;&#x2F;a&gt; is, and how it relates to implementing extensible visitors. In this section, we will break down the concept in simplified terms using familiar Rust patterns and constructs.&lt;&#x2F;p&gt;
&lt;p&gt;A monad, often written as &lt;code&gt;M&lt;&#x2F;code&gt;, is a type that acts as a container for another value &lt;code&gt;T&lt;&#x2F;code&gt;, and it typically appears in the form &lt;code&gt;M&amp;lt;T&amp;gt;&lt;&#x2F;code&gt;. If you have worked with &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;&#x2F;code&gt;, &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;&#x2F;code&gt;, or asynchronous code using &lt;code&gt;impl Future&amp;lt;Output = T&amp;gt;&lt;&#x2F;code&gt;, then you have already used monadic types in Rust.&lt;&#x2F;p&gt;
&lt;p&gt;Monads are not just containers. They also provide a way to operate on the values they contain, typically through an operation known as &quot;bind.&quot; In Rust, this concept appears through the use of operators like &lt;code&gt;?&lt;&#x2F;code&gt;, &lt;code&gt;.await&lt;&#x2F;code&gt;, and &lt;code&gt;.await?&lt;&#x2F;code&gt;, all of which allow you to &quot;extract&quot; or &quot;unwrap&quot; the value inside a container and propagate control based on the result.&lt;&#x2F;p&gt;
&lt;p&gt;With this understanding, we can think of &lt;code&gt;PipeMonadic&lt;&#x2F;code&gt; in CGP as a mechanism that automatically applies these unwrapping operations between steps in a pipeline. It takes the result from one handler and, using a monadic operator, unwraps it before passing it along as input to the next handler. This is how CGP builds a pipeline of computations where each step can short-circuit or continue depending on its output.&lt;&#x2F;p&gt;
&lt;p&gt;The real strength of this approach is that it generalizes well. You are not limited to a specific type like &lt;code&gt;Result&lt;&#x2F;code&gt;; you can apply the same logic to any monad-like type, including more complex combinations such as &lt;code&gt;impl Future&amp;lt;Output = Result&amp;lt;Result&amp;lt;Option&amp;lt;T&amp;gt;, E1&amp;gt;, E2&amp;gt;&amp;gt;&lt;&#x2F;code&gt;. In principle, you could imagine applying something like &lt;code&gt;.await???&lt;&#x2F;code&gt; to extract the inner value, and with monads, this can be abstracted and automated.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;okmonadic-monad-provider&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#okmonadic-monad-provider&quot; aria-label=&quot;Anchor link for: okmonadic-monad-provider&quot;&gt;&lt;code&gt;OkMonadic&lt;&#x2F;code&gt; Monad Provider&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;In the case of &lt;code&gt;DispatchMatchers&lt;&#x2F;code&gt;, the monad provider we use is called &lt;code&gt;OkMonadic&lt;&#x2F;code&gt;. This corresponds to the custom operator &lt;code&gt;⸮&lt;&#x2F;code&gt; we introduced in the pseudocode in the &lt;a href=&quot;https:&#x2F;&#x2F;www.contextgeneric.dev&#x2F;blog&#x2F;extensible-datatypes-part-4&#x2F;#short-circuiting-remainder&quot;&gt;&lt;code&gt;compute_area&lt;&#x2F;code&gt; example&lt;&#x2F;a&gt;, which short-circuits on the &lt;code&gt;Ok&lt;&#x2F;code&gt; variant and passes along the changing &lt;code&gt;Err&lt;&#x2F;code&gt; remainder.&lt;&#x2F;p&gt;
&lt;p&gt;When we say that &lt;code&gt;DispatchMatchers&lt;&#x2F;code&gt; is defined using &lt;code&gt;PipeMonadic&amp;lt;OkMonadic, Providers&amp;gt;&lt;&#x2F;code&gt;, we mean that CGP should build a handler pipeline where each step uses the &lt;code&gt;⸮&lt;&#x2F;code&gt; operator to either return early with &lt;code&gt;Ok(output)&lt;&#x2F;code&gt; or continue processing the &lt;code&gt;Err(remainder)&lt;&#x2F;code&gt; with the next handler.&lt;&#x2F;p&gt;
&lt;p&gt;Because of &lt;code&gt;PipeMonadic&lt;&#x2F;code&gt; and &lt;code&gt;OkMonadic&lt;&#x2F;code&gt;, we do not need to write this logic ourselves. CGP handles the monadic control flow automatically, allowing us to focus on the behavior of each handler without worrying about wiring them together manually.&lt;&#x2F;p&gt;
&lt;p&gt;If any of this still feels unclear, do not worry. We will walk through a concrete example next to clarify how it works in practice. We also plan to publish a separate blog post that dives deeper into how CGP implements monads in Rust, including the internals of &lt;code&gt;PipeMonadic&lt;&#x2F;code&gt; and related abstractions.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;example-use-of-matchwithhandlers&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#example-use-of-matchwithhandlers&quot; aria-label=&quot;Anchor link for: example-use-of-matchwithhandlers&quot;&gt;Example Use of &lt;code&gt;MatchWithHandlers&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;To understand how to use &lt;code&gt;MatchWithHandlers&lt;&#x2F;code&gt; directly, let&#x27;s revisit the example of computing the area of a &lt;code&gt;Shape&lt;&#x2F;code&gt;. We start by defining two separate &lt;code&gt;Computer&lt;&#x2F;code&gt; providers that calculate the area for the &lt;code&gt;Circle&lt;&#x2F;code&gt; and &lt;code&gt;Rectangle&lt;&#x2F;code&gt; variants:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_computer]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;circle_area(circle: Circle) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;f64 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;PI &lt;&#x2F;span&gt;&lt;span&gt;* circle.radius * circle.radius
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[cgp_computer]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;rectangle_area(rectangle: Rectangle) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;f64 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    rectangle.width * rectangle.height
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;cgp-computer-macro&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#cgp-computer-macro&quot; aria-label=&quot;Anchor link for: cgp-computer-macro&quot;&gt;&lt;code&gt;#[cgp_computer]&lt;&#x2F;code&gt; Macro&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;The &lt;code&gt;#[cgp_computer]&lt;&#x2F;code&gt; macro allows us to transform these pure functions into context-generic providers that can be referenced as types. Behind the scenes, this macro generates &lt;code&gt;Computer&lt;&#x2F;code&gt; implementations similar to the following:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_provider]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;Context, Code&amp;gt; Computer&amp;lt;Context, Code, Circle&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;CircleArea {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Output &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;f64&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;compute(_context: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;Context, _code: PhantomData&amp;lt;Code&amp;gt;, input: Circle) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;f64 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        circle_area(input)
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This macro simplifies the process of defining &lt;code&gt;Computer&lt;&#x2F;code&gt; providers by letting us write them as plain functions. Because the macro ignores the &lt;code&gt;Context&lt;&#x2F;code&gt; and &lt;code&gt;Code&lt;&#x2F;code&gt; types, the generated provider works with any &lt;code&gt;Context&lt;&#x2F;code&gt; and &lt;code&gt;Code&lt;&#x2F;code&gt; you supply.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;computeshapearea-handler&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#computeshapearea-handler&quot; aria-label=&quot;Anchor link for: computeshapearea-handler&quot;&gt;&lt;code&gt;ComputeShapeArea&lt;&#x2F;code&gt; Handler&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;With &lt;code&gt;CircleArea&lt;&#x2F;code&gt; and &lt;code&gt;RectangleArea&lt;&#x2F;code&gt; defined, we can create a &lt;code&gt;ComputeShapeArea&lt;&#x2F;code&gt; handler by using &lt;code&gt;MatchWithHandlers&lt;&#x2F;code&gt; as a type alias:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;ComputeShapeArea &lt;&#x2F;span&gt;&lt;span&gt;= MatchWithHandlers::&amp;lt;
&lt;&#x2F;span&gt;&lt;span&gt;    Product&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;[
&lt;&#x2F;span&gt;&lt;span&gt;        ExtractFieldAndHandle&amp;lt;Symbol&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Circle&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;), HandleFieldValue&amp;lt;CircleArea&amp;gt;&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        ExtractFieldAndHandle&amp;lt;Symbol&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Rectangle&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;), HandleFieldValue&amp;lt;RectangleArea&amp;gt;&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    ],
&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Rather than passing providers directly to &lt;code&gt;MatchWithHandlers&lt;&#x2F;code&gt;, we wrap them with helper handlers. The &lt;code&gt;ExtractFieldAndHandle&lt;&#x2F;code&gt; handler extracts the variant value associated with a specific tag, such as &lt;code&gt;Symbol!(&quot;Circle&quot;)&lt;&#x2F;code&gt;, and forwards it to the inner handler &lt;code&gt;HandleFieldValue&amp;lt;CircleArea&amp;gt;&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;The inner handler &lt;code&gt;HandleFieldValue&lt;&#x2F;code&gt; receives the input as &lt;code&gt;Field&amp;lt;Symbol!(&quot;Circle&quot;), Circle&amp;gt;&lt;&#x2F;code&gt;, extracts the &lt;code&gt;Circle&lt;&#x2F;code&gt; value, and passes it to &lt;code&gt;CircleArea&lt;&#x2F;code&gt;. We will explore the implementations of &lt;code&gt;ExtractFieldAndHandle&lt;&#x2F;code&gt; and &lt;code&gt;HandleFieldValue&lt;&#x2F;code&gt; shortly, but first, let&#x27;s see how &lt;code&gt;ComputeShapeArea&lt;&#x2F;code&gt; is used.&lt;&#x2F;p&gt;
&lt;p&gt;As a whole, the instantiated &lt;code&gt;MatchWithHandlers&lt;&#x2F;code&gt; implements the &lt;code&gt;Computer&lt;&#x2F;code&gt; trait. We can call &lt;code&gt;compute&lt;&#x2F;code&gt; on it using &lt;code&gt;()&lt;&#x2F;code&gt; for both the &lt;code&gt;Context&lt;&#x2F;code&gt; and &lt;code&gt;Code&lt;&#x2F;code&gt; types like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; shape = Shape::Circle(Circle { radius: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;5.0 &lt;&#x2F;span&gt;&lt;span&gt;});
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; area = ComputeShapeArea::compute(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;(), PhantomData::&amp;lt;()&amp;gt;, shape);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This works because the &lt;code&gt;Computer&lt;&#x2F;code&gt; instances defined with &lt;code&gt;#[cgp_computer]&lt;&#x2F;code&gt; are generic over any &lt;code&gt;Context&lt;&#x2F;code&gt; and &lt;code&gt;Code&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Under the hood, &lt;code&gt;MatchWithHandlers&lt;&#x2F;code&gt; implements &lt;code&gt;ComputeShapeArea&lt;&#x2F;code&gt; roughly as the following pseudocode:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; remainder = shape.to_extractor();
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; remainder = remainder
&lt;&#x2F;span&gt;&lt;span&gt;    .extract_field(Symbol&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Circle&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;))
&lt;&#x2F;span&gt;&lt;span&gt;    .map(|circle| CircleArea::compute(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;(), PhantomData::&amp;lt;()&amp;gt;, circle))⸮;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; remainder = remainder
&lt;&#x2F;span&gt;&lt;span&gt;    .extract_field(Symbol&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Rectangle&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;))
&lt;&#x2F;span&gt;&lt;span&gt;    .map(|rectangle| RectangleArea::compute(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;(), PhantomData::&amp;lt;()&amp;gt;, rectangle))⸮;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;remainder.finalize_extract();
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Here, &lt;code&gt;MatchWithHandlers&lt;&#x2F;code&gt; performs the same &lt;code&gt;⸮&lt;&#x2F;code&gt; short-circuit operation described earlier in the &lt;a href=&quot;https:&#x2F;&#x2F;www.contextgeneric.dev&#x2F;blog&#x2F;extensible-datatypes-part-4&#x2F;#short-circuiting-remainder&quot;&gt;short-circuiting remainder&lt;&#x2F;a&gt; section. For each &lt;code&gt;Ok&lt;&#x2F;code&gt; value returned by extraction, the corresponding &lt;code&gt;Computer&lt;&#x2F;code&gt; provider computes the area.&lt;&#x2F;p&gt;
&lt;p&gt;This example highlights how much boilerplate &lt;code&gt;MatchWithHandlers&lt;&#x2F;code&gt; abstracts away for us. Its implementation is essentially a monadic pipeline built using &lt;code&gt;PipeMonadic&lt;&#x2F;code&gt;, where &lt;code&gt;OkMonadic&lt;&#x2F;code&gt; provides the behavior of the &lt;code&gt;⸮&lt;&#x2F;code&gt; operator used in this pseudocode.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;extractfieldandhandle&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#extractfieldandhandle&quot; aria-label=&quot;Anchor link for: extractfieldandhandle&quot;&gt;&lt;code&gt;ExtractFieldAndHandle&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;To better understand how the earlier &lt;code&gt;MatchWithHandlers&lt;&#x2F;code&gt; example works, let&#x27;s examine the implementation of the &lt;code&gt;ExtractFieldAndHandle&lt;&#x2F;code&gt; provider:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_provider]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;Context, Code, Input, Tag, Value, Provider, Output, Remainder&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    Computer&amp;lt;Context, Code, Input&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    for ExtractFieldAndHandle&amp;lt;Tag, Provider&amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;    Input: ExtractField&amp;lt;Tag, Value = Value, Remainder = Remainder&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    Provider: Computer&amp;lt;Context, Code, Field&amp;lt;Tag, Value&amp;gt;, Output = Output&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Output &lt;&#x2F;span&gt;&lt;span&gt;= Result&amp;lt;Output, Remainder&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;compute(
&lt;&#x2F;span&gt;&lt;span&gt;        context: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;Context,
&lt;&#x2F;span&gt;&lt;span&gt;        tag: PhantomData&amp;lt;Code&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        input: Input,
&lt;&#x2F;span&gt;&lt;span&gt;    ) -&amp;gt; Result&amp;lt;Output, Remainder&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; value = input.extract_field(PhantomData::&amp;lt;Tag&amp;gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;?&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; output = Provider::compute(context, tag, value.into());
&lt;&#x2F;span&gt;&lt;span&gt;        Ok(output)
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;While the type signature may seem complex, the behavior is straightforward. Given some partial variants &lt;code&gt;Input&lt;&#x2F;code&gt;, this handler attempts to extract a variant with the specified &lt;code&gt;Tag&lt;&#x2F;code&gt; using &lt;code&gt;ExtractField&lt;&#x2F;code&gt;. If extraction succeeds, it wraps the extracted variant as a tagged field &lt;code&gt;Field&amp;lt;Tag, Value&amp;gt;&lt;&#x2F;code&gt; and passes it to the inner &lt;code&gt;Provider&lt;&#x2F;code&gt; for processing. If extraction fails, it returns the remainder as an &lt;code&gt;Err&lt;&#x2F;code&gt;, allowing the next handler in the monadic pipeline to try.&lt;&#x2F;p&gt;
&lt;p&gt;Note that the inner &lt;code&gt;Provider&lt;&#x2F;code&gt; receives a tagged &lt;code&gt;Field&amp;lt;Tag, Value&amp;gt;&lt;&#x2F;code&gt; rather than a bare &lt;code&gt;Value&lt;&#x2F;code&gt;. This allows the provider to differentiate variants that share the same &lt;code&gt;Value&lt;&#x2F;code&gt; type but differ in their variant &lt;code&gt;Tag&lt;&#x2F;code&gt;. For example, consider:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub enum &lt;&#x2F;span&gt;&lt;span&gt;FooBar {
&lt;&#x2F;span&gt;&lt;span&gt;    Foo(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u64&lt;&#x2F;span&gt;&lt;span&gt;),
&lt;&#x2F;span&gt;&lt;span&gt;    Bar(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u64&lt;&#x2F;span&gt;&lt;span&gt;),
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Here, both &lt;code&gt;Foo&lt;&#x2F;code&gt; and &lt;code&gt;Bar&lt;&#x2F;code&gt; hold &lt;code&gt;u64&lt;&#x2F;code&gt; values. &lt;code&gt;ExtractFieldAndHandle&lt;&#x2F;code&gt; will pass these as &lt;code&gt;Field&amp;lt;Symbol!(&quot;Foo&quot;), u64&amp;gt;&lt;&#x2F;code&gt; and &lt;code&gt;Field&amp;lt;Symbol!(&quot;Bar&quot;), u64&amp;gt;&lt;&#x2F;code&gt; respectively, so the provider can handle them differently by matching on the &lt;code&gt;Tag&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;handlefieldvalue&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#handlefieldvalue&quot; aria-label=&quot;Anchor link for: handlefieldvalue&quot;&gt;&lt;code&gt;HandleFieldValue&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;The tagged &lt;code&gt;Field&lt;&#x2F;code&gt; input from &lt;code&gt;ExtractFieldAndHandle&lt;&#x2F;code&gt; is useful when multiple variants share the same &lt;code&gt;Value&lt;&#x2F;code&gt; type. However, in simpler cases like our &lt;code&gt;Shape&lt;&#x2F;code&gt; example, we often just want to handle the contained value directly, ignoring the tag. The &lt;code&gt;HandleFieldValue&lt;&#x2F;code&gt; wrapper simplifies this by “peeling off” the &lt;code&gt;Field&lt;&#x2F;code&gt; wrapper and passing only the inner value to the inner provider:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_provider]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;Context, Code, Tag, Input, Output, Provider&amp;gt; Computer&amp;lt;Context, Code, Field&amp;lt;Tag, Input&amp;gt;&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    for HandleFieldValue&amp;lt;Provider&amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;    Provider: Computer&amp;lt;Context, Code, Input, Output = Output&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Output &lt;&#x2F;span&gt;&lt;span&gt;= Output;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;compute(
&lt;&#x2F;span&gt;&lt;span&gt;        context: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;Context,
&lt;&#x2F;span&gt;&lt;span&gt;        tag: PhantomData&amp;lt;Code&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        input: Field&amp;lt;Tag, Input&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    ) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;Output {
&lt;&#x2F;span&gt;&lt;span&gt;        Provider::compute(context, tag, input.value)
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;As shown, &lt;code&gt;HandleFieldValue&lt;&#x2F;code&gt; simply unwraps the input from &lt;code&gt;Field&amp;lt;Tag, Input&amp;gt;&lt;&#x2F;code&gt; and forwards the contained &lt;code&gt;Input&lt;&#x2F;code&gt; value to the inner provider.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;revisiting-computeshapearea&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#revisiting-computeshapearea&quot; aria-label=&quot;Anchor link for: revisiting-computeshapearea&quot;&gt;Revisiting &lt;code&gt;ComputeShapeArea&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;Now that we&#x27;ve understood &lt;code&gt;ExtractFieldAndHandle&lt;&#x2F;code&gt; and &lt;code&gt;HandleFieldValue&lt;&#x2F;code&gt;, let’s review what happens inside &lt;code&gt;ComputeShapeArea&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;ComputeShapeArea &lt;&#x2F;span&gt;&lt;span&gt;= MatchWithHandlers::&amp;lt;
&lt;&#x2F;span&gt;&lt;span&gt;    Product&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;[
&lt;&#x2F;span&gt;&lt;span&gt;        ExtractFieldAndHandle&amp;lt;Symbol&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Circle&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;), HandleFieldValue&amp;lt;CircleArea&amp;gt;&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        ExtractFieldAndHandle&amp;lt;Symbol&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Rectangle&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;), HandleFieldValue&amp;lt;RectangleArea&amp;gt;&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    ],
&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;MatchWithHandlers&lt;&#x2F;code&gt; uses &lt;code&gt;HasExtractor&lt;&#x2F;code&gt; to convert &lt;code&gt;Shape&lt;&#x2F;code&gt; into &lt;code&gt;PartialShape&amp;lt;IsPresent, IsPresent&amp;gt;&lt;&#x2F;code&gt;, then passes it to &lt;code&gt;ExtractFieldAndHandle&amp;lt;Symbol!(&quot;Circle&quot;), HandleFieldValue&amp;lt;CircleArea&amp;gt;&amp;gt;&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;ExtractFieldAndHandle&lt;&#x2F;code&gt; attempts to extract the &lt;code&gt;Circle&lt;&#x2F;code&gt; variant from &lt;code&gt;PartialShape&amp;lt;IsPresent, IsPresent&amp;gt;&lt;&#x2F;code&gt;:
&lt;ul&gt;
&lt;li&gt;If successful, the extracted value is passed as &lt;code&gt;Field&amp;lt;Symbol!(&quot;Circle&quot;), Circle&amp;gt;&lt;&#x2F;code&gt; to &lt;code&gt;HandleFieldValue&amp;lt;CircleArea&amp;gt;&lt;&#x2F;code&gt;.
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;HandleFieldValue&amp;lt;CircleArea&amp;gt;&lt;&#x2F;code&gt; unwraps the &lt;code&gt;Circle&lt;&#x2F;code&gt; value and passes it to &lt;code&gt;CircleArea&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;Otherwise, the remainder &lt;code&gt;PartialShape&amp;lt;IsVoid, IsPresent&amp;gt;&lt;&#x2F;code&gt; is returned as an error.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;Next, &lt;code&gt;ExtractFieldAndHandle&lt;&#x2F;code&gt; tries to extract the &lt;code&gt;Rectangle&lt;&#x2F;code&gt; variant from &lt;code&gt;PartialShape&amp;lt;IsVoid, IsPresent&amp;gt;&lt;&#x2F;code&gt;:
&lt;ul&gt;
&lt;li&gt;If successful, the extracted value is passed as &lt;code&gt;Field&amp;lt;Symbol!(&quot;Rectangle&quot;), Rectangle&amp;gt;&lt;&#x2F;code&gt; to &lt;code&gt;HandleFieldValue&amp;lt;RectangleArea&amp;gt;&lt;&#x2F;code&gt;.
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;HandleFieldValue&amp;lt;RectangleArea&amp;gt;&lt;&#x2F;code&gt; unwraps the &lt;code&gt;Rectangle&lt;&#x2F;code&gt; and passes it to &lt;code&gt;RectangleArea&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;Otherwise, the remainder &lt;code&gt;PartialShape&amp;lt;IsVoid, IsVoid&amp;gt;&lt;&#x2F;code&gt; is returned as an error.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;Finally, &lt;code&gt;MatchWithHandlers&lt;&#x2F;code&gt; calls &lt;code&gt;FinalizeExtract&lt;&#x2F;code&gt; on &lt;code&gt;PartialShape&amp;lt;IsVoid, IsVoid&amp;gt;&lt;&#x2F;code&gt; to assert that the remainder is empty and discharge the impossible case.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;unifying-variant-value-handlers&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#unifying-variant-value-handlers&quot; aria-label=&quot;Anchor link for: unifying-variant-value-handlers&quot;&gt;Unifying Variant Value Handlers&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;So far, we have seen how &lt;code&gt;MatchWithHandlers&lt;&#x2F;code&gt; can serve as a powerful low-level tool to implement extensible visitors. However, it requires explicitly listing a handler for each variant in the provided handler list. To make this process more ergonomic, we can build higher-level abstractions like &lt;code&gt;MatchWithValueHandlers&lt;&#x2F;code&gt;, which automatically derives the list of variant handlers passed to &lt;code&gt;MatchWithHandlers&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Before implementing &lt;code&gt;MatchWithValueHandlers&lt;&#x2F;code&gt;, we first need to unify the variant handlers used in &lt;code&gt;MatchWithHandlers&lt;&#x2F;code&gt;. Instead of specifying separate handlers for each variant, we modify the variant handlers so that the same handler is used for all variants. For example:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;ComputeShapeArea &lt;&#x2F;span&gt;&lt;span&gt;= MatchWithHandlers&amp;lt;
&lt;&#x2F;span&gt;&lt;span&gt;    Product&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;[
&lt;&#x2F;span&gt;&lt;span&gt;        ExtractFieldAndHandle&amp;lt;Symbol&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Circle&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;), HandleFieldValue&amp;lt;ComputeArea&amp;gt;&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        ExtractFieldAndHandle&amp;lt;Symbol&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Rectangle&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;), HandleFieldValue&amp;lt;ComputeArea&amp;gt;&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    ],
&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Here, rather than using distinct &lt;code&gt;CircleArea&lt;&#x2F;code&gt; and &lt;code&gt;RectangleArea&lt;&#x2F;code&gt; handlers, we use a single handler, &lt;code&gt;ComputeArea&lt;&#x2F;code&gt;, for both variants. This creates a unified pattern of &lt;code&gt;ExtractFieldAndHandle&amp;lt;Tag, HandleFieldValue&amp;lt;ComputeArea&amp;gt;&amp;gt;&lt;&#x2F;code&gt; for each entry. Recognizing this repetition allows us to build further abstractions that simplify these common patterns.&lt;&#x2F;p&gt;
&lt;p&gt;To understand this better, let&#x27;s explore how &lt;code&gt;ComputeArea&lt;&#x2F;code&gt; itself can be implemented. For many extensible variants such as &lt;code&gt;Shape&lt;&#x2F;code&gt;, a straightforward approach is to define a regular Rust trait that computes the area for each variant:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;HasArea {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;area(self) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;f64&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;HasArea &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;Circle {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;area(self) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;f64 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;PI &lt;&#x2F;span&gt;&lt;span&gt;* self.radius * self.radius
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;HasArea &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;Rectangle {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;area(self) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;f64 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        self.width * self.height
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This &lt;code&gt;HasArea&lt;&#x2F;code&gt; trait is simple and intuitive. Each variant implements the &lt;code&gt;area&lt;&#x2F;code&gt; method in the usual Rust way. Notice that we do not hand-implement &lt;code&gt;HasArea&lt;&#x2F;code&gt; for the overall &lt;code&gt;Shape&lt;&#x2F;code&gt; type, we will do this later on, by using &lt;code&gt;MatchWithValueHandlers&lt;&#x2F;code&gt; to help us perform the dispatching.&lt;&#x2F;p&gt;
&lt;p&gt;Although &lt;code&gt;HasArea&lt;&#x2F;code&gt; is a plain Rust trait, it is easy to wrap it as a &lt;code&gt;Computer&lt;&#x2F;code&gt; provider using the &lt;code&gt;#[cgp_computer]&lt;&#x2F;code&gt; macro:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_computer]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;compute_area&amp;lt;T: HasArea&amp;gt;(shape: T) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;f64 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    shape.area()
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This generic function works for any type implementing &lt;code&gt;HasArea&lt;&#x2F;code&gt; and simply calls the &lt;code&gt;area&lt;&#x2F;code&gt; method. Applying &lt;code&gt;#[cgp_computer]&lt;&#x2F;code&gt; here generates the &lt;code&gt;ComputeArea&lt;&#x2F;code&gt; provider type that can then be used within &lt;code&gt;ComputeShapeArea&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;tofieldshandler&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#tofieldshandler&quot; aria-label=&quot;Anchor link for: tofieldshandler&quot;&gt;&lt;code&gt;ToFieldsHandler&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;To simplify &lt;code&gt;ComputeShapeArea&lt;&#x2F;code&gt; further, we need a way to automatically generate the list of extractors passed to &lt;code&gt;MatchWithHandlers&lt;&#x2F;code&gt;. Concretely, we want to generate this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;Product&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;[
&lt;&#x2F;span&gt;&lt;span&gt;    ExtractFieldAndHandle&amp;lt;Symbol&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Circle&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;), HandleFieldValue&amp;lt;ComputeArea&amp;gt;&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    ExtractFieldAndHandle&amp;lt;Symbol&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Rectangle&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;), HandleFieldValue&amp;lt;ComputeArea&amp;gt;&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Recall that &lt;code&gt;Shape&lt;&#x2F;code&gt; implements the &lt;code&gt;HasFields&lt;&#x2F;code&gt; trait, which exposes its variants as a type-level sum:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;Sum&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;[
&lt;&#x2F;span&gt;&lt;span&gt;    Field&amp;lt;Symbol&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Circle&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;), Circle&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    Field&amp;lt;Symbol&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Rectangle&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;), Rectangle&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This means we can programmatically extract the tags from &lt;code&gt;Shape::Fields&lt;&#x2F;code&gt; and replace each variant with an &lt;code&gt;ExtractFieldAndHandle&lt;&#x2F;code&gt; wrapper. We can perform this transformation entirely at the type level using a helper trait, &lt;code&gt;ToFieldHandlers&lt;&#x2F;code&gt;, defined as:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;ToFieldHandlers&amp;lt;Provider&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Handlers&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;Tag, Value, RestFields, Provider&amp;gt; ToFieldHandlers&amp;lt;Provider&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    for Either&amp;lt;Field&amp;lt;Tag, Value&amp;gt;, RestFields&amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;    RestFields: ToFieldHandlers&amp;lt;Provider&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Handlers &lt;&#x2F;span&gt;&lt;span&gt;= Cons&amp;lt;ExtractFieldAndHandle&amp;lt;Tag, Provider&amp;gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;RestFields::&lt;&#x2F;span&gt;&lt;span&gt;Handlers&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;Provider&amp;gt; ToFieldHandlers&amp;lt;Provider&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;Void {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Handlers &lt;&#x2F;span&gt;&lt;span&gt;= Nil;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In essence, &lt;code&gt;ToFieldHandlers&lt;&#x2F;code&gt; recursively walks through each entry in a type-level sum, replacing &lt;code&gt;Field&amp;lt;Tag, Value&amp;gt;&lt;&#x2F;code&gt; with &lt;code&gt;ExtractFieldAndHandle&amp;lt;Tag, Provider&amp;gt;&lt;&#x2F;code&gt;, and converts the entire structure into a type-level list.&lt;&#x2F;p&gt;
&lt;p&gt;Using &lt;code&gt;ToFieldHandlers&lt;&#x2F;code&gt;, we can now write the &lt;code&gt;ComputeShapeArea&lt;&#x2F;code&gt; type as:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;ComputeShapeArea &lt;&#x2F;span&gt;&lt;span&gt;= MatchWithHandlers&amp;lt;
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;lt;&amp;lt;Shape &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as&lt;&#x2F;span&gt;&lt;span&gt; HasFields&amp;gt;::Fields &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as
&lt;&#x2F;span&gt;&lt;span&gt;        ToFieldHandlers&amp;lt;HandleFieldValue&amp;lt;ComputeArea&amp;gt;&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;gt;::Handlers
&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This definition may look complex at first glance. However, it demonstrates the powerful behind-the-scenes transformation that automatically generates the list of variant handlers from &lt;code&gt;Shape&lt;&#x2F;code&gt; to be passed to &lt;code&gt;MatchWithHandlers&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;hasfieldhandlers&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#hasfieldhandlers&quot; aria-label=&quot;Anchor link for: hasfieldhandlers&quot;&gt;&lt;code&gt;HasFieldHandlers&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;The process to generate variant handlers from &lt;code&gt;Shape&lt;&#x2F;code&gt; involves two steps: obtaining &lt;code&gt;Shape&lt;&#x2F;code&gt;’s fields from &lt;code&gt;HasFields&lt;&#x2F;code&gt;, and then applying &lt;code&gt;ToFieldHandlers&lt;&#x2F;code&gt; to those fields. To streamline this, we define another helper trait, &lt;code&gt;HasFieldHandlers&lt;&#x2F;code&gt;, that combines these steps:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;HasFieldHandlers&amp;lt;Provider&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Handlers&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;Context, Fields, Provider&amp;gt; HasFieldHandlers&amp;lt;Provider&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;Context
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;    Context: HasFields&amp;lt;Fields = Fields&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    Fields: ToFieldHandlers&amp;lt;Provider&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Handlers &lt;&#x2F;span&gt;&lt;span&gt;= Fields::Handlers;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;code&gt;HasFieldHandlers&lt;&#x2F;code&gt; unifies the requirements of &lt;code&gt;HasFields&lt;&#x2F;code&gt; and &lt;code&gt;ToFieldHandlers&lt;&#x2F;code&gt; into a single, convenient trait. This lets us simplify the definition of &lt;code&gt;ComputeShapeArea&lt;&#x2F;code&gt; even further:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;ComputeShapeArea &lt;&#x2F;span&gt;&lt;span&gt;= MatchWithHandlers&amp;lt;
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;lt;Shape &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as &lt;&#x2F;span&gt;&lt;span&gt;HasFieldHandlers&amp;lt;HandleFieldValue&amp;lt;ComputeArea&amp;gt;&amp;gt;&amp;gt;::Handlers
&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;With &lt;code&gt;HasFieldHandlers&lt;&#x2F;code&gt;, the definition of &lt;code&gt;ComputeShapeArea&lt;&#x2F;code&gt; becomes much more concise. Instead of manually combining &lt;code&gt;HasFields&lt;&#x2F;code&gt; and &lt;code&gt;ToFieldHandlers&lt;&#x2F;code&gt;, we simply rely on &lt;code&gt;HasFieldHandlers&lt;&#x2F;code&gt; to generate them from &lt;code&gt;Shape&lt;&#x2F;code&gt; and pass the result to &lt;code&gt;MatchWithHandlers&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;More importantly, this pattern is entirely general: it can be applied to any input type that implements &lt;code&gt;HasFields&lt;&#x2F;code&gt;, not just &lt;code&gt;Shape&lt;&#x2F;code&gt;, and to any &lt;code&gt;Computer&lt;&#x2F;code&gt; provider, not just &lt;code&gt;ComputeArea&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;matchwithvaluehandlers&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#matchwithvaluehandlers&quot; aria-label=&quot;Anchor link for: matchwithvaluehandlers&quot;&gt;&lt;code&gt;MatchWithValueHandlers&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;The traits &lt;code&gt;HasFieldHandlers&lt;&#x2F;code&gt; and &lt;code&gt;ToFieldHandlers&lt;&#x2F;code&gt; serve as the helpers for us to perform &lt;em&gt;type-level metaprogramming&lt;&#x2F;em&gt; for us to implement high-level visitor dispatchers such as &lt;code&gt;MatchWithValueHandlers&lt;&#x2F;code&gt;, which is defined as follows:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;MatchWithValueHandlers&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;Provider&amp;gt; =
&lt;&#x2F;span&gt;&lt;span&gt;    UseInputDelegate&amp;lt;MatchWithFieldHandlersInputs&amp;lt;HandleFieldValue&amp;lt;Provider&amp;gt;&amp;gt;&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;delegate_components! {
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;lt;Input: HasFieldHandlers&amp;lt;Provider&amp;gt;, Provider&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    new MatchWithFieldHandlersInputs&amp;lt;Provider&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;        Input: MatchWithHandlers&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Input::&lt;&#x2F;span&gt;&lt;span&gt;Handlers&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The design of &lt;code&gt;MatchWithValueHandlers&lt;&#x2F;code&gt; is similar to how we implemented the builder dispatchers using &lt;a href=&quot;&#x2F;blog&#x2F;extensible-datatypes-part-3&#x2F;#type-level-cgp-metaprogramming&quot;&gt;type-level metaprogramming in part 3&lt;&#x2F;a&gt;. In this case, &lt;code&gt;MatchWithValueHandlers&lt;&#x2F;code&gt; is parameterized by a &lt;code&gt;Provider&lt;&#x2F;code&gt; that is expected to implement &lt;code&gt;Computer&lt;&#x2F;code&gt;, such as &lt;code&gt;ComputeArea&lt;&#x2F;code&gt;. The implementation of &lt;code&gt;MatchWithValueHandlers&lt;&#x2F;code&gt; is simply a type alias to use &lt;code&gt;UseInputDelegate&lt;&#x2F;code&gt; to dispatch the &lt;code&gt;Input&lt;&#x2F;code&gt; type given through &lt;code&gt;Computer&lt;&#x2F;code&gt; to &lt;code&gt;MatchWithFieldHandlersInputs&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;The implementation of &lt;code&gt;MatchWithFieldHandlersInputs&lt;&#x2F;code&gt; is defined through &lt;code&gt;delegate_components!&lt;&#x2F;code&gt;, with it having a generic mapping for any &lt;code&gt;Input&lt;&#x2F;code&gt; that implements &lt;code&gt;HasFieldHandlers&amp;lt;Provider&amp;gt;&lt;&#x2F;code&gt;. It then simply delegates the provider for that input to &lt;code&gt;MatchWithHandlers&amp;lt;Input::Handlers&amp;gt;&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;example-instantiation-of-matchwithvaluehandlers&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#example-instantiation-of-matchwithvaluehandlers&quot; aria-label=&quot;Anchor link for: example-instantiation-of-matchwithvaluehandlers&quot;&gt;Example Instantiation of &lt;code&gt;MatchWithValueHandlers&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;Because &lt;code&gt;MatchWithValueHandlers&lt;&#x2F;code&gt; and &lt;code&gt;MatchWithFieldHandlersInputs&lt;&#x2F;code&gt; rely on type-level metaprogramming, it can be difficult to grasp exactly how they work on first encounter. To make things more concrete, let’s walk through how this abstraction is applied to &lt;code&gt;Shape&lt;&#x2F;code&gt;. With the machinery we’ve built, the definition of &lt;code&gt;ComputeShapeArea&lt;&#x2F;code&gt; becomes as simple as:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;ComputeShapeArea &lt;&#x2F;span&gt;&lt;span&gt;= MatchWithValueHandlers&amp;lt;ComputeArea&amp;gt;;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This version of &lt;code&gt;ComputeShapeArea&lt;&#x2F;code&gt; is remarkably concise. It no longer mentions &lt;code&gt;Shape&lt;&#x2F;code&gt; directly, because it works with &lt;em&gt;any&lt;&#x2F;em&gt; compatible input type, including both &lt;code&gt;Shape&lt;&#x2F;code&gt; and extensions like &lt;code&gt;ShapePlus&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Under the hood, this type alias resolves to &lt;code&gt;MatchWithHandlers&lt;&#x2F;code&gt; through the following steps:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;MatchWithValueHandlers&amp;lt;ComputeArea&amp;gt;&lt;&#x2F;code&gt; expands to &lt;code&gt;UseInputDelegate&amp;lt;MatchWithFieldHandlersInputs&amp;lt;HandleFieldValue&amp;lt;ComputeArea&amp;gt;&amp;gt;&amp;gt;&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;When the &lt;code&gt;Input&lt;&#x2F;code&gt; is &lt;code&gt;Shape&lt;&#x2F;code&gt;, &lt;code&gt;UseInputDelegate&lt;&#x2F;code&gt; locates the corresponding &lt;code&gt;DelegateComponent&lt;&#x2F;code&gt; mapping for &lt;code&gt;Shape&lt;&#x2F;code&gt; in &lt;code&gt;MatchWithFieldHandlersInputs&amp;lt;HandleFieldValue&amp;lt;ComputeArea&amp;gt;&amp;gt;&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;That mapping exists because &lt;code&gt;Shape&lt;&#x2F;code&gt; implements &lt;code&gt;HasFieldHandlers&amp;lt;HandleFieldValue&amp;lt;ComputeArea&amp;gt;&amp;gt;&lt;&#x2F;code&gt;. As we saw earlier, this expands to:&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;Product&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;[
&lt;&#x2F;span&gt;&lt;span&gt;    ExtractFieldAndHandle&amp;lt;Symbol&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Circle&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;), HandleFieldValue&amp;lt;ComputeArea&amp;gt;&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    ExtractFieldAndHandle&amp;lt;Symbol&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Rectangle&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;), HandleFieldValue&amp;lt;ComputeArea&amp;gt;&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;This type-level list is then passed to &lt;code&gt;MatchWithHandlers&lt;&#x2F;code&gt;, which performs the variant dispatch using the logic we’ve already explored.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;implementing-hasarea-for-shape&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#implementing-hasarea-for-shape&quot; aria-label=&quot;Anchor link for: implementing-hasarea-for-shape&quot;&gt;Implementing &lt;code&gt;HasArea&lt;&#x2F;code&gt; for &lt;code&gt;Shape&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;With &lt;code&gt;MatchWithValueHandlers&lt;&#x2F;code&gt;, implementing the &lt;code&gt;HasArea&lt;&#x2F;code&gt; trait for &lt;code&gt;Shape&lt;&#x2F;code&gt; becomes straightforward:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;HasArea &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;Shape {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;area(self) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;f64 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        MatchWithValueHandlers::&amp;lt;ComputeArea&amp;gt;::compute(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;(), PhantomData::&amp;lt;()&amp;gt;, self)
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;As in earlier examples, we use &lt;code&gt;()&lt;&#x2F;code&gt; for both the context and code parameters, since &lt;code&gt;ComputeArea&lt;&#x2F;code&gt; is generic over any &lt;code&gt;Context&lt;&#x2F;code&gt; and &lt;code&gt;Code&lt;&#x2F;code&gt;. Aside from this boilerplate, &lt;code&gt;MatchWithValueHandlers&amp;lt;ComputeArea&amp;gt;&lt;&#x2F;code&gt; takes care of automatically dispatching to the correct variant handler through &lt;code&gt;MatchWithHandlers&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;While &lt;code&gt;Shape&lt;&#x2F;code&gt; only has two variants, one of the major advantages of &lt;code&gt;MatchWithValueHandlers&lt;&#x2F;code&gt; is that it scales effortlessly to enums with many variants and more complex computations. For example, implementing &lt;code&gt;HasArea&lt;&#x2F;code&gt; for &lt;code&gt;ShapePlus&lt;&#x2F;code&gt; is just as simple:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;HasArea &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;ShapePlus {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;area(self) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;f64 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        MatchWithValueHandlers::&amp;lt;ComputeArea&amp;gt;::compute(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;(), PhantomData::&amp;lt;()&amp;gt;, self)
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Although some boilerplate still remains, this approach is significantly simpler than manually matching each variant or relying on procedural macros. It also brings more flexibility and type safety. In the future, CGP may provide more ergonomic abstractions on top of this pattern, making common use cases like &lt;code&gt;HasArea&lt;&#x2F;code&gt; even easier to express.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;dispatching-to-context&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#dispatching-to-context&quot; aria-label=&quot;Anchor link for: dispatching-to-context&quot;&gt;Dispatching to Context&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;In the earlier definition of &lt;code&gt;MatchWithValueHandlers&lt;&#x2F;code&gt;, we omitted one detail that it has a default type parameter for &lt;code&gt;Provider&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;MatchWithValueHandlers&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;Provider = UseContext&amp;gt; =
&lt;&#x2F;span&gt;&lt;span&gt;    UseInputDelegate&amp;lt;MatchWithFieldHandlersInputs&amp;lt;HandleFieldValue&amp;lt;Provider&amp;gt;&amp;gt;&amp;gt;;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This means that if no generic parameter is specified, &lt;code&gt;MatchWithValueHandlers&lt;&#x2F;code&gt; will default to using &lt;code&gt;UseContext&lt;&#x2F;code&gt; as the provider for &lt;code&gt;Computer&lt;&#x2F;code&gt;. If you’ve read the earlier blog posts, you may recall that &lt;code&gt;UseContext&lt;&#x2F;code&gt; is a generic provider that delegates its behavior to the consumer trait implementation from the given context. For example, the implementation of &lt;code&gt;Computer&lt;&#x2F;code&gt; for &lt;code&gt;UseContext&lt;&#x2F;code&gt; looks like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_provider]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;Context, Code, Input&amp;gt; Computer&amp;lt;Context, Code, Input&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;UseContext
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;    Context: CanCompute&amp;lt;Code, Input&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Output &lt;&#x2F;span&gt;&lt;span&gt;= Context::Output;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;compute(context: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;Context, code: PhantomData&amp;lt;Code&amp;gt;, input: Input) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;Output {
&lt;&#x2F;span&gt;&lt;span&gt;        context.compute(code, input)
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Using &lt;code&gt;UseContext&lt;&#x2F;code&gt; as the provider for dispatchers like &lt;code&gt;MatchWithValueHandlers&lt;&#x2F;code&gt; is especially useful because it enables the concrete context to define how each variant should be handled. For example, we can implement an &lt;code&gt;App&lt;&#x2F;code&gt; context that provides &lt;code&gt;Computer&lt;&#x2F;code&gt; implementations for various shapes like &lt;code&gt;Shape&lt;&#x2F;code&gt; and &lt;code&gt;ShapePlus&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_context]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;App;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;delegate_components! {
&lt;&#x2F;span&gt;&lt;span&gt;    AppComponents {
&lt;&#x2F;span&gt;&lt;span&gt;        ComputerComponent: UseInputDelegate&amp;lt;new AreaComputers &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            [
&lt;&#x2F;span&gt;&lt;span&gt;                Circle,
&lt;&#x2F;span&gt;&lt;span&gt;                Rectangle,
&lt;&#x2F;span&gt;&lt;span&gt;                Triangle,
&lt;&#x2F;span&gt;&lt;span&gt;            ]:
&lt;&#x2F;span&gt;&lt;span&gt;                ComputeArea,
&lt;&#x2F;span&gt;&lt;span&gt;            [
&lt;&#x2F;span&gt;&lt;span&gt;                Shape,
&lt;&#x2F;span&gt;&lt;span&gt;                ShapePlus,
&lt;&#x2F;span&gt;&lt;span&gt;            ]: MatchWithValueHandlers,
&lt;&#x2F;span&gt;&lt;span&gt;        }&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In this example, the &lt;code&gt;App&lt;&#x2F;code&gt; context uses &lt;code&gt;UseInputDelegate&lt;&#x2F;code&gt; to define how to compute areas. Variants like &lt;code&gt;Circle&lt;&#x2F;code&gt;, &lt;code&gt;Rectangle&lt;&#x2F;code&gt;, and &lt;code&gt;Triangle&lt;&#x2F;code&gt; are directly handled by &lt;code&gt;ComputeArea&lt;&#x2F;code&gt;. For &lt;code&gt;Shape&lt;&#x2F;code&gt; and &lt;code&gt;ShapePlus&lt;&#x2F;code&gt;, we use &lt;code&gt;MatchWithValueHandlers&lt;&#x2F;code&gt; without specifying a &lt;code&gt;Provider&lt;&#x2F;code&gt;, which means it defaults to &lt;code&gt;UseContext&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;With this setup, when &lt;code&gt;MatchWithValueHandlers&lt;&#x2F;code&gt; dispatches to the individual variants, it delegates to &lt;code&gt;App&lt;&#x2F;code&gt; itself instead of calling &lt;code&gt;ComputeArea&lt;&#x2F;code&gt; directly. This allows us to override the behavior of individual variants easily. For instance, if we want to replace the implementation for &lt;code&gt;Circle&lt;&#x2F;code&gt; with an optimized version, we can simply change the wiring in &lt;code&gt;AppComponents&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;delegate_components! {
&lt;&#x2F;span&gt;&lt;span&gt;    AppComponents {
&lt;&#x2F;span&gt;&lt;span&gt;        ComputerComponent: UseInputDelegate&amp;lt;new AreaComputers &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            Circle: OptimizedCircleArea,
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;        }&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;the-flexibility-of-usecontext&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-flexibility-of-usecontext&quot; aria-label=&quot;Anchor link for: the-flexibility-of-usecontext&quot;&gt;The Flexibility of &lt;code&gt;UseContext&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;This kind of customization would be much harder to achieve if the dispatcher were tightly coupled to a concrete trait implementation, such as using &lt;code&gt;MatchWithValueHandlers&amp;lt;ComputeArea&amp;gt;&lt;&#x2F;code&gt; directly. In that case, the only way to change the behavior would be to modify the &lt;code&gt;HasArea&lt;&#x2F;code&gt; implementation for &lt;code&gt;Circle&lt;&#x2F;code&gt;, which would require ownership of either the &lt;code&gt;Circle&lt;&#x2F;code&gt; type or the &lt;code&gt;HasArea&lt;&#x2F;code&gt; trait.&lt;&#x2F;p&gt;
&lt;p&gt;While this level of indirection may seem unnecessary for a simple example like computing the area of a shape, it becomes crucial in more complex scenarios, such as the modular interpreter design discussed in &lt;a href=&quot;&#x2F;blog&#x2F;extensible-datatypes-part-2&quot;&gt;part 2&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;By routing the variant handling through &lt;code&gt;UseContext&lt;&#x2F;code&gt;, we also retain the flexibility to override the provider entirely. That means we can use &lt;code&gt;MatchWithValueHandlers&amp;lt;ComputeArea&amp;gt;&lt;&#x2F;code&gt; in cases where we don’t want to go through a &lt;code&gt;Context&lt;&#x2F;code&gt; at all, such as using &lt;code&gt;()&lt;&#x2F;code&gt; as the context. This optional &lt;code&gt;Provider&lt;&#x2F;code&gt; parameter gives us the best of both worlds: we can let the context provide the necessary wiring when needed, or directly specify a concrete provider when that makes more sense.&lt;&#x2F;p&gt;
&lt;p&gt;This pattern of using a provider parameter that defaults to &lt;code&gt;UseContext&lt;&#x2F;code&gt; is a recurring design strategy in CGP. It offers a powerful level of control, letting developers customize behavior in a modular and extensible way depending on their use case.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h1 id=&quot;visitor-dispatcher-by-reference&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#visitor-dispatcher-by-reference&quot; aria-label=&quot;Anchor link for: visitor-dispatcher-by-reference&quot;&gt;Visitor Dispatcher by Reference&lt;&#x2F;a&gt;&lt;&#x2F;h1&gt;
&lt;p&gt;In the earlier examples, some careful readers may have noticed a significant flaw in the function signatures for computing the area of shapes, such as in &lt;code&gt;HasArea::area&lt;&#x2F;code&gt;. These methods require &lt;em&gt;owned&lt;&#x2F;em&gt; values of the shape variants, meaning that each time we compute the area, we must consume the shape entirely. This is not ideal, especially when we only need a reference and want to preserve the original value.&lt;&#x2F;p&gt;
&lt;p&gt;We started with the ownership-based visitor dispatcher because it is conceptually simpler. It avoids the need to reason about lifetimes, making it easier to understand the overall implementation of extensible visitor. However, in this section, we will show how a reference-based visitor dispatcher can be built &lt;em&gt;on top of&lt;&#x2F;em&gt; the ownership-based version. Rather than requiring a separate mechanism, the reference-based version is actually a &lt;em&gt;specialization&lt;&#x2F;em&gt; of the existing system.&lt;&#x2F;p&gt;
&lt;p&gt;We will now walk through how to implement the reference-based visitor dispatcher in detail. By the end, you will see how Rust’s type system enables us to safely and cleanly extend the original approach to support references, without compromising lifetime safety or clarity.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;reference-based-area-computation&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#reference-based-area-computation&quot; aria-label=&quot;Anchor link for: reference-based-area-computation&quot;&gt;Reference-Based Area Computation&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;To demonstrate how reference-based visitor dispatch works, let’s define a new trait &lt;code&gt;HasAreaRef&lt;&#x2F;code&gt; that computes the area using a shared reference:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;HasAreaRef {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;area(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;f64&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;HasAreaRef &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;Circle {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;area(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;f64 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;PI &lt;&#x2F;span&gt;&lt;span&gt;* self.radius * self.radius
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;HasAreaRef &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;Rectangle { &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;... &lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;HasAreaRef &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;Triangle { &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;... &lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In practice, you probably wouldn’t need both &lt;code&gt;HasArea&lt;&#x2F;code&gt; and &lt;code&gt;HasAreaRef&lt;&#x2F;code&gt;, but for clarity we use a separate trait here to clearly distinguish between ownership-based and reference-based computations.&lt;&#x2F;p&gt;
&lt;p&gt;Next, we define a new provider &lt;code&gt;ComputeAreaRef&lt;&#x2F;code&gt; using &lt;code&gt;#[cgp_computer]&lt;&#x2F;code&gt;, which implements &lt;code&gt;ComputerRef&lt;&#x2F;code&gt; by calling &lt;code&gt;HasAreaRef&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_computer]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;compute_area_ref&amp;lt;T: HasAreaRef&amp;gt;(shape: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;T) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;f64 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    shape.area()
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;With this in place, we can now implement &lt;code&gt;HasAreaRef&lt;&#x2F;code&gt; for &lt;code&gt;Shape&lt;&#x2F;code&gt; by using &lt;code&gt;MatchWithValueHandlersRef&lt;&#x2F;code&gt;, the reference-based counterpart to &lt;code&gt;MatchWithValueHandlers&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;HasAreaRef &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;Shape {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;area(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;f64 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        MatchWithValueHandlersRef::&amp;lt;ComputeAreaRef&amp;gt;::compute_ref(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;(), PhantomData::&amp;lt;()&amp;gt;, self)
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Likewise, the implementation for &lt;code&gt;ShapePlus&lt;&#x2F;code&gt; follows the same pattern:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;HasAreaRef &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;ShapePlus {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;area(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;f64 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        MatchWithValueHandlersRef::&amp;lt;ComputeAreaRef&amp;gt;::compute_ref(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;(), PhantomData::&amp;lt;()&amp;gt;, self)
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;At first glance, using &lt;code&gt;MatchWithValueHandlersRef&lt;&#x2F;code&gt; to enable reference-based dispatch may seem straightforward — and in many ways, it is. As we’ll see next, the core logic mirrors the ownership-based version closely, with only a few additional considerations around generic lifetimes.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;partialref-variants&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#partialref-variants&quot; aria-label=&quot;Anchor link for: partialref-variants&quot;&gt;&lt;code&gt;PartialRef&lt;&#x2F;code&gt; Variants&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Although most of the higher-level support for reference-based extensible visitors is relatively straightforward, we first need to generate reference-aware partial variants within &lt;code&gt;#[derive(ExtractField)]&lt;&#x2F;code&gt;. For example, for the &lt;code&gt;Shape&lt;&#x2F;code&gt; enum, the macro generates the following reference-based partial variants:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub enum &lt;&#x2F;span&gt;&lt;span&gt;PartialRefShape&amp;lt;&amp;#39;a, F0: MapType, F1: MapType&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    Circle(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;F0&lt;&#x2F;span&gt;&lt;span&gt;::Map&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;#39;a&lt;&#x2F;span&gt;&lt;span&gt; Circle&amp;gt;),
&lt;&#x2F;span&gt;&lt;span&gt;    Rectangle(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;F1&lt;&#x2F;span&gt;&lt;span&gt;::Map&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;#39;a&lt;&#x2F;span&gt;&lt;span&gt; Rectangle&amp;gt;),
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Compared to the owned version &lt;code&gt;PartialShape&lt;&#x2F;code&gt;, the &lt;code&gt;PartialRefShape&lt;&#x2F;code&gt; definition introduces a lifetime parameter &lt;code&gt;&#x27;a&lt;&#x2F;code&gt;, and each of its fields now contains a reference with that lifetime. This allows us to safely operate on borrowed variants without taking ownership.&lt;&#x2F;p&gt;
&lt;p&gt;We need a distinct &lt;code&gt;PartialRefShape&lt;&#x2F;code&gt; type rather than reusing &lt;code&gt;PartialShape&lt;&#x2F;code&gt; because Rust currently has no native mechanism to generically express a value that is either owned or borrowed based on some type-level condition. For instance, if Rust had a concept like a special &lt;code&gt;&#x27;owned&lt;&#x2F;code&gt; lifetime where &lt;code&gt;&amp;amp;&#x27;owned T&lt;&#x2F;code&gt; could be treated as just &lt;code&gt;T&lt;&#x2F;code&gt;, then it might be possible to unify the two representations. But such a feature does not exist, and arguably shouldn&#x27;t.&lt;&#x2F;p&gt;
&lt;p&gt;Given that limitation, the cleanest solution is to define a separate enum that introduces a lifetime parameter and holds references explicitly. Since these types are generated by macros and used internally within CGP&#x27;s dispatching infrastructure, the added complexity is well-contained and does not burden the end user.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;hasextractorref-trait&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#hasextractorref-trait&quot; aria-label=&quot;Anchor link for: hasextractorref-trait&quot;&gt;&lt;code&gt;HasExtractorRef&lt;&#x2F;code&gt; Trait&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;In addition to the partial-ref variants, we need a new trait called &lt;code&gt;HasExtractorRef&lt;&#x2F;code&gt; that extracts data from a reference to the full enum:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;HasExtractorRef {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;ExtractorRef&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;#39;a&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;#39;a&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;extractor_ref&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;#39;a&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;#39;a &lt;&#x2F;span&gt;&lt;span&gt;self) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;ExtractorRef&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;#39;a&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Compared to the &lt;code&gt;HasExtractor&lt;&#x2F;code&gt; trait, &lt;code&gt;HasExtractorRef&lt;&#x2F;code&gt; introduces a generic associated type &lt;code&gt;ExtractorRef&lt;&#x2F;code&gt; that is parameterized by a lifetime &lt;code&gt;&#x27;a&lt;&#x2F;code&gt; and requires the constraint &lt;code&gt;Self: &#x27;a&lt;&#x2F;code&gt;. It also defines an &lt;code&gt;extractor_ref&lt;&#x2F;code&gt; method that takes a &lt;code&gt;&amp;amp;&#x27;a self&lt;&#x2F;code&gt; reference and returns the corresponding partial-ref variants as &lt;code&gt;ExtractorRef&amp;lt;&#x27;a&amp;gt;&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Other than the addition of the lifetime parameter, implementing &lt;code&gt;HasExtractorRef&lt;&#x2F;code&gt; for &lt;code&gt;Shape&lt;&#x2F;code&gt; is straightforward, as shown below:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;HasExtractorRef &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;Shape {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;ExtractorRef&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;#39;a&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; = PartialRefShape&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;#39;a&lt;&#x2F;span&gt;&lt;span&gt;, IsPresent, IsPresent&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where Self&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;#39;a&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;extractor_ref&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;#39;a&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;#39;a &lt;&#x2F;span&gt;&lt;span&gt;self) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;ExtractorRef&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;#39;a&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;match &lt;&#x2F;span&gt;&lt;span&gt;self {
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self&lt;&#x2F;span&gt;&lt;span&gt;::Circle(value) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;PartialRefShape::Circle(value),
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self&lt;&#x2F;span&gt;&lt;span&gt;::Rectangle(value) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;PartialRefShape::Rectangle(value),
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;With &lt;code&gt;extractor_ref&lt;&#x2F;code&gt;, it is now possible to extract data from a borrowed &lt;code&gt;Shape&lt;&#x2F;code&gt; without cloning each variant, enabling efficient reference-based dispatching.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;extractfield-implementation&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#extractfield-implementation&quot; aria-label=&quot;Anchor link for: extractfield-implementation&quot;&gt;&lt;code&gt;ExtractField&lt;&#x2F;code&gt; Implementation&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;Fortunately, beyond the partial-ref variants and the &lt;code&gt;HasExtractorRef&lt;&#x2F;code&gt; trait, most other traits can be reused as if we were working with owned values. This works because &lt;code&gt;PartialRefShape&lt;&#x2F;code&gt; holds what are effectively &quot;owned&quot; variant values in the form of references like &lt;code&gt;&amp;amp;&#x27;a Circle&lt;&#x2F;code&gt; and &lt;code&gt;&amp;amp;&#x27;a Rectangle&lt;&#x2F;code&gt;. For example, we can implement &lt;code&gt;ExtractField&lt;&#x2F;code&gt; for &lt;code&gt;PartialRefShape&lt;&#x2F;code&gt; like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;#39;a&lt;&#x2F;span&gt;&lt;span&gt;, F1: MapType&amp;gt; ExtractField&amp;lt;Symbol&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;(&amp;quot;Circle&amp;quot;)&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;PartialRefShape&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;#39;a&lt;&#x2F;span&gt;&lt;span&gt;, IsPresent, F1&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Value &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;#39;a&lt;&#x2F;span&gt;&lt;span&gt; Circle;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Remainder &lt;&#x2F;span&gt;&lt;span&gt;= PartialShape&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;#39;a&lt;&#x2F;span&gt;&lt;span&gt;, IsVoid, F1&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;extract_field(
&lt;&#x2F;span&gt;&lt;span&gt;        self,
&lt;&#x2F;span&gt;&lt;span&gt;        _tag: PhantomData&amp;lt;Symbol&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;(&amp;quot;Circle&amp;quot;)&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    ) -&amp;gt; Result&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;Value, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;Remainder&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;match &lt;&#x2F;span&gt;&lt;span&gt;self {
&lt;&#x2F;span&gt;&lt;span&gt;            PartialRefShape::Circle(value) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;Ok(value),
&lt;&#x2F;span&gt;&lt;span&gt;            PartialRefShape::Rectangle(value) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;Err(PartialRefShape::Rectangle(value)),
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We can reuse traits like &lt;code&gt;ExtractField&lt;&#x2F;code&gt; because the associated types such as &lt;code&gt;Value&lt;&#x2F;code&gt; do not need to be the owned values themselves — they can be references to those values instead. This lets us treat extensible variants as if they contain references to their fields, allowing us to manipulate them just like owned values.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;matchwithhandlersref&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#matchwithhandlersref&quot; aria-label=&quot;Anchor link for: matchwithhandlersref&quot;&gt;&lt;code&gt;MatchWithHandlersRef&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Because reference-based dispatching relies on &lt;code&gt;HasExtractorRef&lt;&#x2F;code&gt;, we also need to adapt downstream constructs like &lt;code&gt;MatchWithHandlers&lt;&#x2F;code&gt; to work with references instead of owned values. This adaptation is provided by &lt;code&gt;MatchWithHandlersRef&lt;&#x2F;code&gt;, which uses &lt;code&gt;HasExtractorRef&lt;&#x2F;code&gt; in place of &lt;code&gt;HasExtractor&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_provider]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;#39;a&lt;&#x2F;span&gt;&lt;span&gt;, Context, Code, Input, Output, Remainder, Handlers&amp;gt; Computer&amp;lt;Context, Code, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;#39;a&lt;&#x2F;span&gt;&lt;span&gt; Input&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    for MatchWithHandlersRef&amp;lt;Handlers&amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;    Input: HasExtractorRef,
&lt;&#x2F;span&gt;&lt;span&gt;    DispatchMatchers&amp;lt;Handlers&amp;gt;:
&lt;&#x2F;span&gt;&lt;span&gt;        Computer&amp;lt;Context, Code, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Input::&lt;&#x2F;span&gt;&lt;span&gt;ExtractorRef&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;#39;a&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;, Output = Result&amp;lt;Output, Remainder&amp;gt;&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    Remainder: FinalizeExtract,
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Output &lt;&#x2F;span&gt;&lt;span&gt;= Output;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;compute(context: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;Context, code: PhantomData&amp;lt;Code&amp;gt;, input: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;#39;a&lt;&#x2F;span&gt;&lt;span&gt; Input) -&amp;gt; Output {
&lt;&#x2F;span&gt;&lt;span&gt;        DispatchMatchers::compute(context, code, input.extractor_ref()).finalize_extract_result()
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In this implementation, &lt;code&gt;MatchWithHandlersRef&lt;&#x2F;code&gt; handles &lt;code&gt;Computer&lt;&#x2F;code&gt; over a borrowed input &lt;code&gt;&amp;amp;&#x27;a Input&lt;&#x2F;code&gt;. It requires the input type to implement &lt;code&gt;HasExtractorRef&lt;&#x2F;code&gt; so it can extract the appropriate partial-ref variant. The extracted value, which is of type &lt;code&gt;Input::ExtractorRef&amp;lt;&#x27;a&amp;gt;&lt;&#x2F;code&gt;, is then passed to &lt;code&gt;DispatchMatchers&lt;&#x2F;code&gt;, which processes it using the same monadic pipeline as in the owned-value case. After dispatching to the handlers, the &lt;code&gt;Output&lt;&#x2F;code&gt; from &lt;code&gt;Result&amp;lt;Output, Remainder&amp;gt;&lt;&#x2F;code&gt; is extracted by calling &lt;code&gt;finalize_extract_result&lt;&#x2F;code&gt;, which relies on the &lt;code&gt;Remainder&lt;&#x2F;code&gt; type to implement &lt;code&gt;FinalizeExtract&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;One subtle but important point is that &lt;code&gt;MatchWithHandlersRef&lt;&#x2F;code&gt; still implements &lt;code&gt;Computer&lt;&#x2F;code&gt; rather than &lt;code&gt;ComputerRef&lt;&#x2F;code&gt;. The same is true for the handlers invoked through &lt;code&gt;DispatchMatchers&lt;&#x2F;code&gt;, which also expect &lt;code&gt;Computer&lt;&#x2F;code&gt; implementations. As a result, reference-based visitor dispatching requires an intermediate conversion step. Variant handlers that originally implement &lt;code&gt;ComputerRef&lt;&#x2F;code&gt; must first be &quot;lifted&quot; into providers implementing &lt;code&gt;Computer&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;After constructing the reference-based pipeline, &lt;code&gt;MatchWithHandlersRef&lt;&#x2F;code&gt; can then unlift the entire pipeline to implement &lt;code&gt;ComputerRef&lt;&#x2F;code&gt;. This layered approach ensures that reference-based dispatching reuses the same infrastructure as the ownership-based version, while preserving type safety and proper lifetime handling.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;promoteref&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#promoteref&quot; aria-label=&quot;Anchor link for: promoteref&quot;&gt;&lt;code&gt;PromoteRef&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;In the same way that traits like &lt;code&gt;ExtractField&lt;&#x2F;code&gt; can operate on borrowed fields, the &lt;code&gt;Computer&lt;&#x2F;code&gt; trait can also work with borrowed inputs. In fact, the &lt;code&gt;#[cgp_computer]&lt;&#x2F;code&gt; macro expansion for the &lt;code&gt;compute_area_ref&lt;&#x2F;code&gt; function produces the following &lt;code&gt;Computer&lt;&#x2F;code&gt; implementation:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;Context, Code, T: HasAreaRef&amp;gt; Computer&amp;lt;Context, Code, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;T&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;ComputeAreaRef {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Output &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;f64&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;compute(_context: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;Context, _code: PhantomData&amp;lt;Code&amp;gt;, shape: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;T) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;f64 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        compute_area_ref(shape)
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Here, the &lt;code&gt;Computer&lt;&#x2F;code&gt; implementation for &lt;code&gt;ComputeAreaRef&lt;&#x2F;code&gt; accepts any reference &lt;code&gt;&amp;amp;T&lt;&#x2F;code&gt; as the input type, as long as &lt;code&gt;T&lt;&#x2F;code&gt; implements &lt;code&gt;HasAreaRef&lt;&#x2F;code&gt;. This demonstrates that the &lt;code&gt;Computer&lt;&#x2F;code&gt; trait itself is flexible enough to handle borrowed inputs directly, without the need for additional traits.&lt;&#x2F;p&gt;
&lt;p&gt;However, to make development more ergonomic, CGP provides the &lt;code&gt;ComputerRef&lt;&#x2F;code&gt; trait. Using &lt;code&gt;ComputerRef&lt;&#x2F;code&gt; eliminates the need to explicitly write &lt;code&gt;&amp;amp;T&lt;&#x2F;code&gt; in input type parameters and avoids the complexity of higher-ranked trait bounds in where clauses or input delegation. This makes &lt;code&gt;ComputerRef&lt;&#x2F;code&gt; better suited for working with borrowed inputs in a clean and consistent way.&lt;&#x2F;p&gt;
&lt;p&gt;To bridge &lt;code&gt;Computer&lt;&#x2F;code&gt; and &lt;code&gt;ComputerRef&lt;&#x2F;code&gt;, CGP offers the &lt;code&gt;PromoteRef&lt;&#x2F;code&gt; adapter. This adapter converts a provider that implements &lt;code&gt;Computer&lt;&#x2F;code&gt; for borrowed inputs into a &lt;code&gt;ComputerRef&lt;&#x2F;code&gt; provider. For example, the &lt;code&gt;ComputerRef&lt;&#x2F;code&gt; implementation for &lt;code&gt;ComputeAreaRef&lt;&#x2F;code&gt; is defined as follows:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;delegate_components! {
&lt;&#x2F;span&gt;&lt;span&gt;    ComputeAreaRef {
&lt;&#x2F;span&gt;&lt;span&gt;        ComputerRefComponent: PromoteRef&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This means that &lt;code&gt;ComputeAreaRef&lt;&#x2F;code&gt; implements &lt;code&gt;ComputerRef&lt;&#x2F;code&gt; through &lt;code&gt;PromoteRef&amp;lt;ComputeAreaRef&amp;gt;&lt;&#x2F;code&gt;, automatically lifting its &lt;code&gt;Computer&lt;&#x2F;code&gt; implementation for &lt;code&gt;&amp;amp;T&lt;&#x2F;code&gt; into a &lt;code&gt;ComputerRef&lt;&#x2F;code&gt; implementation.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;promotion-from-computer-to-computerref&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#promotion-from-computer-to-computerref&quot; aria-label=&quot;Anchor link for: promotion-from-computer-to-computerref&quot;&gt;Promotion from &lt;code&gt;Computer&lt;&#x2F;code&gt; to &lt;code&gt;ComputerRef&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;The &lt;code&gt;PromoteRef&lt;&#x2F;code&gt; adapter allows a provider that implements &lt;code&gt;Computer&lt;&#x2F;code&gt; for borrowed inputs to become a provider that implements &lt;code&gt;ComputerRef&lt;&#x2F;code&gt;. Its implementation is as follows:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_provider]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;Context, Code, Input, Provider, Output&amp;gt; ComputerRef&amp;lt;Context, Code, Input&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    for PromoteRef&amp;lt;Provider&amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;    Provider: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;#39;a&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; Computer&amp;lt;Context, Code, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;#39;a&lt;&#x2F;span&gt;&lt;span&gt; Input, Output = Output&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Output &lt;&#x2F;span&gt;&lt;span&gt;= Output;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;compute_ref(context: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;Context, tag: PhantomData&amp;lt;Code&amp;gt;, input: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;Input) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;Output {
&lt;&#x2F;span&gt;&lt;span&gt;        Provider::compute(context, tag, input)
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Here, &lt;code&gt;PromoteRef&lt;&#x2F;code&gt; implements &lt;code&gt;ComputerRef&lt;&#x2F;code&gt; as long as the inner &lt;code&gt;Provider&lt;&#x2F;code&gt; supports a higher-ranked trait bound, meaning it can implement &lt;code&gt;Computer&lt;&#x2F;code&gt; for all lifetimes &lt;code&gt;&#x27;a&lt;&#x2F;code&gt; of &lt;code&gt;&amp;amp;&#x27;a Input&lt;&#x2F;code&gt;. This pattern hides the complexity of higher-ranked trait bounds, so end users do not need to think about them when using &lt;code&gt;ComputerRef&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;One important detail is that &lt;code&gt;PromoteRef&lt;&#x2F;code&gt; requires the inner &lt;code&gt;Computer&lt;&#x2F;code&gt; provider to always produce the same &lt;code&gt;Output&lt;&#x2F;code&gt; type for any lifetime &lt;code&gt;&#x27;a&lt;&#x2F;code&gt;. This means that &lt;code&gt;PromoteRef&lt;&#x2F;code&gt; cannot be used if the &lt;code&gt;Output&lt;&#x2F;code&gt; type borrows from the input reference, because &lt;code&gt;ComputerRef&lt;&#x2F;code&gt; defines a single &lt;code&gt;Output&lt;&#x2F;code&gt; type that is independent of the lifetime of the input. This limitation follows naturally from the design of &lt;code&gt;ComputerRef&lt;&#x2F;code&gt;. When the output must borrow from the input, the user should implement &lt;code&gt;Computer&lt;&#x2F;code&gt; directly instead of using &lt;code&gt;ComputerRef&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;promotion-from-computerref-to-computer&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#promotion-from-computerref-to-computer&quot; aria-label=&quot;Anchor link for: promotion-from-computerref-to-computer&quot;&gt;Promotion from &lt;code&gt;ComputerRef&lt;&#x2F;code&gt; to &lt;code&gt;Computer&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;code&gt;PromoteRef&lt;&#x2F;code&gt; also works in the opposite direction, allowing a provider that implements &lt;code&gt;ComputerRef&lt;&#x2F;code&gt; to become a provider that implements &lt;code&gt;Computer&lt;&#x2F;code&gt; for borrowed inputs:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_provider]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;Context, Code, Input, Provider&amp;gt; Computer&amp;lt;Context, Code, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;Input&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;PromoteRef&amp;lt;Provider&amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;    Provider: ComputerRef&amp;lt;Context, Code, Input&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Output &lt;&#x2F;span&gt;&lt;span&gt;= Provider::Output;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;compute(context: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;Context, tag: PhantomData&amp;lt;Code&amp;gt;, input: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;Input) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;Output {
&lt;&#x2F;span&gt;&lt;span&gt;        Provider::compute_ref(context, tag, input)
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In this implementation, &lt;code&gt;PromoteRef&lt;&#x2F;code&gt; wraps a &lt;code&gt;Provider&lt;&#x2F;code&gt; that implements &lt;code&gt;ComputerRef&lt;&#x2F;code&gt; and forwards the call to &lt;code&gt;compute_ref&lt;&#x2F;code&gt;. As a result, it produces a &lt;code&gt;Computer&lt;&#x2F;code&gt; implementation that works with &lt;code&gt;&amp;amp;Input&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;With these two implementations, &lt;code&gt;PromoteRef&lt;&#x2F;code&gt; provides a bidirectional bridge between &lt;code&gt;Computer&lt;&#x2F;code&gt; and &lt;code&gt;ComputerRef&lt;&#x2F;code&gt;. This flexibility allows a single provider to adapt to whichever trait is more convenient for the task, whether the interface expects &lt;code&gt;Computer&lt;&#x2F;code&gt; or &lt;code&gt;ComputerRef&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;matchwithvaluehandlersref&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#matchwithvaluehandlersref&quot; aria-label=&quot;Anchor link for: matchwithvaluehandlersref&quot;&gt;&lt;code&gt;MatchWithValueHandlersRef&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;To support reference-based dispatching in CGP, we only need to introduce a few reference-specific constructs while keeping most of the implementation very similar to the original &lt;code&gt;MatchWithValueHandlers&lt;&#x2F;code&gt;. The definition of &lt;code&gt;MatchWithValueHandlersRef&lt;&#x2F;code&gt; is shown below:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;MatchWithValueHandlersRef&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;Provider&amp;gt; =
&lt;&#x2F;span&gt;&lt;span&gt;    UseInputDelegate&amp;lt;MatchWithFieldHandlersInputsRef&amp;lt;HandleFieldValue&amp;lt;PromoteRef&amp;lt;Provider&amp;gt;&amp;gt;&amp;gt;&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;delegate_components! {
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;lt;Input: HasFieldHandlers&amp;lt;Provider&amp;gt;, Provider&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    new MatchWithFieldHandlersInputsRef&amp;lt;Provider&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;        Input:
&lt;&#x2F;span&gt;&lt;span&gt;            PromoteRef&amp;lt;MatchWithHandlersRef&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Input::&lt;&#x2F;span&gt;&lt;span&gt;Handlers&amp;gt;&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;When comparing this definition to &lt;code&gt;MatchWithValueHandlers&lt;&#x2F;code&gt;, the most notable differences are the use of &lt;code&gt;MatchWithFieldHandlersInputsRef&lt;&#x2F;code&gt; and the additional wrapping with &lt;code&gt;PromoteRef&lt;&#x2F;code&gt; to facilitate conversions between &lt;code&gt;Computer&lt;&#x2F;code&gt; and &lt;code&gt;ComputerRef&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;example-use-of-matchwithvaluehandlersref&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#example-use-of-matchwithvaluehandlersref&quot; aria-label=&quot;Anchor link for: example-use-of-matchwithvaluehandlersref&quot;&gt;Example use of &lt;code&gt;MatchWithValueHandlersRef&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;To better understand how &lt;code&gt;MatchWithValueHandlersRef&lt;&#x2F;code&gt; works in practice, let us walk through what happens when we call &lt;code&gt;MatchWithValueHandlersRef&amp;lt;ComputeAreaRef&amp;gt;&lt;&#x2F;code&gt; on &lt;code&gt;Shape&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;HasAreaRef &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;Shape {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;area(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;f64 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        MatchWithValueHandlersRef::&amp;lt;ComputeAreaRef&amp;gt;::compute_ref(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;(), PhantomData::&amp;lt;()&amp;gt;, self)
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;Provider&lt;&#x2F;code&gt; argument to &lt;code&gt;MatchWithHandlers&lt;&#x2F;code&gt; is &lt;code&gt;ComputeAreaRef&lt;&#x2F;code&gt;, which is expanded into &lt;code&gt;HandleFieldValue&amp;lt;PromoteRef&amp;lt;ComputeAreaRef&amp;gt;&amp;gt;&lt;&#x2F;code&gt; when passed to &lt;code&gt;MatchWithFieldHandlersInputsRef&lt;&#x2F;code&gt;. The &lt;code&gt;UseInputDelegate&lt;&#x2F;code&gt; type is expected to implement &lt;code&gt;ComputerRef&lt;&#x2F;code&gt; for &lt;code&gt;Input = Shape&lt;&#x2F;code&gt;, and it delegates the work to &lt;code&gt;MatchWithFieldHandlersInputsRef&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Next, &lt;code&gt;MatchWithFieldHandlersInputsRef&lt;&#x2F;code&gt; is invoked with &lt;code&gt;Input&lt;&#x2F;code&gt; as &lt;code&gt;Shape&lt;&#x2F;code&gt; and &lt;code&gt;Provider&lt;&#x2F;code&gt; as &lt;code&gt;HandleFieldValue&amp;lt;PromoteRef&amp;lt;ComputeAreaRef&amp;gt;&amp;gt;&lt;&#x2F;code&gt;. The &lt;code&gt;Shape&lt;&#x2F;code&gt; type must implement &lt;code&gt;HasFieldHandlers&amp;lt;HandleFieldValue&amp;lt;PromoteRef&amp;lt;ComputeAreaRef&amp;gt;&amp;gt;&amp;gt;&lt;&#x2F;code&gt;, and its &lt;code&gt;Handlers&lt;&#x2F;code&gt; expand to:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;Product&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;[
&lt;&#x2F;span&gt;&lt;span&gt;    ExtractFieldAndHandle&amp;lt;Symbol&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Circle&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;), HandleFieldValue&amp;lt;PromoteRef&amp;lt;ComputeAreaRef&amp;gt;&amp;gt;&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    ExtractFieldAndHandle&amp;lt;Symbol&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Rectangle&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;), HandleFieldValue&amp;lt;PromoteRef&amp;lt;ComputeAreaRef&amp;gt;&amp;gt;&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The delegate entry maps to &lt;code&gt;PromoteRef&amp;lt;MatchWithHandlersRef&amp;lt;Input::Handlers&amp;gt;&amp;gt;&lt;&#x2F;code&gt;, which becomes:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;PromoteRef&amp;lt;MatchWithHandlersRef&amp;lt;Product&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;[
&lt;&#x2F;span&gt;&lt;span&gt;    ExtractFieldAndHandle&amp;lt;Symbol&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;(&amp;quot;Circle&amp;quot;), HandleFieldValue&amp;lt;PromoteRef&amp;lt;ComputeAreaRef&amp;gt;&amp;gt;&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    ExtractFieldAndHandle&amp;lt;Symbol&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Rectangle&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;), HandleFieldValue&amp;lt;PromoteRef&amp;lt;ComputeAreaRef&amp;gt;&amp;gt;&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;]&amp;gt;&amp;gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In order to implement &lt;code&gt;ComputerRef&lt;&#x2F;code&gt;, &lt;code&gt;PromoteRef&amp;lt;MatchWithHandlersRef&amp;lt;Input::Handlers&amp;gt;&amp;gt;&lt;&#x2F;code&gt; requires &lt;code&gt;MatchWithHandlersRef&amp;lt;Input::Handlers&amp;gt;&lt;&#x2F;code&gt; to implement &lt;code&gt;Computer&lt;&#x2F;code&gt;. For &lt;code&gt;MatchWithHandlersRef&amp;lt;Input::Handlers&amp;gt;&lt;&#x2F;code&gt; to implement &lt;code&gt;Computer&lt;&#x2F;code&gt;, its inner provider &lt;code&gt;HandleFieldValue&amp;lt;PromoteRef&amp;lt;ComputeAreaRef&amp;gt;&amp;gt;&lt;&#x2F;code&gt; must satisfy the following constraints:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Computer&amp;lt;(), (), Field&amp;lt;Symbol!(&quot;Circle&quot;), &amp;amp;Circle&amp;gt;&amp;gt;&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;Computer&amp;lt;(), (), Field&amp;lt;Symbol!(&quot;Rectangle&quot;), &amp;amp;Rectangle&amp;gt;&amp;gt;&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;After &lt;code&gt;HandleFieldValue&lt;&#x2F;code&gt; unwraps the actual field values, the inner provider &lt;code&gt;PromoteRef&amp;lt;ComputeAreaRef&amp;gt;&lt;&#x2F;code&gt; must implement:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Computer&amp;lt;(), (), &amp;amp;Circle&amp;gt;&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;Computer&amp;lt;(), (), &amp;amp;Rectangle&amp;gt;&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Finally, &lt;code&gt;PromoteRef&lt;&#x2F;code&gt; requires &lt;code&gt;ComputeAreaRef&lt;&#x2F;code&gt; to implement:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ComputerRef&amp;lt;(), (), Circle&amp;gt;&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;ComputerRef&amp;lt;(), (), Rectangle&amp;gt;&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;This example shows that the key to implementing &lt;code&gt;MatchWithValueHandlersRef&lt;&#x2F;code&gt; lies in understanding when to use &lt;code&gt;Computer&lt;&#x2F;code&gt; versus &lt;code&gt;ComputerRef&lt;&#x2F;code&gt;, and where to apply &lt;code&gt;PromoteRef&lt;&#x2F;code&gt; to bridge the two. While the type expansion can appear intimidating, most of the complexity is hidden behind these abstractions.&lt;&#x2F;p&gt;
&lt;p&gt;In practice, the usage of &lt;code&gt;MatchWithValueHandlersRef&lt;&#x2F;code&gt; feels almost identical to the ownership-based version, and the underlying implementation shares the same structure aside from a few reference-specific details.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h1 id=&quot;future-work&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#future-work&quot; aria-label=&quot;Anchor link for: future-work&quot;&gt;Future Work&lt;&#x2F;a&gt;&lt;&#x2F;h1&gt;
&lt;p&gt;The modular design of extensible variants makes it straightforward to extend the pattern for new use cases. There are several scenarios that are not yet supported in this initial version. While none of these are technically difficult to implement, the focus for this release has been on the core functionality and the writing of these blog posts. The following areas are planned for future work.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;additional-arguments&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#additional-arguments&quot; aria-label=&quot;Anchor link for: additional-arguments&quot;&gt;Additional Arguments&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;At present, extensible visitors do not support forwarding additional arguments to individual visitor handlers. This limitation prevents traits that require extra arguments, such as:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;HasArea {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;area(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self, scale_factor: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;f64&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;f64&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Here, the &lt;code&gt;area&lt;&#x2F;code&gt; method needs a &lt;code&gt;scale_factor&lt;&#x2F;code&gt; argument that must be passed through the visitor dispatcher to the variant handlers. To support this, we can create adapters similar to &lt;code&gt;ExtractFieldAndHandle&lt;&#x2F;code&gt; that bundle the extra arguments into the &lt;code&gt;Input&lt;&#x2F;code&gt;. We would then define alternative dispatchers, similar to &lt;code&gt;MatchWithValueHandlers&lt;&#x2F;code&gt;, which operate on these bundled inputs.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;mut-references&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#mut-references&quot; aria-label=&quot;Anchor link for: mut-references&quot;&gt;&lt;code&gt;&amp;amp;mut&lt;&#x2F;code&gt; References&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;The current reference-based dispatch system is hard-coded to use shared references (&lt;code&gt;&amp;amp;&lt;&#x2F;code&gt;). As a result, it does not support &lt;code&gt;&amp;amp;mut&lt;&#x2F;code&gt; references for mutable operations such as:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;CanScale {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;scale(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;self, factor: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;f64&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;To support mutable references, the design of partial-ref variants needs to be generalized to work with both &lt;code&gt;&amp;amp;&lt;&#x2F;code&gt; and &lt;code&gt;&amp;amp;mut&lt;&#x2F;code&gt;. This likely requires an abstraction similar to &lt;code&gt;MapType&lt;&#x2F;code&gt;, but for mapping the type of reference used for each field.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;simpler-dispatchers&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#simpler-dispatchers&quot; aria-label=&quot;Anchor link for: simpler-dispatchers&quot;&gt;Simpler Dispatchers&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;Although extensible visitors were designed with complex use cases like modular interpreters in mind, they are equally powerful for simpler needs, such as implementing plain Rust traits like &lt;code&gt;HasArea&lt;&#x2F;code&gt;. While this is already possible with the current infrastructure, the ergonomics leave much to be desired.&lt;&#x2F;p&gt;
&lt;p&gt;Users must first understand and use the &lt;code&gt;#[cgp_computer]&lt;&#x2F;code&gt; macro to define helper providers like &lt;code&gt;ComputeArea&lt;&#x2F;code&gt;, and then manually implement the trait by invoking &lt;code&gt;MatchWithValueHandlers::&amp;lt;ComputeArea&amp;gt;::compute()&lt;&#x2F;code&gt; with dummy context and code. For those unfamiliar with CGP, these steps impose unnecessary friction and cognitive load.&lt;&#x2F;p&gt;
&lt;p&gt;To improve usability, CGP could offer a procedural macro to automate this boilerplate. For instance, a trait could be annotated as follows:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_dispatch]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;HasArea {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;area(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;f64&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;#[cgp_dispatch]&lt;&#x2F;code&gt; macro would parse the trait definition and generate the necessary code to integrate it with the extensible visitor framework. This includes generating a blanket implementation for the trait so that it is automatically implemented for compatible enums like &lt;code&gt;Shape&lt;&#x2F;code&gt; or &lt;code&gt;ShapePlus&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;The generated implementation would resemble:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;Context&amp;gt; HasArea &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;Context
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;    Context: HasExtractorRef,
&lt;&#x2F;span&gt;&lt;span&gt;    MatchWithValueHandlersRef&amp;lt;ComputeArea&amp;gt;: ComputerRef&amp;lt;(), (), Context, Output = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;f64&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;area(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;f64 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        MatchWithValueHandlersRef::&amp;lt;ComputeArea&amp;gt;::compute_ref(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;(), PhantomData, self)
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;With such a macro in place, using extensible visitors to implement common traits would become as easy as annotating the trait with &lt;code&gt;#[cgp_dispatch]&lt;&#x2F;code&gt;, removing the need to understand the inner workings of CGP for simple use cases.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;custom-partial-records-updater&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#custom-partial-records-updater&quot; aria-label=&quot;Anchor link for: custom-partial-records-updater&quot;&gt;Custom Partial Records Updater&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Currently, partial records only support a small set of operations like &lt;code&gt;TakeField&lt;&#x2F;code&gt; and &lt;code&gt;BuildField&lt;&#x2F;code&gt;. This makes it difficult to customize behavior, such as overriding existing field values, filling empty fields with defaults, or taking a default value from an empty field.&lt;&#x2F;p&gt;
&lt;p&gt;To support these scenarios, more generalized interfaces for interacting with partial records are needed. A promising approach is to use &lt;em&gt;natural transformations&lt;&#x2F;em&gt; to implement generic field transformers. For example, a builder transformer would convert &lt;code&gt;IsNothing&lt;&#x2F;code&gt; fields into &lt;code&gt;IsPresent&lt;&#x2F;code&gt; fields, while an overrider transformer would convert either &lt;code&gt;IsNothing&lt;&#x2F;code&gt; or &lt;code&gt;IsPresent&lt;&#x2F;code&gt; fields into &lt;code&gt;IsPresent&lt;&#x2F;code&gt; fields. This would allow for flexible and reusable field manipulation strategies.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;explanation-for-computation-hierarchy&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#explanation-for-computation-hierarchy&quot; aria-label=&quot;Anchor link for: explanation-for-computation-hierarchy&quot;&gt;Explanation for Computation Hierarchy&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Beyond &lt;code&gt;Computer&lt;&#x2F;code&gt;, &lt;code&gt;ComputerRef&lt;&#x2F;code&gt;, and &lt;code&gt;Handler&lt;&#x2F;code&gt;, CGP defines several other traits that represent different kinds of computations. For example, &lt;code&gt;TryComputer&lt;&#x2F;code&gt; supports computations that may fail, and &lt;code&gt;TryComputerRef&lt;&#x2F;code&gt; handles fallible computations that operate on reference inputs. These traits make it possible to model a wide range of behaviors, from straightforward value computations to error-aware or reference-based processing.&lt;&#x2F;p&gt;
&lt;p&gt;CGP also provides constructs such as &lt;code&gt;Promote&lt;&#x2F;code&gt; that allow seamless conversion between different types of computation providers. In addition, it supports multiple ways to compose these providers. Two notable examples are &lt;code&gt;PipeHandlers&lt;&#x2F;code&gt; and &lt;code&gt;PipeMonadic&lt;&#x2F;code&gt;. Monadic composition in particular requires delicate explanation, because CGP’s approach to monads does not behave exactly like the familiar monads in Haskell. Understanding how these monadic pipelines operate is essential for developers who want to create more sophisticated and composable computation flows.&lt;&#x2F;p&gt;
&lt;p&gt;My original plan was to dedicate a fifth part of this series to explain the complete hierarchy of computation traits in CGP. However, the implementation details for extensible data types have already required extensive coverage, and attempting to include computation hierarchy in the same series would make it overwhelming. As a result, I have decided to split that explanation into its own dedicated post, or potentially a separate series, to provide the depth and clarity it deserves.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h1 id=&quot;conclusion&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#conclusion&quot; aria-label=&quot;Anchor link for: conclusion&quot;&gt;Conclusion&lt;&#x2F;a&gt;&lt;&#x2F;h1&gt;
&lt;p&gt;We have now reached the end of our deep dive into the implementation details of extensible variants and extensible visitors. To recap the journey, we began by defining the &lt;code&gt;FromVariant&lt;&#x2F;code&gt; trait, which allows constructing an enum from one of its variants. We then introduced partial variants, which mirror the structure of partial records but use &lt;code&gt;IsVoid&lt;&#x2F;code&gt; to indicate the absence of a variant.&lt;&#x2F;p&gt;
&lt;p&gt;From there, we defined the &lt;code&gt;HasExtractor&lt;&#x2F;code&gt; trait to convert an enum into its partial variants, followed by the &lt;code&gt;ExtractField&lt;&#x2F;code&gt; trait to extract a single variant from those partial variants. This led to the concept of remainders, representing what is left after a variant is extracted, and the &lt;code&gt;FinalizeExtract&lt;&#x2F;code&gt; trait, which finalizes a remainder once all its variants have been handled.&lt;&#x2F;p&gt;
&lt;p&gt;We then examined how upcasting and downcasting for enums are implemented. We explored how the &lt;code&gt;HasFields&lt;&#x2F;code&gt; implementation for enums represents a type-level sum of fields and how &lt;code&gt;FieldExtractor&lt;&#x2F;code&gt; is used to move fields between source and target partial variants. The difference between &lt;code&gt;CanUpcast&lt;&#x2F;code&gt; and &lt;code&gt;CanDowncast&lt;&#x2F;code&gt; boils down to choosing whether the &lt;code&gt;HasFields&lt;&#x2F;code&gt; implementation comes from the source or the target enum.&lt;&#x2F;p&gt;
&lt;p&gt;Next, we delved into the implementation of extensible visitors, beginning with &lt;code&gt;MatchWithHandlers&lt;&#x2F;code&gt; and &lt;code&gt;DispatchMatchers&lt;&#x2F;code&gt;. We saw that &lt;code&gt;DispatchMatchers&lt;&#x2F;code&gt; is structured as a monadic pipeline that short-circuits when it encounters an &lt;code&gt;Ok&lt;&#x2F;code&gt; value. We examined the role of field adapters like &lt;code&gt;ExtractFieldAndHandle&lt;&#x2F;code&gt; and &lt;code&gt;HandleFieldValue&lt;&#x2F;code&gt;, and we explored how &lt;code&gt;#[cgp_computer]&lt;&#x2F;code&gt; transforms a regular trait method into a &lt;code&gt;Computer&lt;&#x2F;code&gt; provider. We then discussed how &lt;code&gt;ToFieldsHandler&lt;&#x2F;code&gt; and &lt;code&gt;HasFieldHandlers&lt;&#x2F;code&gt; convert the tags in an enum’s &lt;code&gt;HasFields&lt;&#x2F;code&gt; implementation into the appropriate providers for use with &lt;code&gt;MatchWithHandlers&lt;&#x2F;code&gt;. Finally, we looked at how the top-level dispatcher &lt;code&gt;MatchWithValueHandlers&lt;&#x2F;code&gt; is assembled through type-level metaprogramming, combining all the earlier components into a cohesive system.&lt;&#x2F;p&gt;
&lt;p&gt;We concluded with the reference-based implementation of extensible visitors. This introduced reference-specific constructs such as partial-ref variants and the &lt;code&gt;HasExtractorRef&lt;&#x2F;code&gt; trait. We examined how &lt;code&gt;MatchWithHandlersRef&lt;&#x2F;code&gt; uses &lt;code&gt;HasExtractorRef&lt;&#x2F;code&gt; to extract borrowed variants, and how &lt;code&gt;PromoteRef&lt;&#x2F;code&gt; bridges between &lt;code&gt;Computer&lt;&#x2F;code&gt; and &lt;code&gt;ComputerRef&lt;&#x2F;code&gt; providers. We then saw that &lt;code&gt;MatchWithValueHandlersRef&lt;&#x2F;code&gt; is implemented with only minimal differences from its ownership-based counterpart, relying on &lt;code&gt;MatchWithHandlersRef&lt;&#x2F;code&gt; and &lt;code&gt;PromoteRef&lt;&#x2F;code&gt; to interleave &lt;code&gt;Computer&lt;&#x2F;code&gt; and &lt;code&gt;ComputerRef&lt;&#x2F;code&gt; computations.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;end-of-series&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#end-of-series&quot; aria-label=&quot;Anchor link for: end-of-series&quot;&gt;End of Series&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;We have reached the conclusion of this series on extensible data types. By now, you should have a clearer understanding of the design patterns that extensible data types make possible and how they can be applied to solve real-world problems in Rust.&lt;&#x2F;p&gt;
&lt;p&gt;Although some of the implementation details can be challenging, I hope this series has given you a solid sense of how extensible data types are structured, and why a type-driven approach allows our system to remain both modular and flexible as it grows.&lt;&#x2F;p&gt;
&lt;p&gt;More importantly, I hope these articles have helped you recognize the design patterns that underpin CGP. Learning to identify and apply these patterns will make your own CGP code more effective and give you tools you can use well beyond this particular topic.&lt;&#x2F;p&gt;
&lt;p&gt;The design and implementation of extensible data types push the boundaries of what CGP can achieve. They show how CGP can model advanced language features that are often only possible through direct integration into the Rust compiler. In day-to-day development, you may not need to reach for every advanced technique demonstrated here, but understanding that these patterns exist will broaden your perspective on what is possible.&lt;&#x2F;p&gt;
&lt;p&gt;Even if you have not fully absorbed every concept presented, I hope this series has inspired you to begin learning CGP from the fundamentals. It is important to realize that many of the basic CGP patterns may initially seem unnecessary or overengineered, yet they are the foundation that makes advanced patterns like extensible data types and &lt;a href=&quot;&#x2F;blog&#x2F;hypershell-release&#x2F;&quot;&gt;Hypershell&lt;&#x2F;a&gt; achievable.&lt;&#x2F;p&gt;
&lt;p&gt;Finally, you do not need to create entirely new language features or DSLs for CGP to prove valuable. In upcoming posts, we will explore more foundational and intermediate CGP patterns that can help you build practical and maintainable Rust applications. Thank you for following this series and for your support of the CGP project. Exciting developments are on the horizon, and I look forward to sharing them with you.&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>Programming Extensible Data Types in Rust with CGP - Part 3: Implementing Extensible Records</title>
        <published>2025-07-12T00:00:00+00:00</published>
        <updated>2025-07-12T00:00:00+00:00</updated>
        
        <author>
          <name>
            Soares Chen
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://www.contextgeneric.dev/blog/extensible-datatypes-part-3/"/>
        <id>https://www.contextgeneric.dev/blog/extensible-datatypes-part-3/</id>
        
        <content type="html" xml:base="https://www.contextgeneric.dev/blog/extensible-datatypes-part-3/">&lt;p&gt;Discuss on &lt;a href=&quot;https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;rust&#x2F;comments&#x2F;1lxv6zr&#x2F;the_design_and_implementation_of_extensible&#x2F;&quot;&gt;Reddit&lt;&#x2F;a&gt;, &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;orgs&#x2F;contextgeneric&#x2F;discussions&#x2F;14&quot;&gt;GitHub&lt;&#x2F;a&gt; or &lt;a href=&quot;https:&#x2F;&#x2F;discord.gg&#x2F;Hgk3rCw6pQ&quot;&gt;Discord&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;recap&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#recap&quot; aria-label=&quot;Anchor link for: recap&quot;&gt;Recap&lt;&#x2F;a&gt;&lt;&#x2F;h1&gt;
&lt;p&gt;This is the &lt;strong&gt;third&lt;&#x2F;strong&gt; part of the blog series on &lt;strong&gt;Programming Extensible Data Types in Rust with CGP&lt;&#x2F;strong&gt;. You can read the &lt;a href=&quot;&#x2F;blog&#x2F;extensible-datatypes-part-1&quot;&gt;first&lt;&#x2F;a&gt; and &lt;a href=&quot;&#x2F;blog&#x2F;extensible-datatypes-part-2&quot;&gt;second&lt;&#x2F;a&gt; parts here.&lt;&#x2F;p&gt;
&lt;p&gt;As a recap, we have covered the new release of &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;contextgeneric&#x2F;cgp&#x2F;releases&#x2F;tag&#x2F;v0.4.2&quot;&gt;&lt;strong&gt;CGP v0.4.2&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt; which now supports the use of &lt;strong&gt;extensible records and variants&lt;&#x2F;strong&gt;, allowing developers to write code that operates on &lt;em&gt;any struct containing specific fields&lt;&#x2F;em&gt; or &lt;em&gt;any enum containing specific variants&lt;&#x2F;em&gt;, without needing their concrete definition.&lt;&#x2F;p&gt;
&lt;p&gt;In the first part of the series, &lt;a href=&quot;&#x2F;blog&#x2F;extensible-datatypes-part-1&quot;&gt;&lt;strong&gt;Modular App Construction and Extensible Builders&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;, we demonstrated an example use of the &lt;strong&gt;extensible builder pattern&lt;&#x2F;strong&gt;, which uses &lt;strong&gt;extensible records&lt;&#x2F;strong&gt; to support modular construction of an application context.&lt;&#x2F;p&gt;
&lt;p&gt;Similarly, in the second part of the series, &lt;a href=&quot;&#x2F;blog&#x2F;extensible-datatypes-part-2&quot;&gt;&lt;strong&gt;Modular Interpreters and Extensible Visitors&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;, we saw how the modular visitor pattern allows us to implement evaluation and to-Lisp conversion for each variant of a language expression enum using separate visitor providers.&lt;&#x2F;p&gt;
&lt;p&gt;At this point, you’ve likely seen how these patterns can make real-world applications more modular and maintainable. If these examples have convinced you of CGP’s practical value, that’s great. But if you still feel the examples are not grounded enough in production use cases, you are welcome to pause here and revisit CGP later.&lt;&#x2F;p&gt;
&lt;p&gt;The next 2 parts of the series are aimed at readers who want to go deeper — those interested in how CGP implements extensible data types under the hood and who might even want to contribute to CGP itself by helping to build the real-world examples you’re looking for.&lt;&#x2F;p&gt;
&lt;p&gt;We will first explore the implementation of extensible records in this part, followed by the implementation of extensible variants in the coming Part 4.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;series-overview&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#series-overview&quot; aria-label=&quot;Anchor link for: series-overview&quot;&gt;Series Overview&lt;&#x2F;a&gt;&lt;&#x2F;h1&gt;
&lt;p&gt;&lt;a href=&quot;&#x2F;blog&#x2F;extensible-datatypes-part-1&quot;&gt;&lt;strong&gt;Part 1: Modular App Construction and Extensible Builders&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt; – In this introductory part, we present a high-level overview of the key features enabled by extensible data types. We then dive into a hands-on demonstration showing how extensible records can be used to build and compose modular builders for real-world applications.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a href=&quot;&#x2F;blog&#x2F;extensible-datatypes-part-2&quot;&gt;&lt;strong&gt;Part 2: Modular Interpreters and Extensible Visitors&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt; – This part continues the demonstration by introducing extensible variants. We use them to address the &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Expression_problem&quot;&gt;&lt;strong&gt;expression problem&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;, implementing a set of reusable interpreter components for a small toy language.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Part 3: Implementing Extensible Records&lt;&#x2F;strong&gt; (this post) – Here, we walk through the internal mechanics behind extensible records. We show how CGP supports the modular builder pattern demonstrated in Part 1 through its underlying type and trait machinery.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a href=&quot;&#x2F;blog&#x2F;extensible-datatypes-part-4&quot;&gt;&lt;strong&gt;Part 4: Implementing Extensible Variants&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt; – This part mirrors Part 3, but for extensible variants. We examine how extensible variants are implemented, and compare the differences and similarities between extensible records and variants.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;underlying-theory&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#underlying-theory&quot; aria-label=&quot;Anchor link for: underlying-theory&quot;&gt;Underlying Theory&lt;&#x2F;a&gt;&lt;&#x2F;h1&gt;
&lt;p&gt;The design of extensible data types in CGP is inspired by a rich body of research in the programming languages community. In particular, CGP draws heavily from the implementation techniques found in &lt;a href=&quot;https:&#x2F;&#x2F;wiki.haskell.org&#x2F;index.php?title=Generics&quot;&gt;&lt;strong&gt;datatype-generic programming in Haskell&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;, as well as ideas presented in the paper &lt;a href=&quot;https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;10.1145&#x2F;3290325&quot;&gt;&lt;strong&gt;Abstracting extensible data types: or, rows by any other name&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;. Concepts similar to CGP’s have also appeared in other languages under names like &lt;strong&gt;row polymorphism&lt;&#x2F;strong&gt; and &lt;strong&gt;polymorphic variants&lt;&#x2F;strong&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;While it might be too academic — or simply too dry — for this post to delve into all the theoretical differences between CGP and these approaches, it’s worth highlighting one essential distinction: CGP’s seamless integration of extensible data types with the CGP system itself. This tight integration sets CGP apart by making the extensibility not just a design principle, but a native part of how you build and scale software in Rust.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;constraint-propagation-problem&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#constraint-propagation-problem&quot; aria-label=&quot;Anchor link for: constraint-propagation-problem&quot;&gt;Constraint Propagation Problem&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;At the heart of CGP lies a powerful solution to a common challenge:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;how can we compose two generic functions that each rely on their own row constraints, and automatically propagate those constraints into the resulting composed function?&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;To illustrate this problem, consider the following simple example:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;first_name_to_string&amp;lt;Context&amp;gt;(context: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;Context) -&amp;gt; String
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;    Context: HasField&amp;lt;Symbol&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;(&amp;quot;first_name&amp;quot;), Value: Display&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    context.get_field(PhantomData).to_string()
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;last_name_to_string&amp;lt;Context&amp;gt;(context: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;Context) -&amp;gt; String
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;    Context: HasField&amp;lt;Symbol&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;(&amp;quot;last_name&amp;quot;), Value: Display&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    context.get_field(PhantomData).to_string()
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In this example, we define two functions that extract the &lt;code&gt;first_name&lt;&#x2F;code&gt; and &lt;code&gt;last_name&lt;&#x2F;code&gt; fields from a generic &lt;code&gt;Context&lt;&#x2F;code&gt; type and convert them to strings. The trait &lt;code&gt;HasField&lt;&#x2F;code&gt; is used to represent a &lt;strong&gt;row constraint&lt;&#x2F;strong&gt;, where field names are expressed as type-level strings using &lt;code&gt;Symbol!&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Now, suppose we want to combine the output of these two functions into a full name string. We can write a function that explicitly concatenates the two results, like so:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;full_name_to_string&amp;lt;Context&amp;gt;(context: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;Context) -&amp;gt; String
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;    Context: HasField&amp;lt;Symbol&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;(&amp;quot;first_name&amp;quot;), Value: Display&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;        + HasField&amp;lt;Symbol&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;(&amp;quot;last_name&amp;quot;), Value: Display&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    format!(
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{} {}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        first_name_to_string(context),
&lt;&#x2F;span&gt;&lt;span&gt;        last_name_to_string(context)
&lt;&#x2F;span&gt;&lt;span&gt;    )
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This works, but requires us to manually specify all the field constraints in the function signature. This becomes increasingly cumbersome as the number of required constraints grows.&lt;&#x2F;p&gt;
&lt;p&gt;More critically, it becomes difficult to write generic higher-order functions that can accept any two such functions with their own constraints, and automatically compose them into a new function that correctly propagates those constraints. For instance, consider this naive attempt:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;concate_outputs&amp;lt;Context&amp;gt;(
&lt;&#x2F;span&gt;&lt;span&gt;    fn_a: impl Fn(&amp;amp;Context) -&amp;gt; String,
&lt;&#x2F;span&gt;&lt;span&gt;    fn_b: impl Fn(&amp;amp;Context) -&amp;gt; String,
&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; impl Fn(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;Context) -&amp;gt; String {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;move |&lt;&#x2F;span&gt;&lt;span&gt;context&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;| &lt;&#x2F;span&gt;&lt;span&gt;format!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{} {}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, fn_a(context), fn_b(context))
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Here, &lt;code&gt;concate_outputs&lt;&#x2F;code&gt; takes two functions and returns a new one that calls both and concatenates their results. However, the function signature does not capture the constraints required by &lt;code&gt;fn_a&lt;&#x2F;code&gt; and &lt;code&gt;fn_b&lt;&#x2F;code&gt;. As a result, when we use this to build a composed function, we still have to restate all of the necessary constraints explicitly:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;full_name_to_string&amp;lt;Context&amp;gt;(context: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;Context) -&amp;gt; String
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;    Context: HasField&amp;lt;Symbol&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;(&amp;quot;first_name&amp;quot;), Value: Display&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;        + HasField&amp;lt;Symbol&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;(&amp;quot;last_name&amp;quot;), Value: Display&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; composed = concate_outputs(first_name_to_string, last_name_to_string);
&lt;&#x2F;span&gt;&lt;span&gt;    composed(context)
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This works within the body of a function, but it prevents us from defining the composed function as a top-level value. In other words, we cannot simply write something like:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; Invalid export
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub let&lt;&#x2F;span&gt;&lt;span&gt; full_name_to_string = concate_outputs(first_name_to_string, last_name_to_string);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;and then export that directly from a module. The constraints must still be manually declared somewhere, limiting the expressiveness and reusability of our composition.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;type-level-composition&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#type-level-composition&quot; aria-label=&quot;Anchor link for: type-level-composition&quot;&gt;Type-Level Composition&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;In many programming languages research, solving the problem of constraint-aware function composition typically requires advanced language features like &lt;strong&gt;constraint kinds&lt;&#x2F;strong&gt;. These features allow constraints to be expressed and manipulated at the type level, enabling functions with different requirements to be composed seamlessly. However, languages like Rust do not yet support these advanced capabilities. This limitation has been one of the major reasons why extensible data types have not seen broader adoption in the Rust and other mainstream languages.&lt;&#x2F;p&gt;
&lt;p&gt;The breakthrough that CGP introduces is the ability to perform this kind of composition in Rust today — without waiting for the language to evolve. The key insight is to &lt;strong&gt;represent functions as types&lt;&#x2F;strong&gt;, and then use CGP&#x27;s system of traits and type-level programming to manage composition and constraint propagation.&lt;&#x2F;p&gt;
&lt;p&gt;To see how this works, let’s begin by transforming two basic functions into CGP providers. Instead of writing traditional functions, we define &lt;code&gt;FirstNameToString&lt;&#x2F;code&gt; and &lt;code&gt;LastNameToString&lt;&#x2F;code&gt; as types that implement the &lt;code&gt;ComputerRef&lt;&#x2F;code&gt; trait:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_new_provider]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;Context, Code, Input&amp;gt; ComputerRef&amp;lt;Context, Code, Input&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;FirstNameToString
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;    Context: HasField&amp;lt;Symbol&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;(&amp;quot;first_name&amp;quot;), Value: Display&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Output &lt;&#x2F;span&gt;&lt;span&gt;= String;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;compute_ref(context: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;Context, _code: PhantomData&amp;lt;Code&amp;gt;, _input: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;Input) -&amp;gt; String {
&lt;&#x2F;span&gt;&lt;span&gt;        context.get_field(PhantomData).to_string()
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[cgp_new_provider]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;Context, Code, Input&amp;gt; ComputerRef&amp;lt;Context, Code, Input&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;LastNameToString
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;    Context: HasField&amp;lt;Symbol&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;(&amp;quot;last_name&amp;quot;), Value: Display&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Output &lt;&#x2F;span&gt;&lt;span&gt;= String;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;compute_ref(context: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;Context, _code: PhantomData&amp;lt;Code&amp;gt;, _input: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;Input) -&amp;gt; String {
&lt;&#x2F;span&gt;&lt;span&gt;        context.get_field(PhantomData).to_string()
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In this setup, &lt;code&gt;FirstNameToString&lt;&#x2F;code&gt; and &lt;code&gt;LastNameToString&lt;&#x2F;code&gt; are no longer standalone functions, but rather types that can be plugged into the CGP system. Each type implements the &lt;code&gt;ComputerRef&lt;&#x2F;code&gt; trait and specifies its output as a &lt;code&gt;String&lt;&#x2F;code&gt;. For simplicity, we ignore the &lt;code&gt;Code&lt;&#x2F;code&gt; and &lt;code&gt;Input&lt;&#x2F;code&gt; parameters, as they are not essential for this example.&lt;&#x2F;p&gt;
&lt;p&gt;Once we have our functions defined as types, we can now build a new provider that composes them:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_new_provider]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;Context, Code, Input, ProviderA, ProviderB&amp;gt; ComputerRef&amp;lt;Context, Code, Input&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    for ConcatOutputs&amp;lt;ProviderA, ProviderB&amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;    ProviderA: ComputerRef&amp;lt;Context, Code, Input, Output: Display&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    ProviderB: ComputerRef&amp;lt;Context, Code, Input, Output: Display&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Output &lt;&#x2F;span&gt;&lt;span&gt;= String;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;compute_ref(context: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;Context, code: PhantomData&amp;lt;Code&amp;gt;, input: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;Input) -&amp;gt; String {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; output_a = ProviderA::compute_ref(context, code, input);
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; output_b = ProviderB::compute_ref(context, code, input);
&lt;&#x2F;span&gt;&lt;span&gt;        format!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{} {}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, output_a, output_b)
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;code&gt;ConcatOutputs&lt;&#x2F;code&gt; acts as a &lt;strong&gt;higher-order provider&lt;&#x2F;strong&gt;: it composes two other providers and returns a new one that computes both and combines their results. This is conceptually similar to a higher-order function that takes two closures and returns a new closure, except that it operates entirely at the type level. It requires that both inner providers implement &lt;code&gt;ComputerRef&lt;&#x2F;code&gt; and produce outputs that implement &lt;code&gt;Display&lt;&#x2F;code&gt;, ensuring that both results can be formatted into a string.&lt;&#x2F;p&gt;
&lt;p&gt;The real power of this approach becomes evident when we compose the two providers with a simple &lt;strong&gt;type alias&lt;&#x2F;strong&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;FullNameToString &lt;&#x2F;span&gt;&lt;span&gt;= ConcatOutputs&amp;lt;FirstNameToString, LastNameToString&amp;gt;;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;With this definition, &lt;code&gt;FullNameToString&lt;&#x2F;code&gt; behaves like a single provider that computes the full name by combining the first and last name. What’s remarkable is that we don’t need to explicitly restate the underlying constraints from &lt;code&gt;FirstNameToString&lt;&#x2F;code&gt; and &lt;code&gt;LastNameToString&lt;&#x2F;code&gt;. Those constraints are &lt;strong&gt;inferred and propagated&lt;&#x2F;strong&gt; automatically, and will only be enforced at the point where &lt;code&gt;FullNameToString&lt;&#x2F;code&gt; is actually used.&lt;&#x2F;p&gt;
&lt;p&gt;This programming model effectively introduces &lt;strong&gt;lazy type-level computation&lt;&#x2F;strong&gt;. The logic for computing outputs is driven by trait implementations at the type level, but the actual evaluation only occurs when the provider is invoked. This allows CGP to perform complex, constraint-aware compositions without requiring language-level support.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;base-implementation&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#base-implementation&quot; aria-label=&quot;Anchor link for: base-implementation&quot;&gt;Base Implementation&lt;&#x2F;a&gt;&lt;&#x2F;h1&gt;
&lt;h2 id=&quot;hasfield-trait&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#hasfield-trait&quot; aria-label=&quot;Anchor link for: hasfield-trait&quot;&gt;&lt;code&gt;HasField&lt;&#x2F;code&gt; Trait&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Now that we have a clearer understanding of how CGP builds on extensible data types, it is time to take a closer look at the key field-related traits that CGP introduces to support this functionality. We begin with the simplest and most foundational trait: &lt;code&gt;HasField&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;The &lt;code&gt;HasField&lt;&#x2F;code&gt; trait has been part of CGP since its early versions, but it is still worth revisiting here to bridge the gap toward the more advanced constructs that follow. Its definition is straightforward:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;HasField&amp;lt;Tag&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Value&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;get_field(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self, _tag: PhantomData&amp;lt;Tag&amp;gt;) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;Self::&lt;&#x2F;span&gt;&lt;span&gt;Value;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This trait provides &lt;strong&gt;read-only access&lt;&#x2F;strong&gt; to individual fields of a struct, using &lt;code&gt;Tag&lt;&#x2F;code&gt; as the field identifier. The tag indicates which field we want to access, and can take one of two forms depending on the struct: &lt;code&gt;Symbol!(&quot;first_name&quot;)&lt;&#x2F;code&gt; for named fields, or &lt;code&gt;Index&amp;lt;0&amp;gt;&lt;&#x2F;code&gt; for tuple-style fields. The associated type &lt;code&gt;Value&lt;&#x2F;code&gt; represents the type of the field being accessed, and the &lt;code&gt;get_field&lt;&#x2F;code&gt; method returns a reference to that field.&lt;&#x2F;p&gt;
&lt;p&gt;The use of &lt;code&gt;PhantomData&amp;lt;Tag&amp;gt;&lt;&#x2F;code&gt; as an argument may look unusual at first, but it plays a critical role in allowing Rust to infer which field is being requested. When multiple &lt;code&gt;HasField&lt;&#x2F;code&gt; implementations are available for a type, this allows the compiler to resolve the correct one.&lt;&#x2F;p&gt;
&lt;p&gt;Consider the following struct:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[derive(HasField)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;Person {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;first_name: String,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;last_name: String,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;When the &lt;code&gt;HasField&lt;&#x2F;code&gt; macro is derived, it automatically generates implementations for both fields as follows.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;HasField&amp;lt;Symbol&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;(&amp;quot;first_name&amp;quot;)&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;Person {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Value &lt;&#x2F;span&gt;&lt;span&gt;= String;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;get_field(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self, _tag: PhantomData&amp;lt;Symbol&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;(&amp;quot;first_name&amp;quot;)&amp;gt;) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;Self::&lt;&#x2F;span&gt;&lt;span&gt;Value {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self.first_name
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;HasField&amp;lt;Symbol&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;(&amp;quot;last_name&amp;quot;)&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;Person {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Value &lt;&#x2F;span&gt;&lt;span&gt;= String;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;get_field(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self, _tag: PhantomData&amp;lt;Symbol&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;(&amp;quot;last_name&amp;quot;)&amp;gt;) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;Self::&lt;&#x2F;span&gt;&lt;span&gt;Value {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self.last_name
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This allows generic code to access either field in a type-safe way without requiring access to the concrete types.&lt;&#x2F;p&gt;
&lt;p&gt;With &lt;code&gt;HasField&lt;&#x2F;code&gt;, we can write code that reads from a subset of fields on a struct, enabling a flexible and reusable programming model. However, if we want to &lt;em&gt;construct&lt;&#x2F;em&gt; such subsets — as is required for the extensible builder pattern — we will first need to introduce a few additional building blocks.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;partial-records&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#partial-records&quot; aria-label=&quot;Anchor link for: partial-records&quot;&gt;Partial Records&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;One of the core limitations of Rust’s struct system is that when constructing a value, you must provide values for &lt;em&gt;all&lt;&#x2F;em&gt; of its fields. This rigidity makes it difficult to build structs in a piecemeal fashion. To overcome this, CGP introduces the idea of &lt;strong&gt;partial records&lt;&#x2F;strong&gt; — a way to represent a struct with some fields intentionally left out.&lt;&#x2F;p&gt;
&lt;p&gt;Let’s consider the same &lt;code&gt;Person&lt;&#x2F;code&gt; struct used previously:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[derive(BuildField)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;Person {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;first_name: String,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;last_name: String,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;When we derive the &lt;code&gt;BuildField&lt;&#x2F;code&gt; trait for this struct, CGP automatically generates a corresponding partial version of the struct called &lt;code&gt;PartialPerson&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;PartialPerson&amp;lt;F0: MapType, F1: MapType&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;first_name: F0::Map&amp;lt;String&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;last_name: F1::Map&amp;lt;String&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Here, &lt;code&gt;F0&lt;&#x2F;code&gt; and &lt;code&gt;F1&lt;&#x2F;code&gt; are type parameters that must implement the &lt;code&gt;MapType&lt;&#x2F;code&gt; trait. These type parameters control whether each field is present or not in a given instance of the partial struct.&lt;&#x2F;p&gt;
&lt;p&gt;The &lt;code&gt;MapType&lt;&#x2F;code&gt; trait is defined as follows:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;MapType {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Map&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;T&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This trait uses a &lt;em&gt;generic associated type&lt;&#x2F;em&gt; (GAT) called &lt;code&gt;Map&lt;&#x2F;code&gt; to determine how the original field types should be transformed. In particular, &lt;code&gt;Map&amp;lt;T&amp;gt;&lt;&#x2F;code&gt; will either be &lt;code&gt;T&lt;&#x2F;code&gt; itself (if the field is present) or a placeholder type &lt;code&gt;()&lt;&#x2F;code&gt; (if the field is missing).&lt;&#x2F;p&gt;
&lt;p&gt;To support this, CGP provides two implementations of the &lt;code&gt;MapType&lt;&#x2F;code&gt; trait. The first is &lt;code&gt;IsPresent&lt;&#x2F;code&gt;, which maps a type to itself to indicate that a field is included:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;IsPresent;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;MapType &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;IsPresent {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Map&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;T&amp;gt; = T;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The second is &lt;code&gt;IsNothing&lt;&#x2F;code&gt;, which maps every type to &lt;code&gt;()&lt;&#x2F;code&gt; to indicate that the field is absent:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;IsNothing;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;MapType &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;IsNothing {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Map&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;T&amp;gt; = ();
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;To see how this works in practice, suppose we want to construct a partial &lt;code&gt;Person&lt;&#x2F;code&gt; value that only includes the &lt;code&gt;first_name&lt;&#x2F;code&gt; field. We can instantiate the type as &lt;code&gt;PartialPerson&amp;lt;IsPresent, IsNothing&amp;gt;&lt;&#x2F;code&gt;, where &lt;code&gt;F0 = IsPresent&lt;&#x2F;code&gt; and &lt;code&gt;F1 = IsNothing&lt;&#x2F;code&gt;. The resulting type expands to:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;PartialPerson {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;first_name: String,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;last_name: (),
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This means we can create a partial instance like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; partial_person = PartialPerson::&amp;lt;IsPresent, IsNothing&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    first_name: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;John&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;.to_owned(),
&lt;&#x2F;span&gt;&lt;span&gt;    last_name: (),
&lt;&#x2F;span&gt;&lt;span&gt;};
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;hasbuilder-trait&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#hasbuilder-trait&quot; aria-label=&quot;Anchor link for: hasbuilder-trait&quot;&gt;&lt;code&gt;HasBuilder&lt;&#x2F;code&gt; Trait&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Once we have defined a partial record struct, we can introduce the &lt;code&gt;HasBuilder&lt;&#x2F;code&gt; trait. This trait allows us to initialize a partial record where &lt;em&gt;all fields are absent&lt;&#x2F;em&gt; by default:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;HasBuilder {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Builder&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;builder() -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;Builder;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;HasBuilder&lt;&#x2F;code&gt; trait defines an associated type called &lt;code&gt;Builder&lt;&#x2F;code&gt;, which represents the initial form of the partial record. The key requirement is that this &lt;code&gt;Builder&lt;&#x2F;code&gt; must have all of its fields empty, since the &lt;code&gt;builder()&lt;&#x2F;code&gt; method constructs it without requiring any input.&lt;&#x2F;p&gt;
&lt;p&gt;For the &lt;code&gt;Person&lt;&#x2F;code&gt; struct, we can implement the &lt;code&gt;HasBuilder&lt;&#x2F;code&gt; trait as follows:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;HasBuilder &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;Person {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Builder &lt;&#x2F;span&gt;&lt;span&gt;= PartialPerson&amp;lt;IsNothing, IsNothing&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;builder() -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;Builder {
&lt;&#x2F;span&gt;&lt;span&gt;        PartialPerson {
&lt;&#x2F;span&gt;&lt;span&gt;            first_name: (),
&lt;&#x2F;span&gt;&lt;span&gt;            last_name: (),
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In this implementation, the initial &lt;code&gt;Builder&lt;&#x2F;code&gt; is simply a &lt;code&gt;PartialPerson&lt;&#x2F;code&gt; type where both field parameters use the &lt;code&gt;IsNothing&lt;&#x2F;code&gt; type mapper. To construct the empty builder, we initialize each field with its mapped type, which for &lt;code&gt;IsNothing&lt;&#x2F;code&gt; is always the unit type &lt;code&gt;()&lt;&#x2F;code&gt;. This gives us a clean and predictable starting point for incrementally building up a complete &lt;code&gt;Person&lt;&#x2F;code&gt; instance.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;buildfield-trait&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#buildfield-trait&quot; aria-label=&quot;Anchor link for: buildfield-trait&quot;&gt;&lt;code&gt;BuildField&lt;&#x2F;code&gt; Trait&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;With the initial builder in place, the next step is to define the &lt;code&gt;BuildField&lt;&#x2F;code&gt; trait, which enables us to incrementally populate fields in the partial record. This trait is defined as follows:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;BuildField&amp;lt;Tag&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Value&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Output&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;build_field(self, _tag: PhantomData&amp;lt;Tag&amp;gt;, value: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;Value) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;Output;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;BuildField&lt;&#x2F;code&gt; trait is parameterized by a &lt;code&gt;Tag&lt;&#x2F;code&gt; type, which identifies the field being constructed, just like in the &lt;code&gt;HasField&lt;&#x2F;code&gt; trait. It also includes an associated type &lt;code&gt;Value&lt;&#x2F;code&gt;, representing the type of the field being added.&lt;&#x2F;p&gt;
&lt;p&gt;The trait additionally includes an associated type &lt;code&gt;Output&lt;&#x2F;code&gt;, which represents the new type of the builder after the field has been inserted. This &lt;code&gt;Output&lt;&#x2F;code&gt; type is essential because each insertion updates the builder’s type parameters, effectively transforming it into a new type that reflects the presence of additional fields.&lt;&#x2F;p&gt;
&lt;p&gt;The &lt;code&gt;build_field&lt;&#x2F;code&gt; method takes ownership of the current builder and consumes the new field value, returning an updated builder that includes the newly added field.&lt;&#x2F;p&gt;
&lt;p&gt;To see how this works in practice, consider the implementation of &lt;code&gt;BuildField&lt;&#x2F;code&gt; for the &lt;code&gt;first_name&lt;&#x2F;code&gt; field of the &lt;code&gt;PartialPerson&lt;&#x2F;code&gt; struct:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;F1: MapType&amp;gt; BuildField&amp;lt;Symbol&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;(&amp;quot;first_name&amp;quot;)&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;PartialPerson&amp;lt;IsNothing, F1&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Value &lt;&#x2F;span&gt;&lt;span&gt;= String;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Output &lt;&#x2F;span&gt;&lt;span&gt;= PartialPerson&amp;lt;IsPresent, F1&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;build_field(self, _tag: PhantomData&amp;lt;Symbol&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;(&amp;quot;first_name&amp;quot;)&amp;gt;, value: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;Value) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;Output {
&lt;&#x2F;span&gt;&lt;span&gt;        PartialPerson {
&lt;&#x2F;span&gt;&lt;span&gt;            first_name: value,
&lt;&#x2F;span&gt;&lt;span&gt;            last_name: self.last_name,
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In this implementation, we define &lt;code&gt;BuildField&amp;lt;Symbol!(&quot;first_name&quot;)&amp;gt;&lt;&#x2F;code&gt; for a &lt;code&gt;PartialPerson&lt;&#x2F;code&gt; where the &lt;code&gt;first_name&lt;&#x2F;code&gt; field is absent (&lt;code&gt;IsNothing&lt;&#x2F;code&gt;) and the &lt;code&gt;last_name&lt;&#x2F;code&gt; field is parameterized generically as &lt;code&gt;F1&lt;&#x2F;code&gt;. This means the implementation will work regardless of whether &lt;code&gt;last_name&lt;&#x2F;code&gt; is present or not. We specify the &lt;code&gt;Value&lt;&#x2F;code&gt; as &lt;code&gt;String&lt;&#x2F;code&gt;, which matches the type of &lt;code&gt;first_name&lt;&#x2F;code&gt;, and set the &lt;code&gt;Output&lt;&#x2F;code&gt; type to a new &lt;code&gt;PartialPerson&lt;&#x2F;code&gt; where the first parameter has been updated to &lt;code&gt;IsPresent&lt;&#x2F;code&gt;. The second parameter remains unchanged to preserve the existing state of &lt;code&gt;last_name&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;The method body constructs a new &lt;code&gt;PartialPerson&lt;&#x2F;code&gt; where the &lt;code&gt;first_name&lt;&#x2F;code&gt; field is now set to the given value, while the &lt;code&gt;last_name&lt;&#x2F;code&gt; field is carried over from the original builder.&lt;&#x2F;p&gt;
&lt;p&gt;Similarly, we can define &lt;code&gt;BuildField&lt;&#x2F;code&gt; for the &lt;code&gt;last_name&lt;&#x2F;code&gt; field:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;F0: MapType&amp;gt; BuildField&amp;lt;Symbol&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;(&amp;quot;last_name&amp;quot;)&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;PartialPerson&amp;lt;F0, IsNothing&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Value &lt;&#x2F;span&gt;&lt;span&gt;= String;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Output &lt;&#x2F;span&gt;&lt;span&gt;= PartialPerson&amp;lt;F0, IsPresent&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;build_field(self, _tag: PhantomData&amp;lt;Symbol&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;(&amp;quot;last_name&amp;quot;)&amp;gt;, value: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;Value) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;Output {
&lt;&#x2F;span&gt;&lt;span&gt;        PartialPerson {
&lt;&#x2F;span&gt;&lt;span&gt;            first_name: self.first_name,
&lt;&#x2F;span&gt;&lt;span&gt;            last_name: value,
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In this case, the generic parameter &lt;code&gt;F0&lt;&#x2F;code&gt; tracks the state of &lt;code&gt;first_name&lt;&#x2F;code&gt;, while &lt;code&gt;IsNothing&lt;&#x2F;code&gt; ensures that &lt;code&gt;last_name&lt;&#x2F;code&gt; is not yet present. The logic follows the same structure as the earlier implementation, simply updating the appropriate field.&lt;&#x2F;p&gt;
&lt;p&gt;With these implementations in place, we can now use the &lt;code&gt;HasBuilder&lt;&#x2F;code&gt; and &lt;code&gt;BuildField&lt;&#x2F;code&gt; traits together to construct a &lt;code&gt;Person&lt;&#x2F;code&gt; incrementally:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;Person::builder() &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; PartialPerson&amp;lt;IsNothing, IsNothing&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    .build_field(PhantomData::&amp;lt;Symbol&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;first_name&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;)&amp;gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;John&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;.to_string()) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; PartialPerson&amp;lt;IsPresent, IsNothing&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    .build_field(PhantomData::&amp;lt;Symbol&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;last_name&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;)&amp;gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Smith&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;.to_string()) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; PartialPerson&amp;lt;IsPresent, IsPresent&amp;gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Notably, the &lt;strong&gt;order&lt;&#x2F;strong&gt; in which fields are built does not matter. The type transformations ensure correctness regardless of sequencing, so the builder also works if we construct the &lt;code&gt;last_name&lt;&#x2F;code&gt; field first:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;Person::builder() &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; PartialPerson&amp;lt;IsNothing, IsNothing&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    .build_field(PhantomData::&amp;lt;Symbol&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;last_name&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;)&amp;gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Smith&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;.to_string()) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; PartialPerson&amp;lt;IsNothing, IsPresent&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    .build_field(PhantomData::&amp;lt;Symbol&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;first_name&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;)&amp;gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;John&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;.to_string()) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; PartialPerson&amp;lt;IsPresent, IsPresent&amp;gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This gives developers the freedom to build up records in any order while maintaining type safety.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;finalizebuild-trait&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#finalizebuild-trait&quot; aria-label=&quot;Anchor link for: finalizebuild-trait&quot;&gt;&lt;code&gt;FinalizeBuild&lt;&#x2F;code&gt; Trait&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;The previous example demonstrated how the &lt;code&gt;builder&lt;&#x2F;code&gt; and &lt;code&gt;build_field&lt;&#x2F;code&gt; methods can be used to construct values in the style of a fluent builder pattern. However, it is important to note that the result of the final &lt;code&gt;build_field&lt;&#x2F;code&gt; call is still a &lt;code&gt;PartialPerson&amp;lt;IsPresent, IsPresent&amp;gt;&lt;&#x2F;code&gt;, not a fully constructed &lt;code&gt;Person&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;This limitation arises because each &lt;code&gt;BuildField&lt;&#x2F;code&gt; implementation for &lt;code&gt;PartialPerson&lt;&#x2F;code&gt; is only responsible for inserting a single field. The presence or absence of other fields is abstracted away through generic type parameters, which means that the implementation cannot detect when the final field has been added. Consequently, there is no opportunity to directly return a &lt;code&gt;Person&lt;&#x2F;code&gt; value when the last required field is set.&lt;&#x2F;p&gt;
&lt;p&gt;While this might make the final construction step slightly more verbose, it is a deliberate trade-off. The generic nature of &lt;code&gt;BuildField&lt;&#x2F;code&gt; is what allows fields to be built in any order without having to implement every possible combination of partially constructed records — something that would otherwise result in an overwhelming combinatorial explosion of implementations.&lt;&#x2F;p&gt;
&lt;p&gt;To resolve this, CGP introduces the &lt;code&gt;FinalizeBuild&lt;&#x2F;code&gt; trait. This trait is used once the builder has been fully populated, converting the complete &lt;code&gt;PartialPerson&lt;&#x2F;code&gt; into a proper &lt;code&gt;Person&lt;&#x2F;code&gt; value:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;FinalizeBuild {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Output&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;finalize_build(self) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;Output;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;FinalizeBuild&lt;&#x2F;code&gt; trait defines an associated &lt;code&gt;Output&lt;&#x2F;code&gt; type, representing the final constructed result. The &lt;code&gt;finalize_build&lt;&#x2F;code&gt; method takes ownership of the builder and transforms it into the desired output.&lt;&#x2F;p&gt;
&lt;p&gt;For &lt;code&gt;PartialPerson&lt;&#x2F;code&gt;, the trait is implemented as follows:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;FinalizeBuild &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;PartialPerson&amp;lt;IsPresent, IsPresent&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Output &lt;&#x2F;span&gt;&lt;span&gt;= Person;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;finalize_build(self) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;Output {
&lt;&#x2F;span&gt;&lt;span&gt;        Person {
&lt;&#x2F;span&gt;&lt;span&gt;            first_name: self.first_name,
&lt;&#x2F;span&gt;&lt;span&gt;            last_name: self.last_name,
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This implementation only applies when all fields are marked as present. At this point, the builder contains all the data necessary to construct a &lt;code&gt;Person&lt;&#x2F;code&gt;, so the conversion is a straightforward transfer of fields.&lt;&#x2F;p&gt;
&lt;p&gt;With this in place, the build process becomes complete by appending a call to &lt;code&gt;finalize_build&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; person = Person::builder() &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; PartialPerson&amp;lt;IsNothing, IsNothing&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    .build_field(PhantomData::&amp;lt;Symbol&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;first_name&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;)&amp;gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;John&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;.to_string()) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; PartialPerson&amp;lt;IsPresent, IsNothing&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    .build_field(PhantomData::&amp;lt;Symbol&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;last_name&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;)&amp;gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Smith&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;.to_string()) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; PartialPerson&amp;lt;IsPresent, IsPresent&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    .finalize_build(); &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; Person
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Together, the partial record struct and the traits &lt;code&gt;HasBuilder&lt;&#x2F;code&gt;, &lt;code&gt;BuildField&lt;&#x2F;code&gt;, and &lt;code&gt;FinalizeBuild&lt;&#x2F;code&gt; form a solid and ergonomic foundation for supporting extensible records in CGP. All of these pieces are automatically generated by the &lt;code&gt;#[derive(BuildField)]&lt;&#x2F;code&gt; macro. We do not use multiple derive macros here, so as to ensure consistency and correctness, eliminating the possibility of compilation failures due to the user missing to derive one of these traits.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;implementation-of-record-merges&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#implementation-of-record-merges&quot; aria-label=&quot;Anchor link for: implementation-of-record-merges&quot;&gt;Implementation of Record Merges&lt;&#x2F;a&gt;&lt;&#x2F;h1&gt;
&lt;p&gt;With the field builder traits in place, we can now explore how the earlier &lt;a href=&quot;&#x2F;blog&#x2F;extensible-datatypes-part-1#safe-struct-building&quot;&gt;struct building&lt;&#x2F;a&gt; method &lt;code&gt;build_from&lt;&#x2F;code&gt; can be implemented to support merging a &lt;code&gt;Person&lt;&#x2F;code&gt; struct into a superset struct such as &lt;code&gt;Employee&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Before we can implement &lt;code&gt;build_from&lt;&#x2F;code&gt;, we first need a few more supporting constructs to enable the merging operation.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;intobuilder-trait&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#intobuilder-trait&quot; aria-label=&quot;Anchor link for: intobuilder-trait&quot;&gt;&lt;code&gt;IntoBuilder&lt;&#x2F;code&gt; Trait&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;In typical usage, partial records begin in an empty state and are gradually populated with field values until they can be finalized into a complete struct. However, we can also go in the &lt;strong&gt;opposite&lt;&#x2F;strong&gt; direction by converting a fully constructed struct &lt;em&gt;into&lt;&#x2F;em&gt; a partial record where all fields are present, and then progressively &lt;em&gt;remove&lt;&#x2F;em&gt; fields from it, one by one, until none remain.&lt;&#x2F;p&gt;
&lt;p&gt;This reverse direction is particularly important for the merging process, where we need to &lt;em&gt;move&lt;&#x2F;em&gt; fields out of a source struct and insert them into a target partial record, field by field.&lt;&#x2F;p&gt;
&lt;p&gt;To support this, we introduce the &lt;code&gt;IntoBuilder&lt;&#x2F;code&gt; trait:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;IntoBuilder {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Builder&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;into_builder(self) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;Builder;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This trait mirrors the structure of &lt;code&gt;HasBuilder&lt;&#x2F;code&gt;, with an associated &lt;code&gt;Builder&lt;&#x2F;code&gt; type that represents a partial record in which all fields are populated. The key difference is that &lt;code&gt;into_builder&lt;&#x2F;code&gt; consumes the original struct and produces its fully populated partial record equivalent.&lt;&#x2F;p&gt;
&lt;p&gt;The implementation of &lt;code&gt;IntoBuilder&lt;&#x2F;code&gt; for &lt;code&gt;Person&lt;&#x2F;code&gt; looks like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;IntoBuilder &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;Person {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Builder &lt;&#x2F;span&gt;&lt;span&gt;= PartialPerson&amp;lt;IsPresent, IsPresent&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;into_builder(self) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;Builder {
&lt;&#x2F;span&gt;&lt;span&gt;        PartialPerson {
&lt;&#x2F;span&gt;&lt;span&gt;            first_name: self.first_name,
&lt;&#x2F;span&gt;&lt;span&gt;            last_name: self.last_name,
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;If you compare this to the implementation of the earlier &lt;code&gt;FinalizeBuild&lt;&#x2F;code&gt; trait, you’ll see that they are nearly identical in structure. The only difference is the direction of conversion — &lt;code&gt;IntoBuilder&lt;&#x2F;code&gt; transforms a &lt;code&gt;Person&lt;&#x2F;code&gt; into a &lt;code&gt;PartialPerson&amp;lt;IsPresent, IsPresent&amp;gt;&lt;&#x2F;code&gt;, while &lt;code&gt;FinalizeBuild&lt;&#x2F;code&gt; does the reverse.&lt;&#x2F;p&gt;
&lt;p&gt;Even though these interfaces are similar, we define &lt;code&gt;IntoBuilder&lt;&#x2F;code&gt; and &lt;code&gt;FinalizeBuild&lt;&#x2F;code&gt; as separate traits. This distinction is valuable because it makes the intent of each trait clear and prevents accidental misuse. Each trait captures a specific stage in the lifecycle of a partial record, whether we are constructing it from scratch, building it up field by field, or tearing it down for merging.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;takefield-trait&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#takefield-trait&quot; aria-label=&quot;Anchor link for: takefield-trait&quot;&gt;&lt;code&gt;TakeField&lt;&#x2F;code&gt; Trait&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Now that we have the &lt;code&gt;IntoBuilder&lt;&#x2F;code&gt; trait to help convert a struct into a fully populated partial record, we also need a way to extract individual fields from that partial record. This is where the &lt;code&gt;TakeField&lt;&#x2F;code&gt; trait comes in. It serves as the &lt;em&gt;opposite&lt;&#x2F;em&gt; of &lt;code&gt;BuildField&lt;&#x2F;code&gt;, allowing us to take a field value &lt;em&gt;out&lt;&#x2F;em&gt; of a partial record:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;TakeField&amp;lt;Tag&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Value&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Remainder&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;take_field(self, _tag: PhantomData&amp;lt;Tag&amp;gt;) -&amp;gt; (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;Value, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;Remainder);
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;Tag&lt;&#x2F;code&gt; and &lt;code&gt;Value&lt;&#x2F;code&gt; types in &lt;code&gt;TakeField&lt;&#x2F;code&gt; behave just like they do in &lt;code&gt;BuildField&lt;&#x2F;code&gt; and &lt;code&gt;HasField&lt;&#x2F;code&gt;. What is new here is the associated type &lt;code&gt;Remainder&lt;&#x2F;code&gt;, which represents the state of the partial record after the specified field has been removed. The &lt;code&gt;take_field&lt;&#x2F;code&gt; method consumes &lt;code&gt;self&lt;&#x2F;code&gt; and returns a tuple containing the extracted field value along with the updated remainder of the partial record.&lt;&#x2F;p&gt;
&lt;p&gt;As an example, here is the &lt;code&gt;TakeField&lt;&#x2F;code&gt; implementation for extracting the &lt;code&gt;first_name&lt;&#x2F;code&gt; field from a &lt;code&gt;PartialPerson&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;F1&amp;gt; TakeField&amp;lt;Symbol&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;(&amp;quot;first_name&amp;quot;)&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;PartialPerson&amp;lt;IsPresent, F1&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Value &lt;&#x2F;span&gt;&lt;span&gt;= String;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Remainder &lt;&#x2F;span&gt;&lt;span&gt;= PartialPerson&amp;lt;IsNothing, F1&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;take_field(self, _tag: PhantomData&amp;lt;Symbol&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;(&amp;quot;first_name&amp;quot;)&amp;gt;) -&amp;gt; (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;Value, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;Remainder) {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; value = self.first_name;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; remainder = PartialPerson {
&lt;&#x2F;span&gt;&lt;span&gt;            first_name: (),
&lt;&#x2F;span&gt;&lt;span&gt;            last_name: self.last_name,
&lt;&#x2F;span&gt;&lt;span&gt;        };
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        (value, remainder)
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;As shown, this implementation is defined for a &lt;code&gt;PartialPerson&lt;&#x2F;code&gt; where the first generic parameter is &lt;code&gt;IsPresent&lt;&#x2F;code&gt;, indicating that the &lt;code&gt;first_name&lt;&#x2F;code&gt; field is available to be taken. In the resulting &lt;code&gt;Remainder&lt;&#x2F;code&gt;, that parameter is updated to &lt;code&gt;IsNothing&lt;&#x2F;code&gt;, reflecting the removal of the field. The method itself returns the &lt;code&gt;first_name&lt;&#x2F;code&gt; value and a new partial record with &lt;code&gt;first_name&lt;&#x2F;code&gt; cleared and the rest of the fields left untouched.&lt;&#x2F;p&gt;
&lt;p&gt;This setup provides the building blocks needed to flexibly extract and transfer fields, which is essential for safely merging one struct into another.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;hasfields-trait&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#hasfields-trait&quot; aria-label=&quot;Anchor link for: hasfields-trait&quot;&gt;&lt;code&gt;HasFields&lt;&#x2F;code&gt; Trait&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;With &lt;code&gt;IntoBuilder&lt;&#x2F;code&gt; available, we can now begin transferring fields from a source struct into a target partial record by peeling them off one at a time. To enable this process generically, we need a mechanism to &lt;em&gt;enumerate&lt;&#x2F;em&gt; the fields of a struct so that generic code can discover which fields are available for transfer.&lt;&#x2F;p&gt;
&lt;p&gt;This is where the &lt;code&gt;HasFields&lt;&#x2F;code&gt; trait comes into play. It is defined as follows:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;HasFields {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Fields&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;HasFields&lt;&#x2F;code&gt; trait includes a single associated type called &lt;code&gt;Fields&lt;&#x2F;code&gt;, which holds a &lt;em&gt;type-level list&lt;&#x2F;em&gt; representing all the fields of the struct. For example, here is how &lt;code&gt;HasFields&lt;&#x2F;code&gt; would be implemented for the &lt;code&gt;Person&lt;&#x2F;code&gt; struct:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;HasFields &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;Person {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Fields &lt;&#x2F;span&gt;&lt;span&gt;= Product&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;[
&lt;&#x2F;span&gt;&lt;span&gt;        Field&amp;lt;Symbol&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;first_name&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;), String&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        Field&amp;lt;Symbol&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;last_name&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;), String&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    ];
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Once the fields of a struct are made available as a type-level list, this list can be used to drive &lt;em&gt;type-level iteration&lt;&#x2F;em&gt; for field-wise operations such as merging. This lays the foundation for generically moving fields between records in a structured and type-safe way.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;buildfrom-trait&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#buildfrom-trait&quot; aria-label=&quot;Anchor link for: buildfrom-trait&quot;&gt;&lt;code&gt;BuildFrom&lt;&#x2F;code&gt; Trait&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;The &lt;code&gt;build_from&lt;&#x2F;code&gt; method is defined within the &lt;code&gt;CanBuildFrom&lt;&#x2F;code&gt; trait, which uses a blanket implementation to support merging fields from one struct into another:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;CanBuildFrom&amp;lt;Source&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Output&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;build_from(self, source: Source) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;Output;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;Builder, Source, Output&amp;gt; CanBuildFrom&amp;lt;Source&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;Builder
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;    Source: HasFields + IntoBuilder,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Source::&lt;&#x2F;span&gt;&lt;span&gt;Fields: FieldsBuilder&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Source::&lt;&#x2F;span&gt;&lt;span&gt;Builder, Builder, Output = Output&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Output &lt;&#x2F;span&gt;&lt;span&gt;= Output;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;build_from(self, source: Source) -&amp;gt; Output {
&lt;&#x2F;span&gt;&lt;span&gt;        Source::Fields::build_fields(source.into_builder(), self)
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In this setup, the &lt;code&gt;CanBuildFrom&lt;&#x2F;code&gt; trait is implemented for the partial record acting as the &lt;em&gt;target&lt;&#x2F;em&gt; of the merge, while the &lt;code&gt;Source&lt;&#x2F;code&gt; type is specified through a generic parameter. The trait defines an associated type &lt;code&gt;Output&lt;&#x2F;code&gt;, representing the result of merging the fields from &lt;code&gt;Source&lt;&#x2F;code&gt; into the current builder. The &lt;code&gt;build_from&lt;&#x2F;code&gt; method takes ownership of both the builder (&lt;code&gt;self&lt;&#x2F;code&gt;) and the source value, and returns a new builder that incorporates the fields from &lt;code&gt;Source&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;The blanket implementation of &lt;code&gt;CanBuildFrom&lt;&#x2F;code&gt; imposes several trait bounds. First, the &lt;code&gt;Source&lt;&#x2F;code&gt; type must implement both &lt;code&gt;HasFields&lt;&#x2F;code&gt; and &lt;code&gt;IntoBuilder&lt;&#x2F;code&gt;. These traits provide access to a type-level list of fields and the ability to convert &lt;code&gt;Source&lt;&#x2F;code&gt; into a partial record with all fields present. The field list obtained from &lt;code&gt;Source::Fields&lt;&#x2F;code&gt; must also implement the &lt;code&gt;FieldsBuilder&lt;&#x2F;code&gt; helper trait. This trait is responsible for driving the merge process field by field, taking as input the &lt;code&gt;Source::Builder&lt;&#x2F;code&gt; and the target &lt;code&gt;Builder&lt;&#x2F;code&gt; (i.e., &lt;code&gt;Self&lt;&#x2F;code&gt;), and producing an &lt;code&gt;Output&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;The implementation of &lt;code&gt;build_from&lt;&#x2F;code&gt; begins by converting the source into its partial form using &lt;code&gt;into_builder&lt;&#x2F;code&gt;, then delegates the merge logic to &lt;code&gt;FieldsBuilder::build_fields&lt;&#x2F;code&gt;, which handles transferring each field in sequence.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;fieldsbuilder-trait&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#fieldsbuilder-trait&quot; aria-label=&quot;Anchor link for: fieldsbuilder-trait&quot;&gt;&lt;code&gt;FieldsBuilder&lt;&#x2F;code&gt; Trait&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;The &lt;code&gt;FieldsBuilder&lt;&#x2F;code&gt; trait is a &lt;em&gt;private&lt;&#x2F;em&gt; helper used exclusively by the &lt;code&gt;CanBuildFrom&lt;&#x2F;code&gt; trait. It is defined as follows:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;trait &lt;&#x2F;span&gt;&lt;span&gt;FieldsBuilder&amp;lt;Source, Target&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Output&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;build_fields(source: Source, target: Target) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;Output;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Unlike &lt;code&gt;CanBuildFrom&lt;&#x2F;code&gt;, the parameters for &lt;code&gt;FieldsBuilder&lt;&#x2F;code&gt; are slightly reordered. The &lt;code&gt;Self&lt;&#x2F;code&gt; type represents the list of fields from the source struct, while &lt;code&gt;Source&lt;&#x2F;code&gt; and &lt;code&gt;Target&lt;&#x2F;code&gt; refer to the partial records we are merging from and into. The goal of this trait is to drive type-level iteration across the list of fields, one by one, and move each field from the source to the target.&lt;&#x2F;p&gt;
&lt;p&gt;To accomplish this, we start with an implementation that matches on the head of the &lt;code&gt;Fields&lt;&#x2F;code&gt; list:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;Source, Target, RestFields, Tag, Value&amp;gt; FieldsBuilder&amp;lt;Source, Target&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    for Cons&amp;lt;Field&amp;lt;Tag, Value&amp;gt;, RestFields&amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;    Source: TakeField&amp;lt;Tag, Value = Value&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    Target: BuildField&amp;lt;Tag, Value = Value&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    RestFields: FieldsBuilder&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Source::&lt;&#x2F;span&gt;&lt;span&gt;Remainder, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Target::&lt;&#x2F;span&gt;&lt;span&gt;Output&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Output &lt;&#x2F;span&gt;&lt;span&gt;= RestFields::Output;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;build_fields(source: Source, target: Target) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;Output {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let &lt;&#x2F;span&gt;&lt;span&gt;(value, next_source) = source.take_field(PhantomData);
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; next_target = target.build_field(PhantomData, value);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        RestFields::build_fields(next_source, next_target)
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Here, we pattern match the &lt;code&gt;Fields&lt;&#x2F;code&gt; type to &lt;code&gt;Cons&amp;lt;Field&amp;lt;Tag, Value&amp;gt;, RestFields&amp;gt;&lt;&#x2F;code&gt;, allowing us to extract the field name &lt;code&gt;Tag&lt;&#x2F;code&gt; and its type &lt;code&gt;Value&lt;&#x2F;code&gt;. Given this information, we require that the &lt;code&gt;Source&lt;&#x2F;code&gt; partial record implements &lt;code&gt;TakeField&lt;&#x2F;code&gt; and that the &lt;code&gt;Target&lt;&#x2F;code&gt; partial record implements &lt;code&gt;BuildField&lt;&#x2F;code&gt;, both using the same &lt;code&gt;Tag&lt;&#x2F;code&gt; and &lt;code&gt;Value&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;We then handle the remaining fields recursively by requiring &lt;code&gt;RestFields&lt;&#x2F;code&gt; to implement &lt;code&gt;FieldsBuilder&lt;&#x2F;code&gt;, using the &lt;code&gt;Remainder&lt;&#x2F;code&gt; type from &lt;code&gt;TakeField&lt;&#x2F;code&gt; as the next &lt;code&gt;Source&lt;&#x2F;code&gt;, and the &lt;code&gt;Output&lt;&#x2F;code&gt; type from &lt;code&gt;BuildField&lt;&#x2F;code&gt; as the next &lt;code&gt;Target&lt;&#x2F;code&gt;. This enables a seamless hand-off from one field to the next during the merging process.&lt;&#x2F;p&gt;
&lt;p&gt;The recursive chain is terminated by the base case, when there are no more fields left to process:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;Source, Target&amp;gt; FieldsBuilder&amp;lt;Source, Target&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;Nil {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Output &lt;&#x2F;span&gt;&lt;span&gt;= Target;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;build_fields(_source: Source, target: Target) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;Output {
&lt;&#x2F;span&gt;&lt;span&gt;        target
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In this final implementation, the &lt;code&gt;Source&lt;&#x2F;code&gt; partial record is now fully depleted — all fields have been taken out — so we simply return the &lt;code&gt;Target&lt;&#x2F;code&gt;, which now contains all the merged fields.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;example-use-of-buildfrom&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#example-use-of-buildfrom&quot; aria-label=&quot;Anchor link for: example-use-of-buildfrom&quot;&gt;Example Use of &lt;code&gt;BuildFrom&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;The implementation of &lt;code&gt;FieldsBuilder&lt;&#x2F;code&gt; can appear intimidating at first, particularly for readers unfamiliar with type-level programming. To make the process more approachable, let’s walk through a concrete example using &lt;code&gt;BuildFrom&lt;&#x2F;code&gt; to illustrate what actually happens under the hood.&lt;&#x2F;p&gt;
&lt;p&gt;Consider a new struct named &lt;code&gt;Employee&lt;&#x2F;code&gt;, which contains the same fields as &lt;code&gt;Person&lt;&#x2F;code&gt;, along with an additional field called &lt;code&gt;employee_id&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[derive(BuildField)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;Employee {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;employee_id: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u64&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;first_name: String,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;last_name: String,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We begin by constructing a &lt;code&gt;Person&lt;&#x2F;code&gt; value. After that, we can use &lt;code&gt;build_from&lt;&#x2F;code&gt; to merge its contents into a partially built &lt;code&gt;Employee&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; person = Person {
&lt;&#x2F;span&gt;&lt;span&gt;    first_name: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;John&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;.to_owned(),
&lt;&#x2F;span&gt;&lt;span&gt;    last_name: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Smith&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;.to_owned(),
&lt;&#x2F;span&gt;&lt;span&gt;};
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; employee = Employee::builder() &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; PartialEmployee&amp;lt;IsNothing, IsNothing, IsNothing&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    .build_from(person) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; PartialEmployee&amp;lt;IsNothing, IsPresent, IsPresent&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    .build_field(PhantomData::&amp;lt;Symbol&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;employee_id&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;)&amp;gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; PartialEmployee&amp;lt;IsPresent, IsPresent, IsPresent&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    .finalize_build(); &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; Person
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;When we call &lt;code&gt;build_from&lt;&#x2F;code&gt;, several steps take place behind the scenes:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;The type &lt;code&gt;PartialEmployee&amp;lt;IsNothing, IsNothing, IsNothing&amp;gt;&lt;&#x2F;code&gt; is required to implement &lt;code&gt;CanBuildFrom&amp;lt;Person&amp;gt;&lt;&#x2F;code&gt;.
&lt;ul&gt;
&lt;li&gt;The &lt;code&gt;Person&lt;&#x2F;code&gt; type implements &lt;code&gt;HasFields::Fields&lt;&#x2F;code&gt; as:&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;Product&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;[
&lt;&#x2F;span&gt;&lt;span&gt;    Field&amp;lt;Symbol&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;first_name&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;), String&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    Field&amp;lt;Symbol&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;last_name&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;), String&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;Person&lt;&#x2F;code&gt; also implements &lt;code&gt;IntoBuilder&lt;&#x2F;code&gt;, producing &lt;code&gt;PartialPerson&amp;lt;IsPresent, IsPresent&amp;gt;&lt;&#x2F;code&gt; as its &lt;code&gt;Builder&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;Person::Fields&lt;&#x2F;code&gt; must then implement &lt;code&gt;FieldsBuilder&amp;lt;PartialPerson&amp;lt;IsPresent, IsPresent&amp;gt;, PartialEmployee&amp;lt;IsNothing, IsNothing, IsNothing&amp;gt;&amp;gt;&lt;&#x2F;code&gt;.
&lt;ul&gt;
&lt;li&gt;The first &lt;code&gt;Cons&lt;&#x2F;code&gt; in the list matches:
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Tag&lt;&#x2F;code&gt; is &lt;code&gt;Symbol!(&quot;first_name&quot;)&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;Value&lt;&#x2F;code&gt; is &lt;code&gt;String&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;RestFields&lt;&#x2F;code&gt; is &lt;code&gt;Cons&amp;lt;Field&amp;lt;Symbol!(&quot;last_name&quot;), String&amp;gt;, Nil&amp;gt;&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;PartialPerson&amp;lt;IsPresent, IsPresent&amp;gt;&lt;&#x2F;code&gt; implements &lt;code&gt;TakeField&amp;lt;Symbol!(&quot;first_name&quot;), Value = String&amp;gt;&lt;&#x2F;code&gt;, resulting in:
&lt;ul&gt;
&lt;li&gt;A &lt;code&gt;Remainder&lt;&#x2F;code&gt; of &lt;code&gt;PartialPerson&amp;lt;IsNothing, IsPresent&amp;gt;&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;PartialEmployee&amp;lt;IsNothing, IsNothing, IsNothing&amp;gt;&lt;&#x2F;code&gt; implements &lt;code&gt;BuildField&amp;lt;Symbol!(&quot;first_name&quot;), Value = String&amp;gt;&lt;&#x2F;code&gt;, producing:
&lt;ul&gt;
&lt;li&gt;An &lt;code&gt;Output&lt;&#x2F;code&gt; of &lt;code&gt;PartialEmployee&amp;lt;IsNothing, IsPresent, IsNothing&amp;gt;&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;The remaining fields, &lt;code&gt;Cons&amp;lt;Field&amp;lt;Symbol!(&quot;last_name&quot;), String&amp;gt;, Nil&amp;gt;&lt;&#x2F;code&gt;, must now implement &lt;code&gt;FieldsBuilder&amp;lt;PartialPerson&amp;lt;IsNothing, IsPresent&amp;gt;, PartialEmployee&amp;lt;IsNothing, IsPresent, IsNothing&amp;gt;&amp;gt;&lt;&#x2F;code&gt;.
&lt;ul&gt;
&lt;li&gt;This matches:
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Tag&lt;&#x2F;code&gt; is &lt;code&gt;Symbol!(&quot;last_name&quot;)&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;Value&lt;&#x2F;code&gt; is &lt;code&gt;String&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;RestFields&lt;&#x2F;code&gt; is &lt;code&gt;Nil&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;PartialPerson&amp;lt;IsNothing, IsPresent&amp;gt;&lt;&#x2F;code&gt; implements &lt;code&gt;TakeField&amp;lt;Symbol!(&quot;last_name&quot;), Value = String&amp;gt;&lt;&#x2F;code&gt;, giving:
&lt;ul&gt;
&lt;li&gt;A &lt;code&gt;Remainder&lt;&#x2F;code&gt; of &lt;code&gt;PartialPerson&amp;lt;IsNothing, IsNothing&amp;gt;&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;PartialEmployee&amp;lt;IsNothing, IsPresent, IsNothing&amp;gt;&lt;&#x2F;code&gt; implements &lt;code&gt;BuildField&amp;lt;Symbol!(&quot;last_name&quot;), Value = String&amp;gt;&lt;&#x2F;code&gt;, yielding:
&lt;ul&gt;
&lt;li&gt;An &lt;code&gt;Output&lt;&#x2F;code&gt; of &lt;code&gt;PartialEmployee&amp;lt;IsNothing, IsPresent, IsPresent&amp;gt;&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;Finally, the &lt;code&gt;Nil&lt;&#x2F;code&gt; case implements &lt;code&gt;FieldsBuilder&amp;lt;PartialPerson&amp;lt;IsNothing, IsNothing&amp;gt;, PartialEmployee&amp;lt;IsNothing, IsPresent, IsPresent&amp;gt;&amp;gt;&lt;&#x2F;code&gt;, which concludes by returning:
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;PartialEmployee&amp;lt;IsNothing, IsPresent, IsPresent&amp;gt;&lt;&#x2F;code&gt; as the final &lt;code&gt;Output&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Although these steps may seem complex at first glance, a closer look reveals that the process simply moves each field from the &lt;code&gt;PartialPerson&lt;&#x2F;code&gt; instance into the &lt;code&gt;PartialEmployee&lt;&#x2F;code&gt;, one at a time. What makes this look more complicated is not the logic itself, but the fact that it is encoded entirely at the type level using traits and generics, rather than as regular Rust code.&lt;&#x2F;p&gt;
&lt;p&gt;If any part of this explanation remains unclear, it might be helpful to paste this blog post — or just this sub-section — into your favorite LLM and ask it to explain the process in simpler terms. Hopefully, the explanation provided here is already clear enough for an LLM to understand, so that it can in turn help make this pattern more accessible to developers who are still learning the intricacies of type-level programming.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;builder-dispatcher&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#builder-dispatcher&quot; aria-label=&quot;Anchor link for: builder-dispatcher&quot;&gt;Builder Dispatcher&lt;&#x2F;a&gt;&lt;&#x2F;h1&gt;
&lt;p&gt;With the &lt;code&gt;BuildFrom&lt;&#x2F;code&gt; trait in place, we can now explore how CGP implements generalized &lt;strong&gt;builder dispatchers&lt;&#x2F;strong&gt; that enable flexible and reusable ways to assemble struct fields from various sources.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;buildwithhandlers-provider&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#buildwithhandlers-provider&quot; aria-label=&quot;Anchor link for: buildwithhandlers-provider&quot;&gt;&lt;code&gt;BuildWithHandlers&lt;&#x2F;code&gt; Provider&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;In &lt;a href=&quot;&#x2F;blog&#x2F;extensible-datatypes-part-1&#x2F;#builder-dispatcher&quot;&gt;earlier examples&lt;&#x2F;a&gt;, we used a utility called &lt;code&gt;BuildAndMergeOutputs&lt;&#x2F;code&gt; to combine outputs from multiple builder providers such as &lt;code&gt;BuildSqliteClient&lt;&#x2F;code&gt;, &lt;code&gt;BuildHttpClient&lt;&#x2F;code&gt;, and &lt;code&gt;BuildOpenAiClient&lt;&#x2F;code&gt;. Under the hood, &lt;code&gt;BuildAndMergeOutputs&lt;&#x2F;code&gt; is built upon a more fundamental dispatcher named &lt;code&gt;BuildWithHandlers&lt;&#x2F;code&gt;. The implementation of this dispatcher looks like the following:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_provider]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;Context, Code, Input, Output, Builder, Handlers, Res&amp;gt; Computer&amp;lt;Context, Code, Input&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    for BuildWithHandlers&amp;lt;Output, Handlers&amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;    Output: HasBuilder&amp;lt;Builder = Builder&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    PipeHandlers&amp;lt;Handlers&amp;gt;: Computer&amp;lt;Context, Code, Builder, Output = Res&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    Res: FinalizeBuild&amp;lt;Output = Output&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Output &lt;&#x2F;span&gt;&lt;span&gt;= Output;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;compute(context: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;Context, code: PhantomData&amp;lt;Code&amp;gt;, _input: Input) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;Output {
&lt;&#x2F;span&gt;&lt;span&gt;        PipeHandlers::compute(context, code, Output::builder()).finalize_build()
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;BuildWithHandlers&lt;&#x2F;code&gt; struct is parameterized by an &lt;code&gt;Output&lt;&#x2F;code&gt; type, which is the final struct we want to construct, and a &lt;code&gt;Handlers&lt;&#x2F;code&gt; type, which represents a type-level list of builder handlers. These handlers will be used to incrementally populate the fields of the &lt;code&gt;Output&lt;&#x2F;code&gt; struct.&lt;&#x2F;p&gt;
&lt;p&gt;This provider implements the &lt;code&gt;Computer&lt;&#x2F;code&gt; trait for any combination of &lt;code&gt;Context&lt;&#x2F;code&gt;, &lt;code&gt;Code&lt;&#x2F;code&gt;, and &lt;code&gt;Input&lt;&#x2F;code&gt;, although the &lt;code&gt;Input&lt;&#x2F;code&gt; parameter is intentionally ignored. To begin, the dispatcher requires the &lt;code&gt;Output&lt;&#x2F;code&gt; type to implement &lt;code&gt;HasBuilder&lt;&#x2F;code&gt;, which gives access to an initially empty partial record through &lt;code&gt;Output::builder()&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Once the empty builder is obtained, it is passed as input to &lt;code&gt;PipeHandlers&amp;lt;Handlers&amp;gt;&lt;&#x2F;code&gt;, a pipeline that applies each handler in the list to progressively build up the partial record. The result of this pipeline must implement &lt;code&gt;FinalizeBuild&lt;&#x2F;code&gt;, allowing it to be converted into the fully constructed &lt;code&gt;Output&lt;&#x2F;code&gt; struct.&lt;&#x2F;p&gt;
&lt;p&gt;And yes, if you&#x27;re wondering whether this &lt;code&gt;PipeHandlers&lt;&#x2F;code&gt; is the same one used in &lt;a href=&quot;&#x2F;blog&#x2F;hypershell-release&quot;&gt;Hypershell&lt;&#x2F;a&gt; to build shell-like command pipelines — the answer is absolutely yes. &lt;code&gt;BuildWithHandlers&lt;&#x2F;code&gt; operates by initializing an empty partial record, passing it through a chain of handlers using &lt;code&gt;PipeHandlers&lt;&#x2F;code&gt;, and then finalizing the result into a complete struct. It’s the same elegant piping mechanism, just applied to a different domain.&lt;&#x2F;p&gt;
&lt;p&gt;This reuse of core abstractions like &lt;code&gt;Pipe&lt;&#x2F;code&gt; and &lt;code&gt;Handler&lt;&#x2F;code&gt; across different systems is one of the most powerful aspects of CGP. These components weren’t designed just for piping shell commands — they were built to support general-purpose &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Function_composition_%28computer_science%29&quot;&gt;function composition&lt;&#x2F;a&gt;, a core concept in functional programming.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;example-use-of-buildwithhandlers&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#example-use-of-buildwithhandlers&quot; aria-label=&quot;Anchor link for: example-use-of-buildwithhandlers&quot;&gt;Example Use of &lt;code&gt;BuildWithHandlers&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;The &lt;code&gt;BuildWithHandlers&lt;&#x2F;code&gt; trait serves as the foundational builder dispatcher in CGP. It is the low-level mechanism behind higher-level dispatchers like &lt;code&gt;BuildAndMergeOutputs&lt;&#x2F;code&gt;, and understanding it provides valuable insight into how CGP composes complex data construction pipelines.&lt;&#x2F;p&gt;
&lt;p&gt;Let’s walk through a concrete example to illustrate how &lt;code&gt;BuildWithHandlers&lt;&#x2F;code&gt; works in practice.&lt;&#x2F;p&gt;
&lt;p&gt;Suppose we have two &lt;code&gt;Computer&lt;&#x2F;code&gt; providers: one that constructs a &lt;code&gt;Person&lt;&#x2F;code&gt; and another that produces a &lt;code&gt;u64&lt;&#x2F;code&gt; value for the &lt;code&gt;employee_id&lt;&#x2F;code&gt; field. We can use &lt;code&gt;BuildWithHandlers&lt;&#x2F;code&gt; to compose these providers and construct an &lt;code&gt;Employee&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;We begin by implementing the two providers as simple functions using the &lt;code&gt;#[cgp_producer]&lt;&#x2F;code&gt; macro:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_producer]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;build_person() -&amp;gt; Person {
&lt;&#x2F;span&gt;&lt;span&gt;    Person {
&lt;&#x2F;span&gt;&lt;span&gt;        first_name: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;John&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;.to_owned(),
&lt;&#x2F;span&gt;&lt;span&gt;        last_name: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Smith&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;.to_owned(),
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[cgp_producer]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;build_employee_id() -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u64 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;#[cgp_producer]&lt;&#x2F;code&gt; macro generates provider implementations (named &lt;code&gt;BuildPerson&lt;&#x2F;code&gt; and &lt;code&gt;BuildEmployeeId&lt;&#x2F;code&gt;) that wrap these functions. These implementations conform to the &lt;code&gt;Computer&lt;&#x2F;code&gt; trait by automatically calling the associated function. This macro allows pure functions to be used as providers with minimal boilerplate, especially useful when you don&#x27;t need to depend on the generic &lt;code&gt;Context&lt;&#x2F;code&gt; or &lt;code&gt;Code&lt;&#x2F;code&gt; parameters.&lt;&#x2F;p&gt;
&lt;p&gt;Now, with both providers defined, we can compose them using &lt;code&gt;BuildWithHandlers&lt;&#x2F;code&gt; like so:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; employee = BuildWithHandlers::&amp;lt;
&lt;&#x2F;span&gt;&lt;span&gt;    Employee,
&lt;&#x2F;span&gt;&lt;span&gt;    Product&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;[
&lt;&#x2F;span&gt;&lt;span&gt;        BuildAndMerge&amp;lt;BuildPerson&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        BuildAndSetField&amp;lt;Symbol&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;employee_id&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;), BuildEmployeeId&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    ],
&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;::compute(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;(), PhantomData::&amp;lt;()&amp;gt;, ());
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In this example, we tell &lt;code&gt;BuildWithHandlers&lt;&#x2F;code&gt; that the final struct we want to build is &lt;code&gt;Employee&lt;&#x2F;code&gt;. We then provide a list of two builder handlers:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;BuildAndMerge&amp;lt;BuildPerson&amp;gt;&lt;&#x2F;code&gt; wraps the &lt;code&gt;BuildPerson&lt;&#x2F;code&gt; provider. It first calls the provider to build a &lt;code&gt;Person&lt;&#x2F;code&gt;, then uses &lt;code&gt;BuildFrom&lt;&#x2F;code&gt; to merge the resulting fields into the &lt;code&gt;PartialEmployee&lt;&#x2F;code&gt; builder.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;BuildAndSetField&amp;lt;Symbol!(&quot;employee_id&quot;), BuildEmployeeId&amp;gt;&lt;&#x2F;code&gt; wraps the &lt;code&gt;BuildEmployeeId&lt;&#x2F;code&gt; provider. It calls the provider to get the &lt;code&gt;u64&lt;&#x2F;code&gt; value and then uses &lt;code&gt;BuildField&lt;&#x2F;code&gt; to assign that value to the &lt;code&gt;employee_id&lt;&#x2F;code&gt; field.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;We invoke &lt;code&gt;compute&lt;&#x2F;code&gt; on the specialized &lt;code&gt;BuildWithHandlers&lt;&#x2F;code&gt;, using unit types &lt;code&gt;()&lt;&#x2F;code&gt; as dummy arguments for &lt;code&gt;Context&lt;&#x2F;code&gt;, &lt;code&gt;Code&lt;&#x2F;code&gt;, and &lt;code&gt;Input&lt;&#x2F;code&gt;. In real-world applications, these types would typically carry contextual information such as configurations or runtime.&lt;&#x2F;p&gt;
&lt;p&gt;This example demonstrates the flexibility of &lt;code&gt;BuildWithHandlers&lt;&#x2F;code&gt;. You’re not limited to merging entire record subsets — you can also work with providers that produce individual field values, then insert them into specific fields using composable builder logic.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;buildandmerge&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#buildandmerge&quot; aria-label=&quot;Anchor link for: buildandmerge&quot;&gt;&lt;code&gt;BuildAndMerge&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;The &lt;code&gt;BuildAndMerge&lt;&#x2F;code&gt; adapter is relatively simple and is defined as follows:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_provider]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;Context, Code, Builder, Provider, Output, Res&amp;gt; Computer&amp;lt;Context, Code, Builder&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    for BuildAndMerge&amp;lt;Provider&amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;    Provider: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;#39;a&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; Computer&amp;lt;Context, Code, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;#39;a&lt;&#x2F;span&gt;&lt;span&gt; Builder, Output = Res&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    Builder: CanBuildFrom&amp;lt;Res, Output = Output&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Output &lt;&#x2F;span&gt;&lt;span&gt;= Output;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;compute(context: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;Context, code: PhantomData&amp;lt;Code&amp;gt;, builder: Builder) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;Output {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; output = Provider::compute(context, code, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;builder);
&lt;&#x2F;span&gt;&lt;span&gt;        builder.build_from(output)
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;code&gt;BuildAndMerge&lt;&#x2F;code&gt; wraps an inner provider (such as &lt;code&gt;BuildPerson&lt;&#x2F;code&gt;) and expects the current &lt;code&gt;Builder&lt;&#x2F;code&gt; — a partial record for the target struct — as input. The inner provider is invoked with a &lt;strong&gt;reference&lt;&#x2F;strong&gt; to this builder as its inner input, allowing it to inspect any fields that may already be set. This feature enables more advanced scenarios where intermediate results influence later ones.&lt;&#x2F;p&gt;
&lt;p&gt;After the inner provider returns a value, &lt;code&gt;BuildAndMerge&lt;&#x2F;code&gt; uses the &lt;code&gt;BuildFrom&lt;&#x2F;code&gt; trait to merge the result into the existing builder. The merged builder is then returned as output.&lt;&#x2F;p&gt;
&lt;p&gt;In simpler cases like &lt;code&gt;BuildPerson&lt;&#x2F;code&gt;, the input builder is ignored, so the trait bounds are trivially satisfied. But the mechanism still works the same way: take a value and merge its fields into the partial record.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;buildandsetfield&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#buildandsetfield&quot; aria-label=&quot;Anchor link for: buildandsetfield&quot;&gt;&lt;code&gt;BuildAndSetField&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;The &lt;code&gt;BuildAndSetField&lt;&#x2F;code&gt; adapter works similarly but focuses on setting a single field rather than merging a full record:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_provider]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;Context, Code, Tag, Value, Provider, Output, Builder&amp;gt; Computer&amp;lt;Context, Code, Builder&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    for BuildAndSetField&amp;lt;Tag, Provider&amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;    Provider: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;#39;a&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; Computer&amp;lt;Context, Code, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;#39;a&lt;&#x2F;span&gt;&lt;span&gt; Builder, Output = Value&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    Builder: BuildField&amp;lt;Tag, Value = Value, Output = Output&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Output &lt;&#x2F;span&gt;&lt;span&gt;= Output;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;compute(context: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;Context, code: PhantomData&amp;lt;Code&amp;gt;, builder: Builder) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;Output {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; value = Provider::compute(context, code, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;builder);
&lt;&#x2F;span&gt;&lt;span&gt;        builder.build_field(PhantomData::&amp;lt;Tag&amp;gt;, value)
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Instead of calling &lt;code&gt;BuildFrom&lt;&#x2F;code&gt;, this adapter uses the &lt;code&gt;BuildField&lt;&#x2F;code&gt; trait to assign a value to a specific field. The field to be set is identified by &lt;code&gt;Tag&lt;&#x2F;code&gt;, and its value comes from the wrapped provider.&lt;&#x2F;p&gt;
&lt;p&gt;This adapter is ideal for cases where you have an individual value (such as &lt;code&gt;u64&lt;&#x2F;code&gt;) and want to insert it into a specific field (like &lt;code&gt;employee_id&lt;&#x2F;code&gt;).&lt;&#x2F;p&gt;
&lt;h2 id=&quot;mapfields-trait&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#mapfields-trait&quot; aria-label=&quot;Anchor link for: mapfields-trait&quot;&gt;&lt;code&gt;MapFields&lt;&#x2F;code&gt; Trait&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;In the previous example, we saw how to use &lt;code&gt;BuildWithHandlers&lt;&#x2F;code&gt; with a list of individual providers — each wrapped in &lt;code&gt;BuildAndMerge&lt;&#x2F;code&gt; or &lt;code&gt;BuildAndSetField&lt;&#x2F;code&gt; — to build a composite struct. This same pattern is what powers higher-level dispatchers like &lt;code&gt;BuildAndMergeOutputs&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Since the pattern of wrapping a list of handlers is so common, CGP provides the &lt;code&gt;MapFields&lt;&#x2F;code&gt; trait to simplify the process. Here’s how it’s defined:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;MapFields&amp;lt;Mapper&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Map&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;Mapper, Current, Rest&amp;gt; MapFields&amp;lt;Mapper&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;Cons&amp;lt;Current, Rest&amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;    Mapper: MapType,
&lt;&#x2F;span&gt;&lt;span&gt;    Rest: MapFields&amp;lt;Mapper&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Map &lt;&#x2F;span&gt;&lt;span&gt;= Cons&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Mapper::&lt;&#x2F;span&gt;&lt;span&gt;Map&amp;lt;Current&amp;gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Rest::&lt;&#x2F;span&gt;&lt;span&gt;Map&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;Mapper&amp;gt; MapFields&amp;lt;Mapper&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;Nil {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Map &lt;&#x2F;span&gt;&lt;span&gt;= Nil;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;MapFields&lt;&#x2F;code&gt; trait enables type-level mapping over a type-level list — very similar to how &lt;code&gt;.iter().map()&lt;&#x2F;code&gt; works on value-level lists in Rust. You pass in a &lt;code&gt;Mapper&lt;&#x2F;code&gt; that implements the &lt;code&gt;MapType&lt;&#x2F;code&gt; trait, and it is applied to each element in the list. This is the same &lt;code&gt;MapType&lt;&#x2F;code&gt; trait we’ve seen used earlier in other utilities, like &lt;code&gt;IsPresent&lt;&#x2F;code&gt; and &lt;code&gt;IsNothing&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;buildandmergeoutputs&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#buildandmergeoutputs&quot; aria-label=&quot;Anchor link for: buildandmergeoutputs&quot;&gt;&lt;code&gt;BuildAndMergeOutputs&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Now that we have the pieces in place, we can implement &lt;code&gt;BuildAndMergeOutputs&lt;&#x2F;code&gt; as a composition of &lt;code&gt;BuildWithHandlers&lt;&#x2F;code&gt; and &lt;code&gt;BuildAndMerge&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;We start by defining a simple type mapper called &lt;code&gt;ToBuildAndMergeHandler&lt;&#x2F;code&gt;, which takes any &lt;code&gt;Handler&lt;&#x2F;code&gt; type and maps it to a &lt;code&gt;BuildAndMerge&amp;lt;Handler&amp;gt;&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;ToBuildAndMergeHandler;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;MapType &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;ToBuildAndMergeHandler {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Map&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;Handler&amp;gt; = BuildAndMerge&amp;lt;Handler&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;With that, we can define &lt;code&gt;BuildAndMergeOutputs&lt;&#x2F;code&gt; simply as a &lt;em&gt;type alias&lt;&#x2F;em&gt;. It takes an &lt;code&gt;Output&lt;&#x2F;code&gt; type and a list of handler types, and internally applies &lt;code&gt;ToBuildAndMergeHandler&lt;&#x2F;code&gt; to each handler in the list. The result is passed to &lt;code&gt;BuildWithHandlers&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;BuildAndMergeOutputs&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;Output, Handlers&amp;gt; =
&lt;&#x2F;span&gt;&lt;span&gt;    BuildWithHandlers&amp;lt;Output, &amp;lt;Handlers &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as &lt;&#x2F;span&gt;&lt;span&gt;MapFields&amp;lt;ToBuildAndMergeHandler&amp;gt;&amp;gt;::Map&amp;gt;;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This implementation showcases the power of type-level composition in CGP. By combining smaller, reusable components like &lt;code&gt;BuildWithHandlers&lt;&#x2F;code&gt;, &lt;code&gt;BuildAndMerge&lt;&#x2F;code&gt;, and &lt;code&gt;MapFields&lt;&#x2F;code&gt;, we can construct higher-level abstractions like &lt;code&gt;BuildAndMergeOutputs&lt;&#x2F;code&gt; with minimal boilerplate and high flexibility.&lt;&#x2F;p&gt;
&lt;p&gt;This modular, composable design stands in contrast to traditional macro-based approaches. With macros, it’s much harder to verify that combining two smaller macros results in correct behavior — especially as the complexity grows. In contrast, with CGP&#x27;s type-level constructs, each piece remains type-checked and composable under well-defined &lt;code&gt;where&lt;&#x2F;code&gt; constraints. These constraints act as a safeguard, ensuring that the combined logic remains sound and predictable.&lt;&#x2F;p&gt;
&lt;p&gt;Moreover, this approach enables us to easily define other dispatcher variants, such as those that use &lt;code&gt;BuildAndSetField&lt;&#x2F;code&gt; instead of &lt;code&gt;BuildAndMerge&lt;&#x2F;code&gt;, without having to rewrite or duplicate core logic.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;hiding-constraints-with-delegate-components&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#hiding-constraints-with-delegate-components&quot; aria-label=&quot;Anchor link for: hiding-constraints-with-delegate-components&quot;&gt;Hiding Constraints with &lt;code&gt;delegate_components!&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;While it&#x27;s possible to define &lt;code&gt;BuildAndMergeOutputs&lt;&#x2F;code&gt; as a simple type alias, doing so introduces ergonomic issues when it’s used with a &lt;em&gt;generic&lt;&#x2F;em&gt; &lt;code&gt;Handlers&lt;&#x2F;code&gt; type provided by the caller.&lt;&#x2F;p&gt;
&lt;p&gt;Consider a situation where we want to implement a provider that wraps around &lt;code&gt;BuildAndMergeOutputs&lt;&#x2F;code&gt; in order to perform validation on the result before returning it. We might write something like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_new_provider]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;Context, Code, Input, Output, Handlers&amp;gt; Computer&amp;lt;Context, Code, Input&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    for BuildAndValidateOutput&amp;lt;Output, Handlers&amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;    BuildAndMergeOutputs&amp;lt;Output, Handlers&amp;gt;: Computer&amp;lt;Context, Code, Input&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Output &lt;&#x2F;span&gt;&lt;span&gt;= Output;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;compute(context: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;Context, code: PhantomData&amp;lt;Code&amp;gt;, input: Input) -&amp;gt; Output {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Here, &lt;code&gt;BuildAndValidateOutput&lt;&#x2F;code&gt; &lt;em&gt;statically&lt;&#x2F;em&gt; depends on &lt;code&gt;BuildAndMergeOutputs&lt;&#x2F;code&gt; by requiring that it implements &lt;code&gt;Computer&lt;&#x2F;code&gt;. However, this code won’t compile as-is. The problem is that &lt;code&gt;BuildAndMergeOutputs&lt;&#x2F;code&gt; is defined as a type alias that internally relies on a hidden constraint: &lt;code&gt;Handlers: MapFields&amp;lt;ToBuildAndMergeHandler&amp;gt;&lt;&#x2F;code&gt;. Since this constraint is not visible at the site of usage, the compiler now demands that we explicitly provide proof that &lt;code&gt;Handlers&lt;&#x2F;code&gt; satisfies this requirement.&lt;&#x2F;p&gt;
&lt;p&gt;While we could add the missing constraint to the &lt;code&gt;where&lt;&#x2F;code&gt; clause of &lt;code&gt;BuildAndValidateOutput&lt;&#x2F;code&gt;, this reduces the ergonomics and composability of the abstraction. It requires callers to understand the internal structure of &lt;code&gt;BuildAndMergeOutputs&lt;&#x2F;code&gt;, which goes against one of the core strengths of CGP — &lt;em&gt;hiding internal constraints&lt;&#x2F;em&gt; so they don&#x27;t leak into user code.&lt;&#x2F;p&gt;
&lt;p&gt;Fortunately, we can solve this by turning &lt;code&gt;BuildAndMergeOutputs&lt;&#x2F;code&gt; into a regular provider struct, and using the &lt;code&gt;delegate_components!&lt;&#x2F;code&gt; macro to &lt;strong&gt;delegate&lt;&#x2F;strong&gt; the &lt;code&gt;Computer&lt;&#x2F;code&gt; implementation to &lt;code&gt;BuildWithHandlers&lt;&#x2F;code&gt;, while keeping the necessary constraints encapsulated.&lt;&#x2F;p&gt;
&lt;p&gt;Here’s how:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;delegate_components! {
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;lt;Output, Handlers: MapFields&amp;lt;ToBuildAndMergeHandler&amp;gt;&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    new BuildAndMergeOutputs&amp;lt;Output, Handlers&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;        ComputerComponent:
&lt;&#x2F;span&gt;&lt;span&gt;            BuildWithHandlers&amp;lt;Output, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Handlers::&lt;&#x2F;span&gt;&lt;span&gt;Map&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This macro creates a new &lt;code&gt;BuildAndMergeOutputs&lt;&#x2F;code&gt; provider that wraps &lt;code&gt;BuildWithHandlers&lt;&#x2F;code&gt;, while adding the required constraint on &lt;code&gt;Handlers&lt;&#x2F;code&gt; behind the scenes. Internally, the macro expands into a &lt;code&gt;DelegateComponent&lt;&#x2F;code&gt; implementation like the following:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;Output, Handlers&amp;gt; DelegateComponent&amp;lt;ComputerComponent&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    for BuildAndMergeOutputs&amp;lt;Output, Handlers&amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;    Handlers: MapFields&amp;lt;ToBuildAndMergeHandler&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Delegate &lt;&#x2F;span&gt;&lt;span&gt;= BuildWithHandlers&amp;lt;Output, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Handlers::&lt;&#x2F;span&gt;&lt;span&gt;Map&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;With this setup, &lt;code&gt;BuildAndMergeOutputs&lt;&#x2F;code&gt; can now be used like any other CGP provider — without needing to manually restate its internal type constraints. This keeps client code clean and focused, and allows CGP abstractions to remain composable and extensible.&lt;&#x2F;p&gt;
&lt;p&gt;The key benefit of this pattern is that it avoids boilerplate while preserving type safety. Whenever a provider&#x27;s implementation is simply a thin wrapper around another provider with some added constraints, it&#x27;s much more convenient to use &lt;code&gt;DelegateComponent&lt;&#x2F;code&gt; via &lt;code&gt;delegate_components!&lt;&#x2F;code&gt; than to implement the provider trait manually.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;type-level-metaprogramming&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#type-level-metaprogramming&quot; aria-label=&quot;Anchor link for: type-level-metaprogramming&quot;&gt;Type-Level Metaprogramming&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;The technique we just explored — wrapping providers and using &lt;code&gt;delegate_components!&lt;&#x2F;code&gt; — can be seen as a form of &lt;strong&gt;metaprogramming&lt;&#x2F;strong&gt; in CGP. Here, we’re leveraging &lt;strong&gt;type-level programming&lt;&#x2F;strong&gt; not just within CGP’s core component abstractions like &lt;code&gt;DelegateComponent&lt;&#x2F;code&gt;, but also as a tool for &lt;em&gt;programmatically defining component wiring&lt;&#x2F;em&gt; through the use of generic parameters and trait constraints.&lt;&#x2F;p&gt;
&lt;p&gt;This highlights a deeper design philosophy behind CGP: rather than inventing a new meta-language or macro system, CGP embraces Rust’s existing type system and trait machinery as the foundation for composability and abstraction. Type-level programming in CGP isn’t an escape hatch — it is the underlying mechanism that &lt;em&gt;makes escape hatches unnecessary&lt;&#x2F;em&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Some readers may find the phrase &quot;type-level programming&quot; intimidating, especially if they associate it with obscure or overly abstract code. But consider the alternatives: in many dynamic languages like Ruby, Python, or JavaScript, metaprogramming is accomplished through bespoke syntax, reflection, or runtime patching — approaches that can be powerful but often come with poor tooling, fragile semantics, and hard-to-debug behavior.&lt;&#x2F;p&gt;
&lt;p&gt;In contrast, type-level programming offers a principled and well-typed foundation for metaprogramming. Constraints are checked at compile time, tooling support remains robust, and the abstractions remain composable. Instead of inventing ad hoc metaprogramming constructs, CGP relies on the well-established theory and practice of type-level computation.&lt;&#x2F;p&gt;
&lt;p&gt;By doing so, CGP achieves a rare combination of power and predictability. Developers who embrace this pattern gain access to highly expressive abstractions, while staying within the familiar boundaries of Rust&#x27;s type system.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;conclusion&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#conclusion&quot; aria-label=&quot;Anchor link for: conclusion&quot;&gt;Conclusion&lt;&#x2F;a&gt;&lt;&#x2F;h1&gt;
&lt;p&gt;By this point, I hope you have a clearer understanding of how CGP supports extensible records. If you are interested in exploring the implementation further, take a look at the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;contextgeneric&#x2F;cgp&quot;&gt;GitHub repository&lt;&#x2F;a&gt;, especially the &lt;code&gt;cgp-field&lt;&#x2F;code&gt; and &lt;code&gt;cgp-dispatch&lt;&#x2F;code&gt; crates, which contain the full source code.&lt;&#x2F;p&gt;
&lt;p&gt;With partial records and field traits such as &lt;code&gt;HasField&lt;&#x2F;code&gt;, &lt;code&gt;BuildField&lt;&#x2F;code&gt;, and &lt;code&gt;TakeField&lt;&#x2F;code&gt;, CGP enables powerful generic operations like &lt;code&gt;BuildFrom&lt;&#x2F;code&gt;, which allows one struct to be merged into another seamlessly. These building blocks form the foundation for more advanced compositional patterns.&lt;&#x2F;p&gt;
&lt;p&gt;To implement the extensible builder pattern, we introduced the &lt;code&gt;BuildWithHandlers&lt;&#x2F;code&gt; dispatcher. This component composes multiple builder handlers and merges their outputs using a clean and predictable build pipeline, constructed with &lt;code&gt;PipeHandlers&lt;&#x2F;code&gt;. The simplicity arises from a system where modularity is built into the core design, rather than added as an afterthought.&lt;&#x2F;p&gt;
&lt;p&gt;On top of this, we implemented the high-level &lt;code&gt;BuildAndMergeOutputs&lt;&#x2F;code&gt; dispatcher by defining a conditional delegation to &lt;code&gt;BuildWithHandlers&lt;&#x2F;code&gt;, after first wrapping each handler using the &lt;code&gt;BuildAndMerge&lt;&#x2F;code&gt; adapter. This design preserves composability while allowing for customized construction logic.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;future-extensions&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#future-extensions&quot; aria-label=&quot;Anchor link for: future-extensions&quot;&gt;Future Extensions&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Because extensible records and builders are implemented modularly, it is easy to extend the system further without rewriting the core. For instance, the current builder pattern requires the source struct to match the target struct exactly, but we may want to allow certain fields to be &lt;strong&gt;dropped&lt;&#x2F;strong&gt; rather than merged.&lt;&#x2F;p&gt;
&lt;p&gt;We might also want to support &lt;strong&gt;overriding&lt;&#x2F;strong&gt; existing fields in a partial record when the same field appears in multiple sources. Additionally, it would be useful to finalize a partial record by filling in any missing fields with &lt;strong&gt;default values&lt;&#x2F;strong&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;These enhancements are already within reach, and we plan to support them in future versions of CGP. Even if they are not included directly in the library, the existing abstractions make it easy for others to implement them independently.&lt;&#x2F;p&gt;
&lt;p&gt;Thanks to the expressive power of Rust’s type system and the composability of type-level programming, these extensions can be implemented in a way that is both straightforward and correct by construction. They remain completely optional and do not introduce additional complexity to the core logic presented here.&lt;&#x2F;p&gt;
&lt;p&gt;This level of flexibility would be difficult to achieve with more ad hoc approaches, such as macros or code generation, which often require the entire logic and all possible extensions to be baked into a single monolithic system. That leads to unnecessary coupling and limits customizability.&lt;&#x2F;p&gt;
&lt;p&gt;If you&#x27;re still unsure how all of this comes together, a future blog post will walk through the implementation of these extensions in detail to show exactly how they work.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;next-part&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#next-part&quot; aria-label=&quot;Anchor link for: next-part&quot;&gt;Next Part&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;In the final &lt;a href=&quot;&#x2F;blog&#x2F;extensible-datatypes-part-4&quot;&gt;Part 4 of this series, &lt;strong&gt;Implementing Extensible Variants&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;, we will follow a similar path to explore how CGP implements extensible variants. Keep in mind the concepts we covered for extensible records — you may be surprised to discover just how much of the same logic carries over, despite the differences between records and variants.&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>Programming Extensible Data Types in Rust with CGP - Part 2: Modular Interpreters and Extensible Visitors</title>
        <published>2025-07-09T00:00:00+00:00</published>
        <updated>2025-07-09T00:00:00+00:00</updated>
        
        <author>
          <name>
            Soares Chen
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://www.contextgeneric.dev/blog/extensible-datatypes-part-2/"/>
        <id>https://www.contextgeneric.dev/blog/extensible-datatypes-part-2/</id>
        
        <content type="html" xml:base="https://www.contextgeneric.dev/blog/extensible-datatypes-part-2/">&lt;p&gt;Discuss on &lt;a href=&quot;https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;rust&#x2F;comments&#x2F;1lvgyre&#x2F;building_modular_interpreters_and_visitors_in&#x2F;&quot;&gt;Reddit&lt;&#x2F;a&gt;, &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;orgs&#x2F;contextgeneric&#x2F;discussions&#x2F;13&quot;&gt;GitHub&lt;&#x2F;a&gt; or &lt;a href=&quot;https:&#x2F;&#x2F;discord.gg&#x2F;Hgk3rCw6pQ&quot;&gt;Discord&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;recap&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#recap&quot; aria-label=&quot;Anchor link for: recap&quot;&gt;Recap&lt;&#x2F;a&gt;&lt;&#x2F;h1&gt;
&lt;p&gt;This is the &lt;strong&gt;second&lt;&#x2F;strong&gt; part of the blog series on &lt;strong&gt;Programming Extensible Data Types in Rust with CGP&lt;&#x2F;strong&gt;. You can read the &lt;a href=&quot;&#x2F;blog&#x2F;extensible-datatypes-part-1&quot;&gt;first part here&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;As a recap, we have covered the new release of &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;contextgeneric&#x2F;cgp&#x2F;releases&#x2F;tag&#x2F;v0.4.2&quot;&gt;&lt;strong&gt;CGP v0.4.2&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt; which now supports the use of &lt;strong&gt;extensible records and variants&lt;&#x2F;strong&gt;, allowing developers to write code that operates on &lt;em&gt;any struct containing specific fields&lt;&#x2F;em&gt; or &lt;em&gt;any enum containing specific variants&lt;&#x2F;em&gt;, without needing their concrete definition.&lt;&#x2F;p&gt;
&lt;p&gt;In the first part of the series, &lt;a href=&quot;&#x2F;blog&#x2F;extensible-datatypes-part-1&quot;&gt;&lt;strong&gt;Modular App Construction and Extensible Builders&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;, we demonstrated an example use of the &lt;strong&gt;extensible builder pattern&lt;&#x2F;strong&gt;, which uses &lt;strong&gt;extensible records&lt;&#x2F;strong&gt; to support modular construction of an application context.&lt;&#x2F;p&gt;
&lt;p&gt;In this second part of the series, we will explore the use of &lt;strong&gt;extensible variants&lt;&#x2F;strong&gt;, by examining how it can be used in an &lt;strong&gt;extensible visitor pattern&lt;&#x2F;strong&gt; to build a modular interpreter for a toy math expression language.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;series-overview&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#series-overview&quot; aria-label=&quot;Anchor link for: series-overview&quot;&gt;Series Overview&lt;&#x2F;a&gt;&lt;&#x2F;h1&gt;
&lt;p&gt;&lt;a href=&quot;&#x2F;blog&#x2F;extensible-datatypes-part-1&quot;&gt;&lt;strong&gt;Part 1: Modular App Construction and Extensible Builders&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt; – In this introductory part, we present a high-level overview of the key features enabled by extensible data types. We then dive into a hands-on demonstration showing how extensible records can be used to build and compose modular builders for real-world applications.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Part 2: Modular Interpreters and Extensible Visitors&lt;&#x2F;strong&gt; (this post) – This part continues the demonstration by introducing extensible variants. We use them to address the &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Expression_problem&quot;&gt;&lt;strong&gt;expression problem&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;, implementing a set of reusable interpreter components for a small toy language.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a href=&quot;&#x2F;blog&#x2F;extensible-datatypes-part-3&quot;&gt;&lt;strong&gt;Part 3: Implementing Extensible Records&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt; – Here, we walk through the internal mechanics behind extensible records. We show how CGP supports the modular builder pattern demonstrated in Part 1 through its underlying type and trait machinery.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a href=&quot;&#x2F;blog&#x2F;extensible-datatypes-part-4&quot;&gt;&lt;strong&gt;Part 4: Implementing Extensible Variants&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt; – This part mirrors Part 3, but for extensible variants. We examine how extensible variants are implemented, and compare the differences and similarities between extensible records and variants.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;extending-the-visitor-pattern&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#extending-the-visitor-pattern&quot; aria-label=&quot;Anchor link for: extending-the-visitor-pattern&quot;&gt;Extending the Visitor Pattern&lt;&#x2F;a&gt;&lt;&#x2F;h1&gt;
&lt;p&gt;Earlier, we explored how CGP uses the extensible builder pattern to enable modular construction of context structs. In this article, we will see how a similar approach can be applied to context &lt;strong&gt;enums&lt;&#x2F;strong&gt;, allowing each variant to be destructured and handled by a flexible, composable set of handlers.&lt;&#x2F;p&gt;
&lt;p&gt;In Rust and many object-oriented languages, this pattern is commonly referred to as the &lt;a href=&quot;https:&#x2F;&#x2F;rust-unofficial.github.io&#x2F;patterns&#x2F;patterns&#x2F;behavioural&#x2F;visitor.html&quot;&gt;&lt;strong&gt;visitor pattern&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;. However, Rust’s powerful &lt;code&gt;enum&lt;&#x2F;code&gt; and &lt;code&gt;match&lt;&#x2F;code&gt; features often reduce the need for the visitor pattern, especially when the concrete enum type is known. In such cases, developers can simply use &lt;code&gt;match&lt;&#x2F;code&gt; expressions to handle each variant explicitly and concisely.&lt;&#x2F;p&gt;
&lt;p&gt;Despite this, the visitor pattern remains useful in situations where the concrete enum type is &lt;strong&gt;unknown&lt;&#x2F;strong&gt; or abstracted away. This is especially true in libraries like &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;serde&#x2F;latest&#x2F;serde&#x2F;de&#x2F;trait.Visitor.html&quot;&gt;&lt;code&gt;serde&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; and &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;syn&#x2F;latest&#x2F;syn&#x2F;visit&#x2F;trait.Visit.html&quot;&gt;&lt;code&gt;syn&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;, where visitors are used to traverse abstract syntax trees or serialization payloads without tying the implementation to a specific format or structure. For instance, in &lt;code&gt;serde&lt;&#x2F;code&gt;, deserialization is driven by a visitor provided by the target type, which walks through structures like JSON or TOML without coupling the deserializer to any specific data format.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;limitations-of-the-traditional-visitor-pattern&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#limitations-of-the-traditional-visitor-pattern&quot; aria-label=&quot;Anchor link for: limitations-of-the-traditional-visitor-pattern&quot;&gt;Limitations of the Traditional Visitor Pattern&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;While the visitor pattern is useful, it suffers from a major drawback: it is inherently &lt;strong&gt;closed for extension&lt;&#x2F;strong&gt;. All possible variants and visitable types must be declared upfront in the visitor interface, and it is challenging to add or remove variants later without breaking existing implementations.&lt;&#x2F;p&gt;
&lt;p&gt;For example, consider the &lt;code&gt;Visitor&lt;&#x2F;code&gt; trait in &lt;code&gt;serde&lt;&#x2F;code&gt;, which defines methods for visiting a fixed set of primitive types — up to 128-bit integers. If a developer wants to deserialize a type that contains a &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;primitive-types&#x2F;latest&#x2F;primitive_types&#x2F;struct.U256.html&quot;&gt;&lt;code&gt;U256&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; value, there is no way to extend the &lt;code&gt;Visitor&lt;&#x2F;code&gt; trait to support native 256-bit integers. Likewise, if someone builds a new serialization format that introduces support for such a type, it cannot cleanly integrate with &lt;code&gt;serde&lt;&#x2F;code&gt; because the trait cannot be expanded.&lt;&#x2F;p&gt;
&lt;p&gt;To work around this, &lt;code&gt;serde&lt;&#x2F;code&gt; includes a broad set of 26 visitor methods in its core &lt;code&gt;Visitor&lt;&#x2F;code&gt; trait to accommodate a wide range of cases. However, this introduces the opposite problem: when a serialization format &lt;strong&gt;does not&lt;&#x2F;strong&gt; support a specific visitor method, the only option is to return a &lt;strong&gt;runtime error&lt;&#x2F;strong&gt;. There is no way to signal at compile time that a type is incompatible with the format, even if it formally implements &lt;code&gt;Serialize&lt;&#x2F;code&gt; or &lt;code&gt;Deserialize&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;This mismatch becomes especially noticeable when using compact formats like &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;postcard&quot;&gt;&lt;code&gt;postcard&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; or &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;bincode&quot;&gt;&lt;code&gt;bincode&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;, which support only a small subset of types compared to JSON. These libraries accept any type implementing &lt;code&gt;Deserialize&lt;&#x2F;code&gt;, but compatibility is only verified at runtime — leaving users to discover format mismatches through runtime errors instead of compile-time errors.&lt;&#x2F;p&gt;
&lt;p&gt;In short, the traditional visitor pattern tends to be either too &lt;strong&gt;restrictive&lt;&#x2F;strong&gt; (by enforcing a closed set of operations) or too &lt;strong&gt;permissive&lt;&#x2F;strong&gt; (by relying on runtime errors to reject unsupported operations). What’s needed is a more flexible, composable alternative — one that allows both sides (visitor and visitee) to express precise requirements at compile time.&lt;&#x2F;p&gt;
&lt;p&gt;This is exactly the problem that the &lt;strong&gt;extensible visitor pattern&lt;&#x2F;strong&gt; in CGP aims to solve. It enables open-ended, modular visitors that preserve &lt;strong&gt;type safety&lt;&#x2F;strong&gt; and &lt;strong&gt;extensibility&lt;&#x2F;strong&gt;, without the pitfalls of runtime errors or rigid interfaces.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-expression-problem&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-expression-problem&quot; aria-label=&quot;Anchor link for: the-expression-problem&quot;&gt;The Expression Problem&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;While it’s theoretically possible to replace &lt;code&gt;serde&lt;&#x2F;code&gt;’s visitor pattern with CGP’s extensible alternative, doing so would require significant refactoring and is outside the scope of this post. Instead, we’ll explore a &lt;em&gt;simpler&lt;&#x2F;em&gt; but well-known challenge that illustrates the same limitations: the &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Expression_problem&quot;&gt;&lt;strong&gt;expression problem&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Suppose we want to implement an interpreter for a toy arithmetic language in Rust. This language might support basic math expressions like &lt;code&gt;1 + (2 * 3)&lt;&#x2F;code&gt;. A typical way to represent such a language is with an enum like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub enum &lt;&#x2F;span&gt;&lt;span&gt;MathExpr {
&lt;&#x2F;span&gt;&lt;span&gt;    Literal(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u64&lt;&#x2F;span&gt;&lt;span&gt;),
&lt;&#x2F;span&gt;&lt;span&gt;    Plus(Box&amp;lt;MathExpr&amp;gt;, Box&amp;lt;MathExpr&amp;gt;),
&lt;&#x2F;span&gt;&lt;span&gt;    Times(Box&amp;lt;MathExpr&amp;gt;, Box&amp;lt;MathExpr&amp;gt;),
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Here, &lt;code&gt;MathExpr&lt;&#x2F;code&gt; represents arithmetic expressions. The &lt;code&gt;Plus&lt;&#x2F;code&gt; and &lt;code&gt;Times&lt;&#x2F;code&gt; variants contain boxed sub-expressions, and &lt;code&gt;Literal&lt;&#x2F;code&gt; holds an integer value. The use of &lt;code&gt;Box&lt;&#x2F;code&gt; is necessary due to Rust’s size constraints for recursive data structures.&lt;&#x2F;p&gt;
&lt;p&gt;To evaluate these expressions, we can implement a straightforward &lt;code&gt;eval&lt;&#x2F;code&gt; function:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;eval(expr: MathExpr) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u64 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;match&lt;&#x2F;span&gt;&lt;span&gt; expr {
&lt;&#x2F;span&gt;&lt;span&gt;        MathExpr::Literal(value) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt; value,
&lt;&#x2F;span&gt;&lt;span&gt;        MathExpr::Plus(a, b) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;eval(*a) + eval(*b),
&lt;&#x2F;span&gt;&lt;span&gt;        MathExpr::Times(a, b) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;eval(*a) * eval(*b),
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This works well for small examples. But real-world interpreters quickly grow in complexity. Each evaluation case might span dozens — or hundreds — of lines of code. Additionally, the enum itself might have many more variants. For example, &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;syn&#x2F;latest&#x2F;syn&#x2F;enum.Expr.html&quot;&gt;&lt;code&gt;syn::Expr&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;, a real-world expression type for Rust, defines over &lt;em&gt;40 variants&lt;&#x2F;em&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Let’s assume our toy &lt;code&gt;MathExpr&lt;&#x2F;code&gt; is similarly complex. Now imagine that alongside &lt;code&gt;eval&lt;&#x2F;code&gt;, we also want to define other operations, like pretty-printing:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;expr_to_string(expr: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;MathExpr) -&amp;gt; String {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;match&lt;&#x2F;span&gt;&lt;span&gt; expr {
&lt;&#x2F;span&gt;&lt;span&gt;        MathExpr::Literal(value) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt; value.to_string(),
&lt;&#x2F;span&gt;&lt;span&gt;        MathExpr::Plus(a, b) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;format!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt; + &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;)&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, expr_to_string(a), expr_to_string(b)),
&lt;&#x2F;span&gt;&lt;span&gt;        MathExpr::Times(a, b) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;format!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt; * &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;)&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, expr_to_string(a), expr_to_string(b)),
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Here lies the crux of the expression problem: as the language evolves, we frequently need to &lt;em&gt;add&lt;&#x2F;em&gt; new expression variants or &lt;em&gt;remove&lt;&#x2F;em&gt; old ones. But any modification to the &lt;code&gt;MathExpr&lt;&#x2F;code&gt; enum forces us to update &lt;em&gt;all&lt;&#x2F;em&gt; pattern-matching functions like &lt;code&gt;eval&lt;&#x2F;code&gt;, &lt;code&gt;expr_to_string&lt;&#x2F;code&gt;, and others. The enum becomes &lt;strong&gt;tightly coupled&lt;&#x2F;strong&gt; to every function that consumes it.&lt;&#x2F;p&gt;
&lt;p&gt;Worse, this coupling is not easy to break. The recursive nature of &lt;code&gt;MathExpr&lt;&#x2F;code&gt; — where variants like &lt;code&gt;Plus&lt;&#x2F;code&gt; contain other &lt;code&gt;MathExpr&lt;&#x2F;code&gt; values — means even modular helper functions (e.g., &lt;code&gt;eval_plus&lt;&#x2F;code&gt;) must still operate on &lt;code&gt;MathExpr&lt;&#x2F;code&gt;, perpetuating the tight dependency.&lt;&#x2F;p&gt;
&lt;p&gt;This isn’t a problem unique to interpreters. Many recursive data structures — like JSON &lt;code&gt;Value&lt;&#x2F;code&gt; types — suffer from similar issues. A JSON object may contain maps of nested &lt;code&gt;Value&lt;&#x2F;code&gt;s, making any function over the type deeply tied to its structure.&lt;&#x2F;p&gt;
&lt;p&gt;Because of this, extending or experimenting with the enum often becomes burdensome. If the type is part of an upstream crate, users may need to submit a &lt;strong&gt;pull request&lt;&#x2F;strong&gt; just to add a variant. And if the maintainer &lt;em&gt;declines&lt;&#x2F;em&gt;, downstream users may be forced to &lt;strong&gt;fork&lt;&#x2F;strong&gt; the crate just to gain the flexibility they need.&lt;&#x2F;p&gt;
&lt;p&gt;In the next section, we’ll explore how CGP&#x27;s extensible visitor pattern addresses this problem — by &lt;strong&gt;decoupling&lt;&#x2F;strong&gt; the implementation of each variant from the concrete enum definition.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;evaluator-computer&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#evaluator-computer&quot; aria-label=&quot;Anchor link for: evaluator-computer&quot;&gt;Evaluator Computer&lt;&#x2F;a&gt;&lt;&#x2F;h1&gt;
&lt;p&gt;To demonstrate how CGP enables extensible and decoupled evaluation logic, we will now walk through how to implement a small part of the &lt;code&gt;eval&lt;&#x2F;code&gt; function — specifically, the logic for handling the &lt;code&gt;Plus&lt;&#x2F;code&gt; operator. Rather than tying ourselves to a fixed &lt;code&gt;MathExpr&lt;&#x2F;code&gt; enum, we begin by defining &lt;code&gt;Plus&lt;&#x2F;code&gt; as an independent struct:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;Plus&amp;lt;Expr&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;left: Box&amp;lt;Expr&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;right: Box&amp;lt;Expr&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In this definition, &lt;code&gt;Plus&lt;&#x2F;code&gt; is no longer a variant of a hardcoded enum. Instead, it is a &lt;em&gt;generic&lt;&#x2F;em&gt; data structure that takes an &lt;code&gt;Expr&lt;&#x2F;code&gt; type parameter. This parameter represents the broader expression type and allows &lt;code&gt;Plus&lt;&#x2F;code&gt; to be reused in many different expression trees. The &lt;code&gt;left&lt;&#x2F;code&gt; and &lt;code&gt;right&lt;&#x2F;code&gt; operands are wrapped in &lt;code&gt;Box&lt;&#x2F;code&gt; to support recursive structures while still satisfying Rust’s size requirements later on.&lt;&#x2F;p&gt;
&lt;p&gt;To actually evaluate such a sub-expression, CGP introduces the concept of a &lt;strong&gt;Computer&lt;&#x2F;strong&gt; — a CGP component designed for pure computation. It is defined as follows:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_component(Computer)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;CanCompute&amp;lt;Code, Input&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Output&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;compute(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self, _code: PhantomData&amp;lt;Code&amp;gt;, input: Input) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;Output;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This trait behaves similarly to the &lt;code&gt;Handler&lt;&#x2F;code&gt; trait introduced earlier, but with one key distinction: &lt;code&gt;compute&lt;&#x2F;code&gt; is a &lt;em&gt;synchronous&lt;&#x2F;em&gt; function and does not return a &lt;code&gt;Result&lt;&#x2F;code&gt;. It is called a &lt;em&gt;computer&lt;&#x2F;em&gt; because it embodies a pure, deterministic &lt;em&gt;computation&lt;&#x2F;em&gt; that transforms input into output.&lt;&#x2F;p&gt;
&lt;p&gt;The &lt;code&gt;Computer&lt;&#x2F;code&gt; trait serves as the foundation for extensible evaluation. It abstracts the idea of computation away from any specific expression type or evaluation strategy. Using this abstraction, we can implement evaluation logic for each sub-expression in isolation. For example, here is how we define a provider for evaluating the &lt;code&gt;Plus&lt;&#x2F;code&gt; struct:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_new_provider]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;Context, Code, MathExpr, Output&amp;gt; Computer&amp;lt;Context, Code, Plus&amp;lt;MathExpr&amp;gt;&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;EvalAdd
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;    Context: CanCompute&amp;lt;Code, MathExpr, Output = Output&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    Output: Add&amp;lt;Output = Output&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Output &lt;&#x2F;span&gt;&lt;span&gt;= Output;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;compute(
&lt;&#x2F;span&gt;&lt;span&gt;        context: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;Context,
&lt;&#x2F;span&gt;&lt;span&gt;        code: PhantomData&amp;lt;Code&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        Plus { left, right }: Plus&amp;lt;MathExpr&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    ) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;Output {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; output_a = context.compute(code, *left);
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; output_b = context.compute(code, *right);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        output_a + output_b
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This implementation defines &lt;code&gt;EvalAdd&lt;&#x2F;code&gt; as a &lt;code&gt;Computer&lt;&#x2F;code&gt; with &lt;code&gt;Plus&amp;lt;MathExpr&amp;gt;&lt;&#x2F;code&gt; as input. It works generically over any &lt;code&gt;Context&lt;&#x2F;code&gt;, &lt;code&gt;Code&lt;&#x2F;code&gt;, and &lt;code&gt;MathExpr&lt;&#x2F;code&gt; type, as long as the context knows how to compute &lt;code&gt;MathExpr&lt;&#x2F;code&gt; and the resulting output type supports the &lt;code&gt;Add&lt;&#x2F;code&gt; trait. In other words, the context must be able to evaluate each operand, and the results must be addable.&lt;&#x2F;p&gt;
&lt;p&gt;By using &lt;code&gt;context.compute(...)&lt;&#x2F;code&gt; recursively on the left and right operands, we evaluate each sub-expression and then add the results together. This setup allows us to write clean, modular logic that does not assume anything about the shape of the expression tree or the numeric type being used.&lt;&#x2F;p&gt;
&lt;p&gt;The same approach applies to other arithmetic operations. For example, we can implement a provider for multiplication as follows:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;Times&amp;lt;Expr&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;left: Box&amp;lt;Expr&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;right: Box&amp;lt;Expr&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[cgp_new_provider]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;Context, Code, MathExpr, Output&amp;gt; Computer&amp;lt;Context, Code, Times&amp;lt;MathExpr&amp;gt;&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;EvalMultiply
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;    Context: CanCompute&amp;lt;Code, MathExpr, Output = Output&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    Output: Mul&amp;lt;Output = Output&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Output &lt;&#x2F;span&gt;&lt;span&gt;= Output;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;compute(
&lt;&#x2F;span&gt;&lt;span&gt;        context: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;Context,
&lt;&#x2F;span&gt;&lt;span&gt;        code: PhantomData&amp;lt;Code&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        Times { left, right }: Times&amp;lt;MathExpr&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    ) -&amp;gt; Output {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; output_a = context.compute(code, *left);
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; output_b = context.compute(code, *right);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        output_a * output_b
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Here, we follow the exact same structure. The only difference is that we require the output type to implement &lt;code&gt;Mul&lt;&#x2F;code&gt; instead of &lt;code&gt;Add&lt;&#x2F;code&gt;, and we use the &lt;code&gt;*&lt;&#x2F;code&gt; operator to combine the results.&lt;&#x2F;p&gt;
&lt;p&gt;Finally, we handle literals using the following straightforward implementation:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;Literal&amp;lt;T&amp;gt;(pub T);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[cgp_new_provider]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;Context, Code, T&amp;gt; Computer&amp;lt;Context, Code, Literal&amp;lt;T&amp;gt;&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;EvalLiteral {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Output &lt;&#x2F;span&gt;&lt;span&gt;= T;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;compute(_context: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;Context, _code: PhantomData&amp;lt;Code&amp;gt;, Literal(value): Literal&amp;lt;T&amp;gt;) -&amp;gt; T {
&lt;&#x2F;span&gt;&lt;span&gt;        value
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;EvalLiteral&lt;&#x2F;code&gt; provider simply returns the inner value. It doesn’t depend on any context or recursive evaluation, making it the simplest form of a computer.&lt;&#x2F;p&gt;
&lt;p&gt;What’s remarkable about this setup is how each of the providers — &lt;code&gt;EvalAdd&lt;&#x2F;code&gt;, &lt;code&gt;EvalMultiply&lt;&#x2F;code&gt;, and &lt;code&gt;EvalLiteral&lt;&#x2F;code&gt; — is completely &lt;strong&gt;decoupled&lt;&#x2F;strong&gt; from both each other and the concrete expression type. These components can live in separate crates or modules and still be composed together to form a complete evaluator.&lt;&#x2F;p&gt;
&lt;p&gt;This modularity is precisely the power that CGP brings to the table. Instead of forcing every part of your evaluator into a rigid, monolithic structure, you can build each piece independently and combine them later. The result is not only cleaner and more maintainable code, but also an evaluation engine that is fully open for extension — without giving up on compile-time guarantees.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;evaluating-concrete-expressions&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#evaluating-concrete-expressions&quot; aria-label=&quot;Anchor link for: evaluating-concrete-expressions&quot;&gt;Evaluating Concrete Expressions&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;With our evaluation logic defined for individual expression types like &lt;code&gt;Plus&lt;&#x2F;code&gt;, &lt;code&gt;Times&lt;&#x2F;code&gt;, and &lt;code&gt;Literal&lt;&#x2F;code&gt;, the next step is to bring everything together into a fully functional evaluator. To do this, we first define a concrete expression type named &lt;code&gt;MathExpr&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[derive(Debug, HasFields, FromVariant, ExtractField)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub enum &lt;&#x2F;span&gt;&lt;span&gt;MathExpr {
&lt;&#x2F;span&gt;&lt;span&gt;    Plus(Plus&amp;lt;MathExpr&amp;gt;),
&lt;&#x2F;span&gt;&lt;span&gt;    Times(Times&amp;lt;MathExpr&amp;gt;),
&lt;&#x2F;span&gt;&lt;span&gt;    Literal(Literal&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u64&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;),
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Notice that instead of embedding the structure of each expression variant directly inside the enum, we define each variant to wrap one of the standalone structs we previously created. This design is intentional. By keeping each sub-expression — such as &lt;code&gt;Plus&lt;&#x2F;code&gt; and &lt;code&gt;Times&lt;&#x2F;code&gt; — as its own modular type, we can reuse and compose them in more flexible ways. To complete the recursive structure, we instantiate the generic type parameter &lt;code&gt;MathExpr&lt;&#x2F;code&gt; inside each sub-expression, allowing the expression tree to contain arbitrarily nested expressions. For the &lt;code&gt;Literal&lt;&#x2F;code&gt; case, we keep things simple by hardcoding the value type to &lt;code&gt;u64&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Now that we have our enum, we need to define the context in which evaluation will happen. In CGP, this is done using a &lt;code&gt;#[cgp_context]&lt;&#x2F;code&gt; declaration:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_context]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;Interpreter;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This &lt;code&gt;Interpreter&lt;&#x2F;code&gt; struct will serve as the central context object for our evaluator. In this particular example, we do not require the context to hold any runtime data, so the struct is left empty. Its only purpose is to act as a compile-time container that wires together the correct provider implementations.&lt;&#x2F;p&gt;
&lt;p&gt;The actual wiring is handled through CGP’s powerful delegation system, which allows us to map input types to their corresponding computation logic. Here&#x27;s how we set it up:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;delegate_components! {
&lt;&#x2F;span&gt;&lt;span&gt;    InterpreterComponents {
&lt;&#x2F;span&gt;&lt;span&gt;        ComputerComponent:
&lt;&#x2F;span&gt;&lt;span&gt;            UseInputDelegate&amp;lt;
&lt;&#x2F;span&gt;&lt;span&gt;                new EvalComponents &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;                    Expr: DispatchEval,
&lt;&#x2F;span&gt;&lt;span&gt;                    Plus&amp;lt;MathExpr&amp;gt;: EvalAdd,
&lt;&#x2F;span&gt;&lt;span&gt;                    Times&amp;lt;MathExpr&amp;gt;: EvalMultiply,
&lt;&#x2F;span&gt;&lt;span&gt;                    Literal&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u64&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;: EvalLiteral,
&lt;&#x2F;span&gt;&lt;span&gt;                }
&lt;&#x2F;span&gt;&lt;span&gt;            &amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In this block, we define the &lt;code&gt;InterpreterComponents&lt;&#x2F;code&gt; wiring configuration, which tells CGP how to resolve the &lt;code&gt;Computer&lt;&#x2F;code&gt; trait for each expression type. At the heart of this configuration is &lt;code&gt;UseInputDelegate&lt;&#x2F;code&gt;, a &lt;a href=&quot;&#x2F;blog&#x2F;hypershell-release&#x2F;#input-based-dispatch&quot;&gt;&lt;strong&gt;generic dispatcher&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt; that automatically selects the correct provider based on the input type at compile time.&lt;&#x2F;p&gt;
&lt;p&gt;This dispatcher operates over the inner &lt;code&gt;EvalComponents&lt;&#x2F;code&gt; table, which we create on the fly using the &lt;code&gt;new&lt;&#x2F;code&gt; keyword. This &lt;code&gt;EvalComponents&lt;&#x2F;code&gt; struct maps each expression type to its associated computation provider:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;MathExpr&lt;&#x2F;code&gt; is mapped to &lt;code&gt;DispatchEval&lt;&#x2F;code&gt;, which acts as a dispatcher that dispatches to one of the sub-expression types based on the variant.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;Plus&amp;lt;MathExpr&amp;gt;&lt;&#x2F;code&gt; is evaluated using &lt;code&gt;EvalAdd&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;Times&amp;lt;MathExpr&amp;gt;&lt;&#x2F;code&gt; is evaluated using &lt;code&gt;EvalMultiply&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;Literal&amp;lt;u64&amp;gt;&lt;&#x2F;code&gt; is handled by &lt;code&gt;EvalLiteral&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Because &lt;code&gt;UseInputDelegate&lt;&#x2F;code&gt; operates at the type level, the entire dispatch process is fully type-safe and resolved at compile time. There is no need for &lt;code&gt;match&lt;&#x2F;code&gt; statements, no runtime type checks, and no boilerplate glue code. The trait system simply composes itself from the parts we’ve defined.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;dispatching-eval&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#dispatching-eval&quot; aria-label=&quot;Anchor link for: dispatching-eval&quot;&gt;Dispatching Eval&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;With the components for evaluating individual sub-expressions in place, we now turn our attention to the final piece of the puzzle: evaluating the main &lt;code&gt;MathExpr&lt;&#x2F;code&gt; enum itself. To accomplish this, we delegate the &lt;code&gt;MathExpr&lt;&#x2F;code&gt; type to a special provider named &lt;code&gt;DispatchEval&lt;&#x2F;code&gt;, which is defined alongside the &lt;code&gt;Interpreter&lt;&#x2F;code&gt; context like so:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_new_provider]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;Code&amp;gt; Computer&amp;lt;Interpreter, Code, MathExpr&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;DispatchEval {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Output &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u64&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;compute(context: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;Interpreter, code: PhantomData&amp;lt;Code&amp;gt;, expr: MathExpr) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;Output {
&lt;&#x2F;span&gt;&lt;span&gt;        &amp;lt;MatchWithValueHandlers&amp;gt;::compute(context, code, expr)
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Here, &lt;code&gt;DispatchEval&lt;&#x2F;code&gt; is implemented as a &lt;em&gt;context-specific&lt;&#x2F;em&gt; provider. That means it only applies when we are evaluating expressions in the &lt;code&gt;Interpreter&lt;&#x2F;code&gt; context, and it handles the concrete &lt;code&gt;MathExpr&lt;&#x2F;code&gt; enum as input. Rather than directly writing out how each variant of the enum is evaluated, we delegate that responsibility to a special &lt;strong&gt;visitor dispatcher&lt;&#x2F;strong&gt; called &lt;code&gt;MatchWithValueHandlers&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;This dispatcher is one of the key tools provided by CGP. It automatically maps each enum variant to the appropriate computation provider we registered earlier in &lt;code&gt;EvalComponents&lt;&#x2F;code&gt;. In effect, &lt;code&gt;MatchWithValueHandlers&lt;&#x2F;code&gt; performs dispatch on the matching of variants at compile time. The implementation of &lt;code&gt;DispatchEval&lt;&#x2F;code&gt; is simply a wrapper around this dispatcher, but that wrapper plays a crucial role.&lt;&#x2F;p&gt;
&lt;p&gt;So why do we need this wrapper in the first place? It comes down to a subtle limitation in Rust’s trait resolution system. If we try to directly wire the &lt;code&gt;Computer&lt;&#x2F;code&gt; handler for &lt;code&gt;MathExpr&lt;&#x2F;code&gt; to &lt;code&gt;MatchWithValueHandlers&lt;&#x2F;code&gt;, the compiler runs into a cyclic dependency: to implement the trait, it needs to evaluate the variant-specific providers like &lt;code&gt;EvalAdd&lt;&#x2F;code&gt;, which themselves rely on &lt;code&gt;MatchWithValueHandlers&lt;&#x2F;code&gt;. The result is a cryptic “overflowing requirements” error.&lt;&#x2F;p&gt;
&lt;p&gt;By inserting this wrapper layer with &lt;code&gt;DispatchEval&lt;&#x2F;code&gt;, we sidestep that issue. Rust is able to mark the trait as implemented before diving into the body of the method, effectively breaking the cycle.&lt;&#x2F;p&gt;
&lt;p&gt;To understand what &lt;code&gt;MatchWithValueHandlers&lt;&#x2F;code&gt; is doing under the hood, imagine manually writing out the dispatch logic like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_new_provider]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;Code&amp;gt; Computer&amp;lt;Interpreter, Code, MathExpr&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;DispatchEval {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Output &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u64&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;compute(context: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;Interpreter, code: PhantomData&amp;lt;Code&amp;gt;, expr: MathExpr) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;Output {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;match&lt;&#x2F;span&gt;&lt;span&gt; expr {
&lt;&#x2F;span&gt;&lt;span&gt;            Expr::Plus(expr) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt; context.compute(code, expr),
&lt;&#x2F;span&gt;&lt;span&gt;            Expr::Times(expr) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt; context.compute(code, expr),
&lt;&#x2F;span&gt;&lt;span&gt;            Expr::Literal(expr) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt; context.compute(code, expr),
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This is straightforward for a small enum like ours. But once your enum grows beyond a few variants — as is the case with something like &lt;code&gt;syn::Expr&lt;&#x2F;code&gt;, which contains over 40 — you quickly run into repetition, verbosity, and maintenance pain.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;MatchWithValueHandlers&lt;&#x2F;code&gt; avoids all that by performing this logic &lt;em&gt;generically&lt;&#x2F;em&gt;. It doesn&#x27;t rely on macros or hardcoded pattern matching. Instead, it works entirely through traits and type-level programming. That means the same dispatcher can be reused for any enum type that satisfies the required constraints, without knowing anything about the actual enum variants ahead of time.&lt;&#x2F;p&gt;
&lt;p&gt;This is a significant benefit over traditional macro-based approaches, which are more difficult to reason about, harder to debug, and often tightly coupled to specific enum definitions. With CGP, you get a reusable, type-safe visitor implementation that scales cleanly as your codebase grows.&lt;&#x2F;p&gt;
&lt;p&gt;In short, &lt;code&gt;DispatchEval&lt;&#x2F;code&gt; and &lt;code&gt;MatchWithValueHandlers&lt;&#x2F;code&gt; together make it possible to evaluate complex enums in a clean, declarative, and extensible way — without writing repetitive boilerplate or giving up compile-time guarantees. It’s another example of how CGP turns what would normally be painful and manual trait implementations into something elegant and maintainable.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;converting-to-a-lisp-expression&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#converting-to-a-lisp-expression&quot; aria-label=&quot;Anchor link for: converting-to-a-lisp-expression&quot;&gt;Converting to a Lisp Expression&lt;&#x2F;a&gt;&lt;&#x2F;h1&gt;
&lt;p&gt;At this point, we’ve implemented a basic arithmetic evaluator using CGP. But interpreting expressions is only one of many possible operations we might want to perform. Often, we want to &lt;strong&gt;transform&lt;&#x2F;strong&gt; the syntax tree — say, converting it into a string, generating code, or emitting tokens for macro expansion.&lt;&#x2F;p&gt;
&lt;p&gt;Although a plain &lt;code&gt;to_string&lt;&#x2F;code&gt; implementation could be a compelling use case on its own, it might seem too trivial to justify CGP’s involvement (spoiler: it’s not). So instead, to make things a little more illustrative and practical, we’ll convert our arithmetic expressions into &lt;strong&gt;Lisp expressions&lt;&#x2F;strong&gt; — specifically, into a form inspired by &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;S-expression&quot;&gt;S-expressions&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;why-lisp&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#why-lisp&quot; aria-label=&quot;Anchor link for: why-lisp&quot;&gt;Why Lisp?&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;The motivation here is similar to the real-world task of converting a Rust syntax tree (like &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;syn&#x2F;latest&#x2F;syn&#x2F;enum.Expr.html&quot;&gt;&lt;code&gt;syn::Expr&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;) into a &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;proc-macro2&#x2F;latest&#x2F;proc_macro2&#x2F;struct.TokenStream.html&quot;&gt;&lt;code&gt;TokenStream&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;. That task typically requires walking a rich enum structure and transforming it into a stream of tokens. Rather than deal with the full complexity of &lt;code&gt;TokenStream&lt;&#x2F;code&gt;, we’ll use a simplified representation based on Lisp syntax — concise, nested, and familiar to anyone who’s seen prefix notation.&lt;&#x2F;p&gt;
&lt;p&gt;For example, our arithmetic expression &lt;code&gt;1 + (2 * 3)&lt;&#x2F;code&gt; would become the Lisp-like expression: &lt;code&gt;(+ 1 (* 2 3))&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;To represent this form, we define a general-purpose enum:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[derive(HasFields, FromVariant, ExtractField)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub enum &lt;&#x2F;span&gt;&lt;span&gt;LispExpr {
&lt;&#x2F;span&gt;&lt;span&gt;    List(List&amp;lt;LispExpr&amp;gt;),
&lt;&#x2F;span&gt;&lt;span&gt;    Literal(Literal&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u64&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;),
&lt;&#x2F;span&gt;&lt;span&gt;    Ident(Ident),
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;List&amp;lt;Expr&amp;gt;(pub Vec&amp;lt;Box&amp;lt;Expr&amp;gt;&amp;gt;);
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;Ident(pub String);
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;Literal&amp;lt;T&amp;gt;(pub T);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This &lt;code&gt;LispExpr&lt;&#x2F;code&gt; enum is broader than our original &lt;code&gt;MathExpr&lt;&#x2F;code&gt; — it can represent not just arithmetic but more general symbolic forms. Each &lt;code&gt;List&lt;&#x2F;code&gt; is a vector of boxed sub-expressions; &lt;code&gt;Literal&lt;&#x2F;code&gt; holds numeric values; and &lt;code&gt;Ident&lt;&#x2F;code&gt; wraps identifiers like &lt;code&gt;&quot;+&quot;&lt;&#x2F;code&gt; or &lt;code&gt;&quot;*&quot;&lt;&#x2F;code&gt;. For simplicity, we use a &lt;code&gt;Vec&lt;&#x2F;code&gt; instead of a linked list.&lt;&#x2F;p&gt;
&lt;p&gt;We can manually construct the equivalent of &lt;code&gt;(+ 1 (* 2 3))&lt;&#x2F;code&gt; like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; lisp_expr = LispExpr::List(List(vec![
&lt;&#x2F;span&gt;&lt;span&gt;    LispExpr::Ident(Ident(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;+&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;.to_owned())).into(),
&lt;&#x2F;span&gt;&lt;span&gt;    LispExpr::Literal(Literal(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;)).into(),
&lt;&#x2F;span&gt;&lt;span&gt;    LispExpr::List(List(vec![
&lt;&#x2F;span&gt;&lt;span&gt;        LispExpr::Ident(Ident(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;*&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;.to_owned())).into(),
&lt;&#x2F;span&gt;&lt;span&gt;        LispExpr::Literal(Literal(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;)).into(),
&lt;&#x2F;span&gt;&lt;span&gt;        LispExpr::Literal(Literal(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span&gt;)).into(),
&lt;&#x2F;span&gt;&lt;span&gt;    ])).into()
&lt;&#x2F;span&gt;&lt;span&gt;]));
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This demonstrates the basic structure. But the real point is this: converting from &lt;code&gt;Expr&lt;&#x2F;code&gt; to &lt;code&gt;LispExpr&lt;&#x2F;code&gt; &lt;strong&gt;is itself another instance of the expression problem&lt;&#x2F;strong&gt;, just like evaluation. In fact, it&#x27;s even more subtle — this is a &lt;strong&gt;&quot;double expression problem&quot;&lt;&#x2F;strong&gt;: we want to decouple our logic from both the &lt;em&gt;source expression type&lt;&#x2F;em&gt; (&lt;code&gt;MathExpr&lt;&#x2F;code&gt;) and the &lt;em&gt;target type&lt;&#x2F;em&gt; (&lt;code&gt;LispExpr&lt;&#x2F;code&gt;).&lt;&#x2F;p&gt;
&lt;p&gt;So how do we solve it modularly?&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-computerref-component&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-computerref-component&quot; aria-label=&quot;Anchor link for: the-computerref-component&quot;&gt;The &lt;code&gt;ComputerRef&lt;&#x2F;code&gt; Component&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;To implement this modular conversion, we’ll use a slightly different CGP trait: &lt;code&gt;ComputerRef&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_component(ComputerRef)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;CanComputeRef&amp;lt;Code, Input&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Output&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;compute_ref(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self, _code: PhantomData&amp;lt;Code&amp;gt;, input: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;Input) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;Output;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;code&gt;ComputerRef&lt;&#x2F;code&gt; is similar to &lt;code&gt;Computer&lt;&#x2F;code&gt;, but it takes a &lt;strong&gt;reference&lt;&#x2F;strong&gt; to the input rather than consuming it. This is especially useful in our case, because we might want to evaluate the expression again after transforming it — something we couldn’t do if we moved it.&lt;&#x2F;p&gt;
&lt;p&gt;While we &lt;em&gt;could&lt;&#x2F;em&gt; clone the input or use higher-ranked trait bounds to handle references, &lt;code&gt;ComputerRef&lt;&#x2F;code&gt; offers a cleaner, more ergonomic solution. CGP also provides promotion adapters that allow &lt;code&gt;ComputerRef&lt;&#x2F;code&gt; implementations to act as &lt;code&gt;Computer&lt;&#x2F;code&gt; providers when needed. So the two traits are often interchangeable in practice — use the one that fits your borrowing needs.&lt;&#x2F;p&gt;
&lt;p&gt;For the example, we used &lt;code&gt;Computer&lt;&#x2F;code&gt; to implement evaluation, but &lt;code&gt;ComputerRef&lt;&#x2F;code&gt; for to-Lisp transformation, to demonstrate the use of both traits. In practice, you might want to use &lt;code&gt;ComputerRef&lt;&#x2F;code&gt; for evaluation as well, so that the same expression can still be reused after evaluation.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;implementing-plustolisp&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#implementing-plustolisp&quot; aria-label=&quot;Anchor link for: implementing-plustolisp&quot;&gt;Implementing &lt;code&gt;PlusToLisp&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;With our expression types and Lisp target representation in place, we can now implement a CGP provider that transforms a &lt;code&gt;Plus&lt;&#x2F;code&gt; expression into its corresponding Lisp representation. Here&#x27;s what the provider looks like:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_new_provider]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;Context, Code, MathExpr, LispExpr&amp;gt; ComputerRef&amp;lt;Context, Code, Plus&amp;lt;MathExpr&amp;gt;&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;PlusToLisp
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;    Context:
&lt;&#x2F;span&gt;&lt;span&gt;        HasLispExprType&amp;lt;LispExpr = LispExpr&amp;gt; + CanComputeRef&amp;lt;Code, MathExpr, Output = LispExpr&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    LispSubExpr&amp;lt;LispExpr&amp;gt;: CanUpcast&amp;lt;LispExpr&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Output &lt;&#x2F;span&gt;&lt;span&gt;= LispExpr;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;compute_ref(
&lt;&#x2F;span&gt;&lt;span&gt;        context: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;Context,
&lt;&#x2F;span&gt;&lt;span&gt;        code: PhantomData&amp;lt;Code&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        Plus { left, right }: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;Plus&amp;lt;MathExpr&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    ) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;Output {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; expr_a = context.compute_ref(code, left);
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; expr_b = context.compute_ref(code, right);
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; ident = LispSubExpr::Ident(Ident(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;+&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;.to_owned())).upcast(PhantomData);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        LispSubExpr::List(List(vec![ident.into(), expr_a.into(), expr_b.into()]))
&lt;&#x2F;span&gt;&lt;span&gt;            .upcast(PhantomData)
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This implementation takes a &lt;code&gt;Plus&amp;lt;MathExpr&amp;gt;&lt;&#x2F;code&gt; as input and returns a &lt;code&gt;LispExpr&lt;&#x2F;code&gt; as output. The transformation is recursive: each subexpression is converted by delegating to the same &lt;code&gt;ComputerRef&lt;&#x2F;code&gt; trait for &lt;code&gt;MathExpr&lt;&#x2F;code&gt;. The resulting &lt;code&gt;LispExpr&lt;&#x2F;code&gt; values are then combined into a list, with the &lt;code&gt;&quot;+&quot;&lt;&#x2F;code&gt; operator represented as an identifier at the head.&lt;&#x2F;p&gt;
&lt;p&gt;Notice that the provider is generic over both the context and the code. It requires that the context knows how to evaluate an &lt;code&gt;MathExpr&lt;&#x2F;code&gt; into a &lt;code&gt;LispExpr&lt;&#x2F;code&gt;, and that it defines a concrete type for &lt;code&gt;LispExpr&lt;&#x2F;code&gt;. This is done via a CGP type trait called &lt;code&gt;HasLispExprType&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_type]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;HasLispExprType {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;LispExpr&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;By relying on this trait, we avoid hardcoding the &lt;code&gt;LispExpr&lt;&#x2F;code&gt; type directly into the provider. Instead, the actual type can be supplied later when we wire everything together.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;constructing-variants-with-sub-enums&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#constructing-variants-with-sub-enums&quot; aria-label=&quot;Anchor link for: constructing-variants-with-sub-enums&quot;&gt;Constructing Variants with Sub-Enums&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;While we want to construct a &lt;code&gt;LispExpr&lt;&#x2F;code&gt; as the final result, we do not necessarily need access to all of its variants inside this provider. In fact, for converting a &lt;code&gt;Plus&lt;&#x2F;code&gt; node, we only need to construct two specific kinds of &lt;code&gt;LispExpr&lt;&#x2F;code&gt;: a &lt;code&gt;List&lt;&#x2F;code&gt;, and an &lt;code&gt;Ident&lt;&#x2F;code&gt; representing &lt;code&gt;&quot;+&quot;&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;To express this more precisely, we define a &lt;em&gt;local&lt;&#x2F;em&gt; enum called &lt;code&gt;LispSubExpr&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[derive(HasFields, ExtractField, FromVariant)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;enum &lt;&#x2F;span&gt;&lt;span&gt;LispSubExpr&amp;lt;LispExpr&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    List(List&amp;lt;LispExpr&amp;gt;),
&lt;&#x2F;span&gt;&lt;span&gt;    Ident(Ident),
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This &lt;code&gt;LispSubExpr&lt;&#x2F;code&gt; enum includes only the subset of variants required to construct a &lt;code&gt;Plus&lt;&#x2F;code&gt; expression in Lisp form. It excludes other variants like &lt;code&gt;Literal&lt;&#x2F;code&gt;, which may be needed by other parts of the transformation but are not relevant here. Even though &lt;code&gt;LispSubExpr&lt;&#x2F;code&gt; is a reduced version of &lt;code&gt;LispExpr&lt;&#x2F;code&gt;, it is still parameterized by the full &lt;code&gt;LispExpr&lt;&#x2F;code&gt; type, so that the elements in the list can recursively represent complete expressions.&lt;&#x2F;p&gt;
&lt;p&gt;To use &lt;code&gt;LispSubExpr&lt;&#x2F;code&gt; in our transformation, we need a way to convert — or more precisely, &lt;em&gt;upcast&lt;&#x2F;em&gt; — from this smaller enum into the full &lt;code&gt;LispExpr&lt;&#x2F;code&gt;. This is made possible by implementing the &lt;code&gt;CanUpcast&lt;&#x2F;code&gt; trait we &lt;a href=&quot;&#x2F;blog&#x2F;extensible-datatypes-part-1#safe-enum-upcasting&quot;&gt;introduced earlier&lt;&#x2F;a&gt;, which is implemented automatically when we annotate the enum with &lt;code&gt;#[derive(HasFields, ExtractField, FromVariant)]&lt;&#x2F;code&gt;. This gives us a safe and type-checked way to promote the constructed value into the broader type expected by the rest of the system.&lt;&#x2F;p&gt;
&lt;p&gt;Inside the method body, we first compute the Lisp representations of the two sub-expressions. Then we create an identifier for the &lt;code&gt;&quot;+&quot;&lt;&#x2F;code&gt; symbol and upcast it to &lt;code&gt;LispExpr&lt;&#x2F;code&gt;. Finally, we build a &lt;code&gt;List&lt;&#x2F;code&gt; containing the operator followed by the two operands, and upcast that list into the final &lt;code&gt;LispExpr&lt;&#x2F;code&gt; result.&lt;&#x2F;p&gt;
&lt;p&gt;This pattern demonstrates how CGP’s upcasting mechanism makes it easy to construct enum values in a modular and flexible way. Instead of requiring full knowledge of the target enum’s structure, we work with a small, purpose-specific subset. This keeps our providers focused and easier to reason about, while still interoperating cleanly with the larger system.&lt;&#x2F;p&gt;
&lt;p&gt;In essence, &lt;code&gt;LispSubExpr&lt;&#x2F;code&gt; plays a role similar to what &lt;code&gt;#[cgp_auto_getter]&lt;&#x2F;code&gt; do for structs in CGP. Just as &lt;code&gt;#[cgp_auto_getter]&lt;&#x2F;code&gt; lets you &lt;strong&gt;read&lt;&#x2F;strong&gt; fields from a struct through a derived trait without knowing the whole type, &lt;code&gt;CanUpcast&lt;&#x2F;code&gt; lets you &lt;strong&gt;construct&lt;&#x2F;strong&gt; parts of an enum using only the variants you care about — without being tied to the entire definition of the enum.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;implementing-literaltolisp&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#implementing-literaltolisp&quot; aria-label=&quot;Anchor link for: implementing-literaltolisp&quot;&gt;Implementing &lt;code&gt;LiteralToLisp&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;The implementation of &lt;code&gt;TimesToLisp&lt;&#x2F;code&gt; follows the same pattern as &lt;code&gt;PlusToLisp&lt;&#x2F;code&gt;, differing only in that it constructs the &lt;code&gt;&quot;*&quot;&lt;&#x2F;code&gt; identifier instead of &lt;code&gt;&quot;+&quot;&lt;&#x2F;code&gt;. Since the structure is nearly identical, we will focus instead on a more interesting case: converting literal values into their Lisp representation.&lt;&#x2F;p&gt;
&lt;p&gt;The transformation of a literal is handled by the &lt;code&gt;LiteralToLisp&lt;&#x2F;code&gt; provider, which implements the &lt;code&gt;ComputerRef&lt;&#x2F;code&gt; trait. The core idea here is to wrap the literal value in a Lisp-compatible enum variant and return it as the final result. Here&#x27;s the implementation:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_new_provider]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;Context, Code, T, LispExpr&amp;gt; ComputerRef&amp;lt;Context, Code, Literal&amp;lt;T&amp;gt;&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;LiteralToLisp
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;    Context: HasLispExprType&amp;lt;LispExpr = LispExpr&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    LispSubExpr&amp;lt;T&amp;gt;: CanUpcast&amp;lt;LispExpr&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    T: Clone,
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Output &lt;&#x2F;span&gt;&lt;span&gt;= LispExpr;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;compute_ref(
&lt;&#x2F;span&gt;&lt;span&gt;        _context: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;Context,
&lt;&#x2F;span&gt;&lt;span&gt;        _code: PhantomData&amp;lt;Code&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        Literal(value): &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;Literal&amp;lt;T&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    ) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;Output {
&lt;&#x2F;span&gt;&lt;span&gt;        LispSubExpr::Literal(Literal(value.clone())).upcast(PhantomData)
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In this implementation, we pattern match on a reference to the &lt;code&gt;Literal&amp;lt;T&amp;gt;&lt;&#x2F;code&gt; and simply clone the value before constructing a new &lt;code&gt;Literal&lt;&#x2F;code&gt; variant inside a helper enum. This enum, &lt;code&gt;LispSubExpr&lt;&#x2F;code&gt;, plays the same role here as it did in the &lt;code&gt;PlusToLisp&lt;&#x2F;code&gt; provider: it defines a minimal subset of variants sufficient to perform the transformation.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[derive(HasFields, ExtractField, FromVariant)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;enum &lt;&#x2F;span&gt;&lt;span&gt;LispSubExpr&amp;lt;T&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    Literal(Literal&amp;lt;T&amp;gt;),
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;What makes this pattern especially powerful is that the &lt;code&gt;LispSubExpr&lt;&#x2F;code&gt; and &lt;code&gt;Literal&lt;&#x2F;code&gt; enums are completely parameterized over the literal type &lt;code&gt;T&lt;&#x2F;code&gt;. This means that the transformation logic does not need to know or care about what kind of value the literal holds. As long as &lt;code&gt;T&lt;&#x2F;code&gt; can be cloned, the provider works uniformly for all supported literal types — whether they are numbers, strings, or other values.&lt;&#x2F;p&gt;
&lt;p&gt;There is another subtle but important aspect to this design: the &lt;code&gt;Literal&lt;&#x2F;code&gt; type used here is exactly the same as the one used in our arithmetic expression tree. In other words, the same data structure is reused across both the source language (&lt;code&gt;MathExpr&lt;&#x2F;code&gt;) and the target language (&lt;code&gt;LispExpr&lt;&#x2F;code&gt;). This isn’t just a convenience — it opens the door to reusing logic across very different language expressions.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;wiring-to-lisp-handlers&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#wiring-to-lisp-handlers&quot; aria-label=&quot;Anchor link for: wiring-to-lisp-handlers&quot;&gt;Wiring To-Lisp Handlers&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;With the Lisp transformation providers now defined, the final step is to integrate them into the interpreter context. This is where the individual pieces — evaluation, transformation, and type configuration — are all connected through CGP’s &lt;code&gt;delegate_components!&lt;&#x2F;code&gt; macro. To do this, we update the &lt;code&gt;InterpreterComponents&lt;&#x2F;code&gt; definition so that it includes the logic required for converting expressions into their Lisp representations:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[derive(Eq, PartialEq, Debug, HasFields, FromVariant, ExtractField)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub enum &lt;&#x2F;span&gt;&lt;span&gt;LispExpr {
&lt;&#x2F;span&gt;&lt;span&gt;    List(List&amp;lt;LispExpr&amp;gt;),
&lt;&#x2F;span&gt;&lt;span&gt;    Literal(Literal&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u64&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;),
&lt;&#x2F;span&gt;&lt;span&gt;    Ident(Ident),
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;delegate_components! {
&lt;&#x2F;span&gt;&lt;span&gt;    InterpreterComponents {
&lt;&#x2F;span&gt;&lt;span&gt;        LispExprTypeProviderComponent:
&lt;&#x2F;span&gt;&lt;span&gt;            UseType&amp;lt;LispExpr&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        ComputerComponent:
&lt;&#x2F;span&gt;&lt;span&gt;            UseInputDelegate&amp;lt;
&lt;&#x2F;span&gt;&lt;span&gt;                new EvalComponents &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;                    MathExpr: DispatchEval,
&lt;&#x2F;span&gt;&lt;span&gt;                    Literal&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u64&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;: EvalLiteral,
&lt;&#x2F;span&gt;&lt;span&gt;                    Plus&amp;lt;Expr&amp;gt;: EvalAdd,
&lt;&#x2F;span&gt;&lt;span&gt;                    Times&amp;lt;Expr&amp;gt;: EvalMultiply,
&lt;&#x2F;span&gt;&lt;span&gt;                }
&lt;&#x2F;span&gt;&lt;span&gt;            &amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        ComputerRefComponent:
&lt;&#x2F;span&gt;&lt;span&gt;            UseInputDelegate&amp;lt;
&lt;&#x2F;span&gt;&lt;span&gt;                new ToLispComponents &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;                    Expr: DispatchToLisp,
&lt;&#x2F;span&gt;&lt;span&gt;                    Literal&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u64&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;: LiteralToLisp,
&lt;&#x2F;span&gt;&lt;span&gt;                    Plus&amp;lt;Expr&amp;gt;: PlusToLisp,
&lt;&#x2F;span&gt;&lt;span&gt;                    Times&amp;lt;Expr&amp;gt;: TimesToLisp,
&lt;&#x2F;span&gt;&lt;span&gt;                }
&lt;&#x2F;span&gt;&lt;span&gt;            &amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In this setup, the &lt;code&gt;LispExprTypeProviderComponent&lt;&#x2F;code&gt; establishes the concrete &lt;code&gt;LispExpr&lt;&#x2F;code&gt; enum as the actual type behind the abstract &lt;code&gt;LispExpr&lt;&#x2F;code&gt; used in our providers. This mapping is done through &lt;code&gt;UseType&lt;&#x2F;code&gt;, which binds the type parameter required by &lt;code&gt;HasLispExprType&lt;&#x2F;code&gt; to the specific enum definition we want to use in the final output.&lt;&#x2F;p&gt;
&lt;p&gt;The &lt;code&gt;ComputerComponent&lt;&#x2F;code&gt; remains unchanged from when we configured the system for arithmetic evaluation. It continues to delegate evaluation logic to the appropriate providers, such as &lt;code&gt;EvalAdd&lt;&#x2F;code&gt; for addition and &lt;code&gt;EvalLiteral&lt;&#x2F;code&gt; for literal values.&lt;&#x2F;p&gt;
&lt;p&gt;The main addition here is the &lt;code&gt;ComputerRefComponent&lt;&#x2F;code&gt;, which enables reference-based computations — specifically, the transformation of expression trees into Lisp form without taking ownership of them. This component also uses &lt;code&gt;UseInputDelegate&lt;&#x2F;code&gt;, but it connects to a different set of providers: those responsible for generating Lisp output. It includes the transformation logic for &lt;code&gt;Plus&lt;&#x2F;code&gt;, &lt;code&gt;Times&lt;&#x2F;code&gt;, and &lt;code&gt;Literal&lt;&#x2F;code&gt;, each handled by their respective providers.&lt;&#x2F;p&gt;
&lt;p&gt;For the top-level &lt;code&gt;MathExpr&lt;&#x2F;code&gt; type, we introduce &lt;code&gt;DispatchToLisp&lt;&#x2F;code&gt;, a dedicated dispatcher that routes the various expression variants to their corresponding transformation providers. It is defined as follows:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_new_provider]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;Code&amp;gt; ComputerRef&amp;lt;Interpreter, Code, MathExpr&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;DispatchToLisp {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Output &lt;&#x2F;span&gt;&lt;span&gt;= LispExpr;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;compute_ref(context: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;Interpreter, code: PhantomData&amp;lt;Code&amp;gt;, expr: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;MathExpr) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;Output {
&lt;&#x2F;span&gt;&lt;span&gt;        &amp;lt;MatchWithValueHandlersRef&amp;gt;::compute_ref(context, code, expr)
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This implementation mirrors the earlier &lt;code&gt;DispatchEval&lt;&#x2F;code&gt;, but with one key distinction: it uses &lt;code&gt;MatchWithValueHandlersRef&lt;&#x2F;code&gt;, a visitor dispatcher designed specifically for reference-based operations. Rather than consuming the input, it operates on borrowed values and dispatches calls to providers that implement the &lt;code&gt;ComputerRef&lt;&#x2F;code&gt; trait.&lt;&#x2F;p&gt;
&lt;p&gt;One of the major advantages of this approach is that it is entirely driven by the type system. Because the dispatcher is implemented generically — as a regular Rust &lt;code&gt;impl&lt;&#x2F;code&gt; rather than a macro — it benefits fully from the compiler’s ability to check lifetime correctness, trait bounds, and input-output consistency. Mistakes such as passing the wrong reference type, using incompatible trait bounds, or violating borrowing rules are caught immediately at compile time, often with clear and actionable error messages.&lt;&#x2F;p&gt;
&lt;p&gt;If this logic had instead been implemented using traditional Rust macros, many of these issues would only surface later during macro expansion or execution, making them harder to trace and debug. CGP’s generic dispatchers, by contrast, offer the same level of automation while remaining transparent and fully type-checked.&lt;&#x2F;p&gt;
&lt;p&gt;The &lt;code&gt;MatchWithValueHandlers&lt;&#x2F;code&gt; and &lt;code&gt;MatchWithValueHandlersRef&lt;&#x2F;code&gt; dispatchers are just two examples of CGP’s modular dispatching infrastructure. CGP provides a &lt;em&gt;family&lt;&#x2F;em&gt; of such dispatchers, each tuned for a particular use case — whether by value, by reference, or with more specialized patterns. These dispatchers are designed to be extensible and interchangeable, giving you fine-grained control over how your logic is routed while preserving flexibility.&lt;&#x2F;p&gt;
&lt;p&gt;With both evaluation and Lisp transformation now wired into the same interpreter context, the system is able to evaluate expressions to numeric results or convert them into Lisp-style syntax trees, all from the same &lt;code&gt;MathExpr&lt;&#x2F;code&gt; type. The modularity, reusability, and compile-time guarantees of this architecture make CGP a powerful and scalable tool for building language runtimes and transformation pipelines in Rust.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;advanced-techniques&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#advanced-techniques&quot; aria-label=&quot;Anchor link for: advanced-techniques&quot;&gt;Advanced Techniques&lt;&#x2F;a&gt;&lt;&#x2F;h1&gt;
&lt;h2 id=&quot;binary-operator-provider&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#binary-operator-provider&quot; aria-label=&quot;Anchor link for: binary-operator-provider&quot;&gt;Binary Operator Provider&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;When examining the implementations of &lt;code&gt;PlusToLisp&lt;&#x2F;code&gt; and &lt;code&gt;TimesToLisp&lt;&#x2F;code&gt;, it quickly becomes clear that they follow nearly identical patterns. Aside from the specific operator symbol and the input types, the transformation logic is the same. This duplication presents a perfect opportunity for &lt;em&gt;further abstraction&lt;&#x2F;em&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;By extracting the shared structure, we can implement a generalized provider, &lt;code&gt;BinaryOpToLisp&lt;&#x2F;code&gt;, that handles both &lt;code&gt;Plus&lt;&#x2F;code&gt; and &lt;code&gt;Times&lt;&#x2F;code&gt; expressions using a single implementation:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_new_provider]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;Context, Code, MathExpr, MathSubExpr, LispExpr, Operator&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    ComputerRef&amp;lt;Context, Code, MathSubExpr&amp;gt; for BinaryOpToLisp&amp;lt;Operator&amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;    Context: HasMathExprType&amp;lt;MathExpr = MathExpr&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;        + HasLispExprType&amp;lt;LispExpr = LispExpr&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;        + CanComputeRef&amp;lt;Code, MathExpr, Output = LispExpr&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    MathSubExpr: BinarySubExpression&amp;lt;MathExpr&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    Operator: Default + Display,
&lt;&#x2F;span&gt;&lt;span&gt;    LispSubExpr&amp;lt;LispExpr&amp;gt;: CanUpcast&amp;lt;LispExpr&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Output &lt;&#x2F;span&gt;&lt;span&gt;= LispExpr;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;compute_ref(context: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;Context, code: PhantomData&amp;lt;Code&amp;gt;, expr: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;MathSubExpr) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;Output {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; expr_a = context.compute_ref(code, expr.left());
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; expr_b = context.compute_ref(code, expr.right());
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; ident = LispSubExpr::Ident(Ident(Operator::default().to_string())).upcast(PhantomData);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        LispSubExpr::List(List(vec![ident.into(), expr_a.into(), expr_b.into()]))
&lt;&#x2F;span&gt;&lt;span&gt;            .upcast(PhantomData)
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This provider introduces a generic &lt;code&gt;Operator&lt;&#x2F;code&gt; type, which is expected to represent the binary operator as a type-level string, such as &lt;code&gt;&quot;+&quot;&lt;&#x2F;code&gt; or &lt;code&gt;&quot;*&quot;&lt;&#x2F;code&gt;. To support this, &lt;code&gt;Operator&lt;&#x2F;code&gt; must implement both &lt;code&gt;Default&lt;&#x2F;code&gt; and &lt;code&gt;Display&lt;&#x2F;code&gt;. These traits allow the provider to convert the operator type into a string during execution, which is then used to create a &lt;code&gt;LispSubExpr::Ident&lt;&#x2F;code&gt; variant representing the operation.&lt;&#x2F;p&gt;
&lt;p&gt;The input to this provider is any &lt;code&gt;MathSubExpr&lt;&#x2F;code&gt; — which could be &lt;code&gt;Plus&lt;&#x2F;code&gt;, &lt;code&gt;Times&lt;&#x2F;code&gt;, or any other binary expression type — that implements the &lt;code&gt;BinarySubExpression&lt;&#x2F;code&gt; trait:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_auto_getter]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;BinarySubExpression&amp;lt;Expr&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;left(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;Box&amp;lt;Expr&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;right(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;Box&amp;lt;Expr&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;By annotating this trait with &lt;code&gt;#[cgp_auto_getter]&lt;&#x2F;code&gt;, CGP can automatically implement it for any struct that contains &lt;code&gt;left&lt;&#x2F;code&gt; and &lt;code&gt;right&lt;&#x2F;code&gt; fields of type &lt;code&gt;Box&amp;lt;Expr&amp;gt;&lt;&#x2F;code&gt;. This removes the need to manually implement the trait for each binary operator type and allows the generic provider to access subexpressions in a uniform way.&lt;&#x2F;p&gt;
&lt;p&gt;To connect this trait to the right expression type, we introduce the &lt;code&gt;HasMathExprType&lt;&#x2F;code&gt; trait:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_type]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;HasMathExprType {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;MathExpr&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This trait plays a similar role to &lt;code&gt;HasLispExprType&lt;&#x2F;code&gt;, allowing us to define the abstract &lt;code&gt;MathExpr&lt;&#x2F;code&gt; type outside of the generic parameters of the provider. It ensures that the right type is used consistently throughout the system and helps avoid ambiguity when specifying the generic parameter for &lt;code&gt;BinarySubExpression&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;The body of &lt;code&gt;compute_ref&lt;&#x2F;code&gt; mirrors the logic we saw earlier. We evaluate both the left and right subexpressions recursively, construct a Lisp identifier by calling &lt;code&gt;Operator::default().to_string()&lt;&#x2F;code&gt;, and then build a list containing the operator followed by the operands. The resulting Lisp structure is then upcast into the final &lt;code&gt;LispExpr&lt;&#x2F;code&gt; type.&lt;&#x2F;p&gt;
&lt;p&gt;With this reusable provider in place, we can now eliminate the separate implementations for &lt;code&gt;PlusToLisp&lt;&#x2F;code&gt; and &lt;code&gt;TimesToLisp&lt;&#x2F;code&gt;, and wire both operators through a single generic provider in our component configuration:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;delegate_components! {
&lt;&#x2F;span&gt;&lt;span&gt;    InterpreterComponents {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;        MathExprTypeProviderComponent:
&lt;&#x2F;span&gt;&lt;span&gt;            UseType&amp;lt;MathExpr&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        ComputerRefComponent:
&lt;&#x2F;span&gt;&lt;span&gt;            UseInputDelegate&amp;lt;
&lt;&#x2F;span&gt;&lt;span&gt;                new ToLispComponents &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;                    MathExpr: DispatchToLisp,
&lt;&#x2F;span&gt;&lt;span&gt;                    Literal&amp;lt;Value&amp;gt;: LiteralToLisp,
&lt;&#x2F;span&gt;&lt;span&gt;                    Plus&amp;lt;MathExpr&amp;gt;: BinaryOpToLisp&amp;lt;Symbol&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;+&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;)&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;                    Times&amp;lt;MathExpr&amp;gt;: BinaryOpToLisp&amp;lt;Symbol&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;*&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;)&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;                }
&lt;&#x2F;span&gt;&lt;span&gt;            &amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Here, we map &lt;code&gt;Plus&amp;lt;MathExpr&amp;gt;&lt;&#x2F;code&gt; and &lt;code&gt;Times&amp;lt;MathExpr&amp;gt;&lt;&#x2F;code&gt; to the same &lt;code&gt;BinaryOpToLisp&lt;&#x2F;code&gt; provider, each with a different &lt;code&gt;Symbol!&lt;&#x2F;code&gt; type-level string.&lt;&#x2F;p&gt;
&lt;p&gt;Thanks to CGP’s expressive delegation system and powerful match-based dispatching via &lt;code&gt;MatchWithValueHandlersRef&lt;&#x2F;code&gt;, this setup allows us to write reusable, composable transformation logic. Rather than duplicating the same structure across multiple providers, we define it once in a generic form and let the type system handle the rest.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;code-based-dispatching&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#code-based-dispatching&quot; aria-label=&quot;Anchor link for: code-based-dispatching&quot;&gt;Code-Based Dispatching&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Earlier, we explored the difference between the &lt;code&gt;Computer&lt;&#x2F;code&gt; and &lt;code&gt;ComputerRef&lt;&#x2F;code&gt; traits and saw how &lt;code&gt;ComputerRef&lt;&#x2F;code&gt; offers a cleaner and more efficient interface for computations that don’t require ownership of the input. This naturally applies to our evaluation logic as well — after all, an evaluator only needs to borrow the expression, not consume it.&lt;&#x2F;p&gt;
&lt;p&gt;However, once we refactor our &lt;code&gt;EvalAdd&lt;&#x2F;code&gt;, &lt;code&gt;EvalMultiply&lt;&#x2F;code&gt;, and other evaluation providers to use &lt;code&gt;ComputerRef&lt;&#x2F;code&gt;, we run into a challenge: we’ve already wired &lt;code&gt;ComputerRefComponent&lt;&#x2F;code&gt; for the purpose of transforming expressions to Lisp. How do we now support &lt;em&gt;both&lt;&#x2F;em&gt; evaluation and transformation using the same trait?&lt;&#x2F;p&gt;
&lt;p&gt;This is where the &lt;code&gt;Code&lt;&#x2F;code&gt; parameter in the &lt;code&gt;ComputerRef&lt;&#x2F;code&gt; trait comes into play. If you’ve read about &lt;a href=&quot;&#x2F;blog&#x2F;hypershell-release&#x2F;#generic-dispatcher&quot;&gt;Hypershell’s design&lt;&#x2F;a&gt;, you’ll recognize &lt;code&gt;Code&lt;&#x2F;code&gt; can be used to build type-level DSLs to encode the kind of operation we want to perform. In our interpreter, we can apply the same idea to distinguish between different computation &lt;em&gt;intentions&lt;&#x2F;em&gt; — for example, evaluation vs. conversion.&lt;&#x2F;p&gt;
&lt;p&gt;Let’s begin by defining two types that represent our operations at the type level:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;Eval;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;ToLisp;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;These act as “statements” in our interpreter DSL. &lt;code&gt;Eval&lt;&#x2F;code&gt; represents program evaluation, while &lt;code&gt;ToLisp&lt;&#x2F;code&gt; represents conversion into Lisp syntax. This gives us a lightweight and expressive way to route logic based on the kind of computation we want to perform.&lt;&#x2F;p&gt;
&lt;p&gt;With that in place, we can define a single provider for handling &lt;code&gt;Plus&lt;&#x2F;code&gt; expressions, where the behavior is determined by the &lt;code&gt;Code&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;delegate_components! {
&lt;&#x2F;span&gt;&lt;span&gt;    new HandlePlus {
&lt;&#x2F;span&gt;&lt;span&gt;        ComputerRefComponent: UseDelegate&amp;lt;
&lt;&#x2F;span&gt;&lt;span&gt;            new PlusHandlers &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;                Eval: EvalAdd,
&lt;&#x2F;span&gt;&lt;span&gt;                ToLisp: BinaryOpToLisp&amp;lt;Symbol&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;+&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;)&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;            }&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Here, we use &lt;code&gt;delegate_components!&lt;&#x2F;code&gt; to define a new provider called &lt;code&gt;HandlePlus&lt;&#x2F;code&gt;. Inside it, we delegate the &lt;code&gt;ComputerRefComponent&lt;&#x2F;code&gt; implementation to &lt;code&gt;UseDelegate&lt;&#x2F;code&gt;, which performs &lt;code&gt;Code&lt;&#x2F;code&gt;-based dispatching based on the newly created dispatch table &lt;code&gt;PlusHandlers&lt;&#x2F;code&gt;. If the &lt;code&gt;Code&lt;&#x2F;code&gt; is &lt;code&gt;Eval&lt;&#x2F;code&gt;, it uses &lt;code&gt;EvalAdd&lt;&#x2F;code&gt;. If it’s &lt;code&gt;ToLisp&lt;&#x2F;code&gt;, it uses &lt;code&gt;BinaryOpToLisp&amp;lt;Symbol!(&quot;+&quot;)&amp;gt;&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Thanks to CGP’s blanket implementations, &lt;code&gt;HandlePlus&lt;&#x2F;code&gt; automatically becomes a valid &lt;code&gt;ComputerRef&lt;&#x2F;code&gt; provider for &lt;code&gt;Plus&amp;lt;Expr&amp;gt;&lt;&#x2F;code&gt; — delegating to the appropriate providers based on &lt;code&gt;Code&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;We could also have achieved similar functionality by writing two separate &lt;code&gt;impl&lt;&#x2F;code&gt; blocks for &lt;code&gt;HandlePlus&lt;&#x2F;code&gt;, like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;HandlePlus;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[cgp_provider]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;Context, MathExpr&amp;gt; Computer&amp;lt;Context, Eval, Plus&amp;lt;MathExpr&amp;gt;&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;HandlePlus {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[cgp_provider]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;Context, MathExpr&amp;gt; ComputerRef&amp;lt;Context, ToLisp, Plus&amp;lt;MathExpr&amp;gt;&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;HandlePlus {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This works too, but it introduces friction. Each &lt;code&gt;impl&lt;&#x2F;code&gt; must be written in the same crate as the type it targets (in this case, &lt;code&gt;HandlePlus&lt;&#x2F;code&gt;). That restricts how you organize your code. If you wanted to group all &lt;code&gt;Eval&lt;&#x2F;code&gt; logic into one crate and all &lt;code&gt;ToLisp&lt;&#x2F;code&gt; logic into another, this approach would make it more challenging to separate the implementations.&lt;&#x2F;p&gt;
&lt;p&gt;Using &lt;code&gt;delegate_components!&lt;&#x2F;code&gt;, on the other hand, gives you complete modularity. You can define &lt;code&gt;EvalAdd&lt;&#x2F;code&gt; and &lt;code&gt;BinaryOpToLisp&lt;&#x2F;code&gt; in completely separate places, and only compose them when building the actual interpreter.&lt;&#x2F;p&gt;
&lt;p&gt;We follow this same pattern for &lt;code&gt;Times&lt;&#x2F;code&gt; and &lt;code&gt;Literal&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;delegate_components! {
&lt;&#x2F;span&gt;&lt;span&gt;    new HandleTimes {
&lt;&#x2F;span&gt;&lt;span&gt;        ComputerRefComponent: UseDelegate&amp;lt;
&lt;&#x2F;span&gt;&lt;span&gt;            new TimesHandlers &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;                Eval: EvalMultiply,
&lt;&#x2F;span&gt;&lt;span&gt;                ToLisp: BinaryOpToLisp&amp;lt;Symbol&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;*&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;)&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;            }&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;delegate_components! {
&lt;&#x2F;span&gt;&lt;span&gt;    new HandleLiteral {
&lt;&#x2F;span&gt;&lt;span&gt;        ComputerRefComponent: UseDelegate&amp;lt;
&lt;&#x2F;span&gt;&lt;span&gt;            new LiteralHandlers &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;                Eval: EvalLiteral,
&lt;&#x2F;span&gt;&lt;span&gt;                ToLisp: LiteralToLisp,
&lt;&#x2F;span&gt;&lt;span&gt;            }&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Finally, we define a top-level dispatcher that handles the &lt;code&gt;MathExpr&lt;&#x2F;code&gt; enum itself:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;delegate_components! {
&lt;&#x2F;span&gt;&lt;span&gt;    new HandleMathExpr {
&lt;&#x2F;span&gt;&lt;span&gt;        ComputerRefComponent: UseDelegate&amp;lt;
&lt;&#x2F;span&gt;&lt;span&gt;            new MathExprHandlers &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;                Eval: DispatchEval,
&lt;&#x2F;span&gt;&lt;span&gt;                ToLisp: DispatchToLisp,
&lt;&#x2F;span&gt;&lt;span&gt;            }&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now that we’ve defined these composed providers, we can plug them into the interpreter’s wiring:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;delegate_components! {
&lt;&#x2F;span&gt;&lt;span&gt;    InterpreterComponents {
&lt;&#x2F;span&gt;&lt;span&gt;        MathExprTypeProviderComponent:
&lt;&#x2F;span&gt;&lt;span&gt;            UseType&amp;lt;MathExpr&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        LispExprTypeProviderComponent:
&lt;&#x2F;span&gt;&lt;span&gt;            UseType&amp;lt;LispExpr&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        ComputerRefComponent:
&lt;&#x2F;span&gt;&lt;span&gt;            UseInputDelegate&amp;lt;
&lt;&#x2F;span&gt;&lt;span&gt;                new ExprComputerComponents &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;                    MathExpr: HandleMathExpr,
&lt;&#x2F;span&gt;&lt;span&gt;                    Literal&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u64&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;: HandleLiteral,
&lt;&#x2F;span&gt;&lt;span&gt;                    Plus&amp;lt;MathExpr&amp;gt;: HandlePlus,
&lt;&#x2F;span&gt;&lt;span&gt;                    Times&amp;lt;MathExpr&amp;gt;: HandleTimes,
&lt;&#x2F;span&gt;&lt;span&gt;                }
&lt;&#x2F;span&gt;&lt;span&gt;            &amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;At this point, we’ve created a &lt;em&gt;two-layer&lt;&#x2F;em&gt; dispatch system. The first layer selects a handler based on the &lt;em&gt;input type&lt;&#x2F;em&gt; — e.g., &lt;code&gt;Plus&amp;lt;MathExpr&amp;gt;&lt;&#x2F;code&gt;. The second layer selects a handler based on the &lt;em&gt;code type&lt;&#x2F;em&gt; — e.g., &lt;code&gt;Eval&lt;&#x2F;code&gt; vs. &lt;code&gt;ToLisp&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;This approach is flexible and composable. You could just as easily reverse the order, grouping logic by &lt;code&gt;Code&lt;&#x2F;code&gt; first and dispatching on the input type second. That may make more sense if you’re organizing your project by functionality (say, all evaluation logic in one crate, all Lisp transformation logic in another).&lt;&#x2F;p&gt;
&lt;p&gt;Importantly, the dispatch ordering is entirely compile-time and has &lt;strong&gt;no impact on performance&lt;&#x2F;strong&gt;. CGP uses Rust’s type system and monomorphization to resolve all this dispatch at compile time, so whether you dispatch by &lt;code&gt;Input&lt;&#x2F;code&gt; first or &lt;code&gt;Code&lt;&#x2F;code&gt; first, the result is the same: fast, zero-cost, strongly typed behavior.&lt;&#x2F;p&gt;
&lt;p&gt;This layered dispatch model is one of CGP’s superpowers. It enables you to write simple, focused components and compose them in flexible, scalable ways — without macros, runtime reflection, or boilerplate.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;extending-mathexpr&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#extending-mathexpr&quot; aria-label=&quot;Anchor link for: extending-mathexpr&quot;&gt;Extending &lt;code&gt;MathExpr&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;&lt;&#x2F;h1&gt;
&lt;p&gt;With the basic interpreter in place, supporting addition and multiplication, it’s natural to explore how we can extend the language further. To demonstrate the modularity and flexibility of CGP, let’s add two new features: &lt;em&gt;subtraction&lt;&#x2F;em&gt; and &lt;em&gt;negation&lt;&#x2F;em&gt;. These are simple but meaningful enhancements that allow us to test how well our interpreter handles incremental language growth.&lt;&#x2F;p&gt;
&lt;p&gt;Now, one could argue that subtraction and negation are not strictly necessary in the core language. After all, both operations can be expressed using multiplication by &lt;code&gt;-1&lt;&#x2F;code&gt;. But while this may be theoretically sound, practical language design often involves more than minimalism. By promoting these features to first-class status, we can greatly improve the ergonomics of writing and reading programs in the language.&lt;&#x2F;p&gt;
&lt;p&gt;This kind of design decision mirrors broader discussions in language evolution. Consider CGP itself. While we’ve built everything so far using CGP purely as a Rust library, it’s conceivable to imagine CGP becoming a &lt;em&gt;native&lt;&#x2F;em&gt; feature of the language. From a purist’s perspective, native support might not seem essential — after all, we’ve shown that powerful, compile-time generics-based programming is already achievable today. But once a tool like CGP becomes central to how systems are built, native support brings significant benefits: smoother integration, better diagnostics, and a lower learning curve.&lt;&#x2F;p&gt;
&lt;p&gt;In fact, if Rust were implemented using CGP from the start, it would be much easier to extend the language with features like CGP itself. There would be no need to fork the compiler or jump through macro-related hoops. Extensions could be introduced as structured additions to the language, just as we are now extending our interpreter with new syntax.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;defining-the-mathplusexpr-expression-type&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#defining-the-mathplusexpr-expression-type&quot; aria-label=&quot;Anchor link for: defining-the-mathplusexpr-expression-type&quot;&gt;Defining the &lt;code&gt;MathPlusExpr&lt;&#x2F;code&gt; Expression Type&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;To see how CGP enables modular language extension, let’s define a new expression type — &lt;code&gt;MathPlusExpr&lt;&#x2F;code&gt; — that expands on our original &lt;code&gt;MathExpr&lt;&#x2F;code&gt;. Crucially, this new enum does not replace the old one. Instead, it lives &lt;em&gt;alongside&lt;&#x2F;em&gt; it, allowing us to demonstrate how CGP supports language variants and extensions without duplicating logic or entangling implementations.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[derive(Debug, HasFields, FromVariant, ExtractField)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub enum &lt;&#x2F;span&gt;&lt;span&gt;MathPlusExpr {
&lt;&#x2F;span&gt;&lt;span&gt;    Plus(Plus&amp;lt;MathPlusExpr&amp;gt;),
&lt;&#x2F;span&gt;&lt;span&gt;    Times(Times&amp;lt;MathPlusExpr&amp;gt;),
&lt;&#x2F;span&gt;&lt;span&gt;    Minus(Minus&amp;lt;MathPlusExpr&amp;gt;),
&lt;&#x2F;span&gt;&lt;span&gt;    Negate(Negate&amp;lt;MathPlusExpr&amp;gt;),
&lt;&#x2F;span&gt;&lt;span&gt;    Literal(Literal&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;i64&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;),
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;At a glance, &lt;code&gt;MathPlusExpr&lt;&#x2F;code&gt; looks much like &lt;code&gt;MathExpr&lt;&#x2F;code&gt;, but it includes two new variants: &lt;code&gt;Minus&lt;&#x2F;code&gt; for subtraction and &lt;code&gt;Negate&lt;&#x2F;code&gt; for unary negation. For the original variants — addition, multiplication, and literals — we continue to use the same generic sub-expression types as before, now instantiated with &lt;code&gt;MathPlusExpr&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;We’ve also changed the numeric type for &lt;code&gt;Literal&lt;&#x2F;code&gt; from &lt;code&gt;u64&lt;&#x2F;code&gt; to &lt;code&gt;i64&lt;&#x2F;code&gt;, enabling the representation of negative values. This change may seem minor, but it highlights an important feature of the system: the ability to evolve types naturally without breaking compatibility. Thanks to CGP’s generic approach, providers like &lt;code&gt;EvalAdd&lt;&#x2F;code&gt; and &lt;code&gt;EvalMultiply&lt;&#x2F;code&gt; still work seamlessly. Since &lt;code&gt;i64&lt;&#x2F;code&gt; also implements &lt;code&gt;Add&lt;&#x2F;code&gt; and &lt;code&gt;Mul&lt;&#x2F;code&gt;, the existing evaluators remain fully reusable without modification.&lt;&#x2F;p&gt;
&lt;p&gt;For the two new variants, we define their associated sub-expression types just as we did before:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;Minus&amp;lt;Expr&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;left: Box&amp;lt;Expr&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;right: Box&amp;lt;Expr&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;Negate&amp;lt;Expr&amp;gt;(pub Box&amp;lt;Expr&amp;gt;);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;implementing-eval-providers&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#implementing-eval-providers&quot; aria-label=&quot;Anchor link for: implementing-eval-providers&quot;&gt;Implementing Eval Providers&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;With our extended expression language in place, the next step is to implement evaluation logic for the new constructs. We begin with subtraction. The evaluator for &lt;code&gt;Minus&lt;&#x2F;code&gt; is straightforward and closely mirrors what we’ve already done for addition and multiplication. The only real difference is that we now use the &lt;code&gt;Sub&lt;&#x2F;code&gt; trait to handle the subtraction operation.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_new_provider]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;Context, Code, MathExpr, Output&amp;gt; ComputerRef&amp;lt;Context, Code, Minus&amp;lt;MathExpr&amp;gt;&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;EvalSubtract
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;    Context: CanComputeRef&amp;lt;Code, MathExpr, Output = Output&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    Output: Sub&amp;lt;Output = Output&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Output &lt;&#x2F;span&gt;&lt;span&gt;= Output;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;compute_ref(
&lt;&#x2F;span&gt;&lt;span&gt;        context: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;Context,
&lt;&#x2F;span&gt;&lt;span&gt;        code: PhantomData&amp;lt;Code&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        Minus { left, right }: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;Minus&amp;lt;MathExpr&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    ) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;Output {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; output_a = context.compute_ref(code, left);
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; output_b = context.compute_ref(code, right);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        output_a - output_b
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We follow a similar pattern for the &lt;code&gt;Negate&lt;&#x2F;code&gt; expression. Since negation is a unary operation, its implementation is even simpler. We compute the value of the inner expression, then apply the &lt;code&gt;Neg&lt;&#x2F;code&gt; trait to produce the final result.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_new_provider]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;Context, Code, MathExpr, Output&amp;gt; ComputerRef&amp;lt;Context, Code, Negate&amp;lt;MathExpr&amp;gt;&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;EvalNegate
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;    Context: CanComputeRef&amp;lt;Code, MathExpr, Output = Output&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    Output: Neg&amp;lt;Output = Output&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Output &lt;&#x2F;span&gt;&lt;span&gt;= Output;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;compute_ref(
&lt;&#x2F;span&gt;&lt;span&gt;        context: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;Context,
&lt;&#x2F;span&gt;&lt;span&gt;        code: PhantomData&amp;lt;Code&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        Negate(expr): &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;Negate&amp;lt;MathExpr&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    ) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;Output {
&lt;&#x2F;span&gt;&lt;span&gt;        -context.compute_ref(code, expr)
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;wiring-of-interpreterplus&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#wiring-of-interpreterplus&quot; aria-label=&quot;Anchor link for: wiring-of-interpreterplus&quot;&gt;Wiring of &lt;code&gt;InterpreterPlus&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;To complete the extension, we define a new context called &lt;code&gt;InterpreterPlus&lt;&#x2F;code&gt;. This context wires together the evaluation logic for our extended expression language, including subtraction and negation.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_context]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;InterpreterPlus;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;delegate_components! {
&lt;&#x2F;span&gt;&lt;span&gt;    InterpreterPlusComponents {
&lt;&#x2F;span&gt;&lt;span&gt;        ComputerRefComponent:
&lt;&#x2F;span&gt;&lt;span&gt;            UseDelegate&amp;lt;new CodeComponents &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;                Eval: UseInputDelegate&amp;lt;new EvalComponents &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;                    MathPlusExpr: DispatchEval,
&lt;&#x2F;span&gt;&lt;span&gt;                    Plus&amp;lt;MathPlusExpr&amp;gt;: EvalAdd,
&lt;&#x2F;span&gt;&lt;span&gt;                    Times&amp;lt;MathPlusExpr&amp;gt;: EvalMultiply,
&lt;&#x2F;span&gt;&lt;span&gt;                    Minus&amp;lt;MathPlusExpr&amp;gt;: EvalSubtract,
&lt;&#x2F;span&gt;&lt;span&gt;                    Negate&amp;lt;MathPlusExpr&amp;gt;: EvalNegate,
&lt;&#x2F;span&gt;&lt;span&gt;                    Literal&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;i64&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;: EvalLiteral,
&lt;&#x2F;span&gt;&lt;span&gt;                }&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;            }&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[cgp_new_provider]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;ComputerRef&amp;lt;InterpreterPlus, Eval, MathPlusExpr&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;DispatchEval {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Output &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;i64&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;compute_ref(
&lt;&#x2F;span&gt;&lt;span&gt;        context: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;InterpreterPlus,
&lt;&#x2F;span&gt;&lt;span&gt;        code: PhantomData&amp;lt;Eval&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        expr: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;MathPlusExpr,
&lt;&#x2F;span&gt;&lt;span&gt;    ) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;Output {
&lt;&#x2F;span&gt;&lt;span&gt;        &amp;lt;MatchWithValueHandlersRef&amp;gt;::compute_ref(context, code, expr)
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Thanks to CGP’s modular design, implementing &lt;code&gt;InterpreterPlus&lt;&#x2F;code&gt; requires only a few dozen lines of code. The core task here is to dispatch each sub-expression type to its corresponding provider. We also define a context-specific wrapper implementation that enables recursive evaluation through &lt;code&gt;MatchWithValueHandlersRef&lt;&#x2F;code&gt;. This approach highlights how CGP makes it easy to extend and organize language features cleanly and efficiently.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;omitting-to-lisp-implementations&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#omitting-to-lisp-implementations&quot; aria-label=&quot;Anchor link for: omitting-to-lisp-implementations&quot;&gt;Omitting To-Lisp Implementations&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;At this stage, you might assume that supporting to-Lisp conversion for &lt;code&gt;MathPlusExpr&lt;&#x2F;code&gt; is necessary before proceeding further. However, when rapidly prototyping new language extensions, it is often desirable to &lt;em&gt;skip&lt;&#x2F;em&gt; implementing less critical features like to-Lisp conversion and focus solely on the core logic, such as evaluation.&lt;&#x2F;p&gt;
&lt;p&gt;This is where CGP shines. You can choose &lt;strong&gt;not to&lt;&#x2F;strong&gt; implement certain language features — like to-Lisp conversion for &lt;code&gt;MathPlusExpr&lt;&#x2F;code&gt; — and still have your evaluation code compile and work perfectly without any extra effort.&lt;&#x2F;p&gt;
&lt;p&gt;This stands in stark contrast to typical Rust designs that rely on &lt;strong&gt;heavyweight traits&lt;&#x2F;strong&gt; with many methods. In those cases, introducing a new type like &lt;code&gt;MathPlusExpr&lt;&#x2F;code&gt; usually forces you to provide boilerplate implementations, often filled with &lt;code&gt;unimplemented!()&lt;&#x2F;code&gt;, just to satisfy the compiler. This can quickly become cumbersome and confusing, making it hard to know which methods are truly essential for an initial prototype.&lt;&#x2F;p&gt;
&lt;p&gt;With CGP, the minimal trait design and lazy wiring mean that components are only checked for implementation when they are actually &lt;em&gt;used&lt;&#x2F;em&gt;. As a result, you can safely defer adding to-Lisp conversion for &lt;code&gt;Minus&lt;&#x2F;code&gt; and &lt;code&gt;Negate&lt;&#x2F;code&gt; without worrying about subtle runtime panics or crashes caused by missing implementations.&lt;&#x2F;p&gt;
&lt;p&gt;Thanks to CGP’s flexibility and strong compile-time guarantees, once your code compiles, you can trust that missing non-essential features won’t break your core functionality — allowing you to focus on what matters most in early development.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;conclusion&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#conclusion&quot; aria-label=&quot;Anchor link for: conclusion&quot;&gt;Conclusion&lt;&#x2F;a&gt;&lt;&#x2F;h1&gt;
&lt;p&gt;By now, we’ve seen how extensible variants and the CGP visitor pattern open up a new frontier in modular interpreter design. You can find the full source code of the examples in this article at our &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;contextgeneric&#x2F;cgp-examples&#x2F;tree&#x2F;main&#x2F;expression&quot;&gt;GitHub repository&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Rather than tying our logic to rigid enums or bloated visitor traits, we’ve been able to deconstruct and evaluate expressions with reusable, decoupled components — all backed by strong compile-time guarantees. Whether we’re evaluating arithmetic, transforming into Lisp, or handling richer variants down the line, each operation remains isolated, composable, and safe.&lt;&#x2F;p&gt;
&lt;p&gt;This is more than a workaround for the expression problem — it’s a foundational shift in how we think about data structures and operations in Rust. With CGP, you no longer need to trade off between extensibility and type safety. You can add new variants without touching existing code, and build interpreters or transformers that evolve organically with your domain.&lt;&#x2F;p&gt;
&lt;p&gt;In &lt;a href=&quot;&#x2F;blog&#x2F;extensible-datatypes-part-3&quot;&gt;Part 3 of this series, &lt;strong&gt;Implementing Extensible Records&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;, we will dive into the &lt;em&gt;underlying&lt;&#x2F;em&gt; implementation details of &lt;strong&gt;extensible records&lt;&#x2F;strong&gt;, and how the extensible builder pattern is built on top of it. We will cover the concepts of &lt;strong&gt;partial records&lt;&#x2F;strong&gt;, and the use of traits such as &lt;code&gt;BuildField&lt;&#x2F;code&gt; and &lt;code&gt;FinalizeField&lt;&#x2F;code&gt; to represent &lt;em&gt;row constraints&lt;&#x2F;em&gt;.&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>Programming Extensible Data Types in Rust with CGP - Part 1: Modular App Construction and Extensible Builders</title>
        <published>2025-07-07T00:00:00+00:00</published>
        <updated>2025-07-07T00:00:00+00:00</updated>
        
        <author>
          <name>
            Soares Chen
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://www.contextgeneric.dev/blog/extensible-datatypes-part-1/"/>
        <id>https://www.contextgeneric.dev/blog/extensible-datatypes-part-1/</id>
        
        <content type="html" xml:base="https://www.contextgeneric.dev/blog/extensible-datatypes-part-1/">&lt;p&gt;Discuss on &lt;a href=&quot;https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;rust&#x2F;comments&#x2F;1ltu9nl&#x2F;programming_extensible_data_types_in_rust_with&#x2F;&quot;&gt;Reddit&lt;&#x2F;a&gt;, &lt;a href=&quot;https:&#x2F;&#x2F;lobste.rs&#x2F;s&#x2F;piugxk&#x2F;programming_extensible_data_types_rust&quot;&gt;Lobsters&lt;&#x2F;a&gt;, &lt;a href=&quot;https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=44497815&quot;&gt;Hacker News&lt;&#x2F;a&gt;, &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;orgs&#x2F;contextgeneric&#x2F;discussions&#x2F;12&quot;&gt;GitHub&lt;&#x2F;a&gt;, or &lt;a href=&quot;https:&#x2F;&#x2F;discord.gg&#x2F;Hgk3rCw6pQ&quot;&gt;Discord&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;overview&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#overview&quot; aria-label=&quot;Anchor link for: overview&quot;&gt;Overview&lt;&#x2F;a&gt;&lt;&#x2F;h1&gt;
&lt;p&gt;I’m excited to announce the release of &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;contextgeneric&#x2F;cgp&#x2F;releases&#x2F;tag&#x2F;v0.4.2&quot;&gt;&lt;strong&gt;CGP v0.4.2&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;, a major milestone that significantly expands the expressive power of generic programming in Rust. With this release, CGP introduces full support for &lt;strong&gt;extensible records and variants&lt;&#x2F;strong&gt;, unlocking a range of new capabilities for developers working with highly modular and reusable code.&lt;&#x2F;p&gt;
&lt;p&gt;Extensible records and variants allow developers to write code that operates on &lt;em&gt;any struct containing specific fields&lt;&#x2F;em&gt; or &lt;em&gt;any enum containing specific variants&lt;&#x2F;em&gt;, without needing their concrete definition. This makes it possible to write truly generic and flexible logic that is decoupled from rigid type definitions.&lt;&#x2F;p&gt;
&lt;p&gt;In earlier versions, CGP already offered a foundational feature through the &lt;code&gt;HasField&lt;&#x2F;code&gt; trait, which made it possible to &lt;em&gt;read&lt;&#x2F;em&gt; a field from any struct that included it. With version 0.4.2, this functionality is dramatically extended. Not only can you now read fields, but you can also &lt;em&gt;construct&lt;&#x2F;em&gt; values onto these fields in a type-safe manner. More importantly, the same level of extensibility is now available for enums, enabling operations over variants in a similarly generic fashion.&lt;&#x2F;p&gt;
&lt;p&gt;This advancement introduces two powerful programming patterns that are now possible with CGP:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Extensible Builder Pattern&lt;&#x2F;strong&gt;: This pattern allows for modular construction of structs from independent sub-structs, each contributing specific fields. It enables highly composable and decoupled design in data construction.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Extensible Visitor Pattern&lt;&#x2F;strong&gt;: This pattern enables the modular deconstruction of enums, allowing independent components to handle different variants without requiring full knowledge of the entire enum definition. This effectively enables a modularized version of the &lt;em&gt;visitor pattern&lt;&#x2F;em&gt;, by allowing new variants to be handled by extensible visitors.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;For readers coming from more advanced programming languages, this development effectively brings the power of &lt;a href=&quot;https:&#x2F;&#x2F;wiki.haskell.org&#x2F;index.php?title=Generics&quot;&gt;&lt;strong&gt;datatype-generic programming&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;, &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Structural_type_system&quot;&gt;&lt;strong&gt;structural typing&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;, &lt;a href=&quot;https:&#x2F;&#x2F;book.purescript.org&#x2F;chapter4.html&quot;&gt;&lt;strong&gt;row polymorphism&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt; and &lt;a href=&quot;https:&#x2F;&#x2F;ocaml.org&#x2F;manual&#x2F;5.1&#x2F;polyvariant.html&quot;&gt;&lt;strong&gt;polymorphic variants&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt; to Rust. These are advanced type system features commonly found in languages like Haskell, PureScript and OCaml, and their availability in CGP represents a major leap in what is possible with the type system in Rust.&lt;&#x2F;p&gt;
&lt;p&gt;In addition, CGP v0.4.2 introduces support for safe &lt;strong&gt;upcasting and downcasting between enums&lt;&#x2F;strong&gt; that share a common subset of variants. This provides a foundation for writing extensible and evolvable APIs that remain compatible across different layers of abstraction or across independently maintained modules.&lt;&#x2F;p&gt;
&lt;p&gt;Here is a revised version of your “Content Organization” section, rewritten for clarity, flow, and consistency in tone and style. It maintains full sentences and should read naturally for Rust developers new to CGP:&lt;&#x2F;p&gt;
&lt;h1 id=&quot;series-overview&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#series-overview&quot; aria-label=&quot;Anchor link for: series-overview&quot;&gt;Series Overview&lt;&#x2F;a&gt;&lt;&#x2F;h1&gt;
&lt;p&gt;This article is the first in a five-part series exploring the examples and implementation of extensible data types in CGP. Below is an overview of what each part covers:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Part 1: Modular App Construction and Extensible Builders&lt;&#x2F;strong&gt; (this post) – In this introductory part, we present a high-level overview of the key features enabled by extensible data types. We then dive into a hands-on demonstration showing how extensible records can be used to build and compose modular builders for real-world applications.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a href=&quot;&#x2F;blog&#x2F;extensible-datatypes-part-2&quot;&gt;&lt;strong&gt;Part 2: Modular Interpreters and Extensible Visitors&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt; – This part continues the demonstration by introducing extensible variants. We use them to address the &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Expression_problem&quot;&gt;&lt;strong&gt;expression problem&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;, implementing a set of reusable interpreter components for a small toy language.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a href=&quot;&#x2F;blog&#x2F;extensible-datatypes-part-3&quot;&gt;&lt;strong&gt;Part 3: Implementing Extensible Records&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt; – Here, we walk through the internal mechanics behind extensible records. We show how CGP supports the modular builder pattern demonstrated in Part 1 through its underlying type and trait machinery.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a href=&quot;&#x2F;blog&#x2F;extensible-datatypes-part-4&quot;&gt;&lt;strong&gt;Part 4: Implementing Extensible Variants&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt; – This part mirrors Part 3, but for extensible variants. We examine how extensible variants are implemented, and compare the differences and similarities between extensible records and variants.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;feature-highlighs&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#feature-highlighs&quot; aria-label=&quot;Anchor link for: feature-highlighs&quot;&gt;Feature Highlighs&lt;&#x2F;a&gt;&lt;&#x2F;h1&gt;
&lt;h2 id=&quot;safe-enum-upcasting&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#safe-enum-upcasting&quot; aria-label=&quot;Anchor link for: safe-enum-upcasting&quot;&gt;Safe Enum Upcasting&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Let’s begin by looking at how CGP enables safe upcasting between enums. Imagine you have the following enum definition called &lt;code&gt;Shape&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[derive(HasFields, FromVariant, ExtractField)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub enum &lt;&#x2F;span&gt;&lt;span&gt;Shape {
&lt;&#x2F;span&gt;&lt;span&gt;    Circle(Circle),
&lt;&#x2F;span&gt;&lt;span&gt;    Rectangle(Rectangle),
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;You may also have a different &lt;code&gt;ShapePlus&lt;&#x2F;code&gt; enum, defined elsewhere, that represents a &lt;em&gt;superset&lt;&#x2F;em&gt; of the variants in &lt;code&gt;Shape&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[derive(HasFields, FromVariant, ExtractField)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub enum &lt;&#x2F;span&gt;&lt;span&gt;ShapePlus {
&lt;&#x2F;span&gt;&lt;span&gt;    Triangle(Triangle),
&lt;&#x2F;span&gt;&lt;span&gt;    Rectangle(Rectangle),
&lt;&#x2F;span&gt;&lt;span&gt;    Circle(Circle),
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;With CGP v0.4.2, it is now possible to &lt;em&gt;upcast&lt;&#x2F;em&gt; a &lt;code&gt;Shape&lt;&#x2F;code&gt; value into a &lt;code&gt;ShapePlus&lt;&#x2F;code&gt; value in fully safe Rust:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; shape = Shape::Circle(Circle { radius: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;5.0 &lt;&#x2F;span&gt;&lt;span&gt;});
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; shape_plus = shape.upcast(PhantomData::&amp;lt;ShapePlus&amp;gt;);
&lt;&#x2F;span&gt;&lt;span&gt;assert_eq!(shape_plus, ShapePlus::Circle(Circle { radius: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;5.0 &lt;&#x2F;span&gt;&lt;span&gt;}));
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This operation works by leveraging the derived CGP traits &lt;code&gt;HasFields&lt;&#x2F;code&gt;, &lt;code&gt;ExtractField&lt;&#x2F;code&gt;, and &lt;code&gt;FromVariant&lt;&#x2F;code&gt;. As long as the source enum’s variants are a subset of the target enum’s, CGP can automatically generate the logic required to lift the smaller enum into the larger one.&lt;&#x2F;p&gt;
&lt;p&gt;A particularly powerful aspect of this design is that the two enums do not need to know about each other. They can be defined in entirely separate crates, and the trait derivations are completely general. You don’t need to define any enum-specific conversion traits. This makes it possible to build libraries of reusable variant groups and compose them freely in application code.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;safe-enum-downcasting&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#safe-enum-downcasting&quot; aria-label=&quot;Anchor link for: safe-enum-downcasting&quot;&gt;Safe Enum Downcasting&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;In the reverse direction, CGP also supports &lt;em&gt;safe downcasting&lt;&#x2F;em&gt; from a larger enum to a smaller one that contains only a subset of its variants. Using the same &lt;code&gt;Shape&lt;&#x2F;code&gt; and &lt;code&gt;ShapePlus&lt;&#x2F;code&gt; enums, the following example demonstrates how this works:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; shape = ShapePlus::Circle(Circle { radius: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;5.0 &lt;&#x2F;span&gt;&lt;span&gt;});
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;assert_eq!(
&lt;&#x2F;span&gt;&lt;span&gt;    shape.downcast(PhantomData::&amp;lt;Shape&amp;gt;).ok(),
&lt;&#x2F;span&gt;&lt;span&gt;    Some(Shape::Circle(Circle { radius: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;5.0 &lt;&#x2F;span&gt;&lt;span&gt;}))
&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Like &lt;code&gt;upcast&lt;&#x2F;code&gt;, this &lt;code&gt;downcast&lt;&#x2F;code&gt; method relies on the same set of derived CGP traits and works for any pair of compatible enums. The operation returns a &lt;code&gt;Result&lt;&#x2F;code&gt;, where the &lt;code&gt;Ok&lt;&#x2F;code&gt; variant contains the downcasted value, and the &lt;code&gt;Err&lt;&#x2F;code&gt; variant carries the unhandled remainder of the original enum.&lt;&#x2F;p&gt;
&lt;p&gt;In the example above, we use &lt;code&gt;.ok()&lt;&#x2F;code&gt; to simplify the comparison, but in practice, the &lt;code&gt;Err&lt;&#x2F;code&gt; case contains useful remainder value that can be further examined or downcasted again.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;safe-exhaustive-downcasting&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#safe-exhaustive-downcasting&quot; aria-label=&quot;Anchor link for: safe-exhaustive-downcasting&quot;&gt;Safe Exhaustive Downcasting&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;One of the unique capabilities CGP provides is the ability to &lt;em&gt;exhaustively downcast&lt;&#x2F;em&gt; an enum, step by step, until all possible variants are handled. This pattern becomes especially useful when working with generic enums in extensible APIs, where the concrete enum definition is unknown or evolving.&lt;&#x2F;p&gt;
&lt;p&gt;To demonstrate this, suppose we define another enum to represent the remaining &lt;code&gt;Triangle&lt;&#x2F;code&gt; variant:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[derive(HasFields, ExtractField, FromVariant)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub enum &lt;&#x2F;span&gt;&lt;span&gt;TriangleOnly {
&lt;&#x2F;span&gt;&lt;span&gt;    Triangle(Triangle),
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now, the combination of &lt;code&gt;Shape&lt;&#x2F;code&gt; and &lt;code&gt;TriangleOnly&lt;&#x2F;code&gt; covers the entire set of variants from &lt;code&gt;ShapePlus&lt;&#x2F;code&gt;. We can use this setup to exhaustively handle all possible cases, while staying entirely within the bounds of safe Rust:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; shape_plus = ShapePlus::Triangle(Triangle {
&lt;&#x2F;span&gt;&lt;span&gt;    base: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;3.0&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    height: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;4.0&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;});
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; area = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;match&lt;&#x2F;span&gt;&lt;span&gt; shape_plus.downcast(PhantomData::&amp;lt;Shape&amp;gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;    Ok(shape) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; match&lt;&#x2F;span&gt;&lt;span&gt; shape {
&lt;&#x2F;span&gt;&lt;span&gt;        Shape::Circle(circle) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;PI &lt;&#x2F;span&gt;&lt;span&gt;* circle.radius * circle.radius,
&lt;&#x2F;span&gt;&lt;span&gt;        Shape::Rectangle(rectangle) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt; rectangle.width * rectangle.height,
&lt;&#x2F;span&gt;&lt;span&gt;    },
&lt;&#x2F;span&gt;&lt;span&gt;    Err(remainder) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; match&lt;&#x2F;span&gt;&lt;span&gt; remainder.downcast_fields(PhantomData::&amp;lt;TriangleOnly&amp;gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;        Ok(TriangleOnly::Triangle(triangle)) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt; triangle.base * triangle.height &#x2F; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;2.0&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    },
&lt;&#x2F;span&gt;&lt;span&gt;};
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In this example, we first attempt to downcast into &lt;code&gt;Shape&lt;&#x2F;code&gt;. If that fails, the remainder is passed to &lt;code&gt;downcast_fields&lt;&#x2F;code&gt;, which attempts to further downcast to &lt;code&gt;TriangleOnly&lt;&#x2F;code&gt;. When all variants are properly handled, Rust automatically knows that there is no variant left to be handled, and we can safely omit the final &lt;code&gt;Err&lt;&#x2F;code&gt; case.&lt;&#x2F;p&gt;
&lt;p&gt;At first glance, this approach may appear more complex than simply matching against the original enum directly. However, its true strength lies in its &lt;strong&gt;generality&lt;&#x2F;strong&gt;. With CGP’s downcasting mechanism, you can pattern match over generic enum types without knowing their full structure in advance. This enables highly extensible and type-safe designs where variants can be added or removed modularly, without breaking existing logic.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;safe-struct-building&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#safe-struct-building&quot; aria-label=&quot;Anchor link for: safe-struct-building&quot;&gt;Safe Struct Building&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Just as CGP enables safe, composable deconstruction of enums, it also brings &lt;strong&gt;extensible construction&lt;&#x2F;strong&gt; to structs. This is achieved through a form of structural merging, where smaller structs can be incrementally combined into larger ones. The result is a flexible and modular approach to building complex data types, well-suited for highly decoupled or plugin-style architectures.&lt;&#x2F;p&gt;
&lt;p&gt;To illustrate this, let’s take the example of a &lt;code&gt;Employee&lt;&#x2F;code&gt; struct:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[derive(HasFields, BuildField)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;Employee {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;employee_id: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u64&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;first_name: String,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;last_name: String,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Suppose we also define two smaller structs — &lt;code&gt;Person&lt;&#x2F;code&gt; and &lt;code&gt;EmployeeId&lt;&#x2F;code&gt; — each containing a subset of the fields in &lt;code&gt;Employee&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[derive(HasFields, BuildField)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;Person {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;first_name: String,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;last_name: String,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[derive(HasFields, BuildField)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;EmployeeId {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;employee_id: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u64&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;With CGP, we can now construct a &lt;code&gt;Employee&lt;&#x2F;code&gt; value in a modular and extensible way, by composing these smaller building blocks:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; person = Person {
&lt;&#x2F;span&gt;&lt;span&gt;    first_name: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;John&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;.to_owned(),
&lt;&#x2F;span&gt;&lt;span&gt;    last_name: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Smith&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;.to_owned(),
&lt;&#x2F;span&gt;&lt;span&gt;};
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; employee_id = EmployeeId { employee_id: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1 &lt;&#x2F;span&gt;&lt;span&gt;};
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; employee = Employee::builder()
&lt;&#x2F;span&gt;&lt;span&gt;    .build_from(person)
&lt;&#x2F;span&gt;&lt;span&gt;    .build_from(employee_id)
&lt;&#x2F;span&gt;&lt;span&gt;    .finalize_build();
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Here’s what’s happening: The &lt;code&gt;builder()&lt;&#x2F;code&gt; method on &lt;code&gt;Employee&lt;&#x2F;code&gt; initiates a &lt;em&gt;partial record&lt;&#x2F;em&gt; builder, an intermediate structure that initially contains none of the target fields. Each call to &lt;code&gt;build_from&lt;&#x2F;code&gt; takes a struct that contributes one or more of the remaining fields and returns a new builder with those fields filled in. Once all required fields have been supplied, the &lt;code&gt;finalize_build()&lt;&#x2F;code&gt; method consumes the builder and produces a fully constructed &lt;code&gt;Employee&lt;&#x2F;code&gt; instance.&lt;&#x2F;p&gt;
&lt;p&gt;Just like enum upcasting and downcasting, the struct builder is implemented entirely in &lt;strong&gt;safe&lt;&#x2F;strong&gt;, &lt;strong&gt;panic-free&lt;&#x2F;strong&gt; Rust. There’s no runtime reflection or unsafe code involved. The only requirement is that the participating structs must have compatible fields and derive the CGP-provided traits &lt;code&gt;HasFields&lt;&#x2F;code&gt; and &lt;code&gt;BuildField&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Moreover, this system is completely decoupled from specific struct definitions. The individual component structs — &lt;code&gt;Person&lt;&#x2F;code&gt;, &lt;code&gt;EmployeeId&lt;&#x2F;code&gt;, and &lt;code&gt;Employee&lt;&#x2F;code&gt; — can be defined in separate crates, with no awareness of each other. Once the CGP traits are derived, they become interoperable through structural field compatibility alone.&lt;&#x2F;p&gt;
&lt;p&gt;While this example may seem trivial — after all, constructing &lt;code&gt;Employee&lt;&#x2F;code&gt; directly is straightforward — it serves as a foundation for much more powerful generic abstractions. As you’ll see in the upcoming sections, the builder pattern opens the door to writing highly reusable, type-safe logic that can construct &lt;strong&gt;generic types&lt;&#x2F;strong&gt; without ever referencing their concrete types. This makes it possible to write libraries or plugins that contribute data to a shared structure without tight coupling or dependency on a central type definition.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;motivation-for-extensible-builders&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#motivation-for-extensible-builders&quot; aria-label=&quot;Anchor link for: motivation-for-extensible-builders&quot;&gt;Motivation for Extensible Builders&lt;&#x2F;a&gt;&lt;&#x2F;h1&gt;
&lt;p&gt;To understand how extensible records enable modular builders, let’s explore a practical use case: constructing an application context from configuration inputs.&lt;&#x2F;p&gt;
&lt;p&gt;Imagine we’re building an API client for our application. The application context needs to include an SQLite database connection and an HTTP client. A typical way to model this in Rust would be to define a struct like the following:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_context]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;App {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;sqlite_pool: SqlitePool,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;http_client: Client,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This &lt;code&gt;App&lt;&#x2F;code&gt; struct holds a &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;sqlx&#x2F;latest&#x2F;sqlx&#x2F;sqlite&#x2F;type.SqlitePool.html&quot;&gt;&lt;code&gt;SqlitePool&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; from the &lt;code&gt;sqlx&lt;&#x2F;code&gt; crate, and an HTTP &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;reqwest&#x2F;latest&#x2F;reqwest&#x2F;struct.Client.html&quot;&gt;&lt;code&gt;Client&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; from &lt;code&gt;reqwest&lt;&#x2F;code&gt;. To construct this context, we might implement a &lt;code&gt;new&lt;&#x2F;code&gt; function as follows:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;App {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub&lt;&#x2F;span&gt;&lt;span&gt; async &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;new(db_path: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;str&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; Result&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self&lt;&#x2F;span&gt;&lt;span&gt;, Error&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; http_client = Client::new();
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; sqlite_pool = SqlitePool::connect(db_path).await&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;?&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        Ok(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            http_client,
&lt;&#x2F;span&gt;&lt;span&gt;            sqlite_pool,
&lt;&#x2F;span&gt;&lt;span&gt;        })
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This constructor is asynchronous and returns a &lt;code&gt;Result&amp;lt;App, Error&amp;gt;&lt;&#x2F;code&gt;. It creates a default &lt;code&gt;Client&lt;&#x2F;code&gt; using &lt;code&gt;reqwest&lt;&#x2F;code&gt;, connects to the database using the provided path, and assembles both into an &lt;code&gt;App&lt;&#x2F;code&gt; struct.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;adding-ai-capabilities-to-app&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#adding-ai-capabilities-to-app&quot; aria-label=&quot;Anchor link for: adding-ai-capabilities-to-app&quot;&gt;Adding AI Capabilities to &lt;code&gt;App&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;At this point, the constructor looks simple. But in a real-world setting, it’s rarely that clean. Suppose the product team now wants to integrate AI capabilities into the application. To support this, we decide to use an LLM service like ChatGPT and extend the &lt;code&gt;App&lt;&#x2F;code&gt; struct accordingly:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_context]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;App {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;sqlite_pool: SqlitePool,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;http_client: Client,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;open_ai_client: openai::Client,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;open_ai_agent: Agent&amp;lt;openai::CompletionModel&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In this updated version, we introduce two new fields: &lt;code&gt;open_ai_client&lt;&#x2F;code&gt;, which is used to communicate with the OpenAI API, and &lt;code&gt;open_ai_agent&lt;&#x2F;code&gt;, which encapsulates a configured agent that can perform conversational tasks using a model like GPT-4o using &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;rig-core&#x2F;latest&#x2F;rig&#x2F;index.html&quot;&gt;&lt;code&gt;rig&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;The &lt;code&gt;new&lt;&#x2F;code&gt; constructor must now also handle the initialization logic for these fields:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;App {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub&lt;&#x2F;span&gt;&lt;span&gt; async &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;new(db_path: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;str&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; Result&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self&lt;&#x2F;span&gt;&lt;span&gt;, Error&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; http_client = Client::new();
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; sqlite_pool = SqlitePool::connect(db_path).await&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;?&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; open_ai_client = openai::Client::from_env();
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; open_ai_agent = open_ai_client.agent(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;gpt-4o&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;).build();
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        Ok(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            http_client,
&lt;&#x2F;span&gt;&lt;span&gt;            sqlite_pool,
&lt;&#x2F;span&gt;&lt;span&gt;            open_ai_client,
&lt;&#x2F;span&gt;&lt;span&gt;            open_ai_agent,
&lt;&#x2F;span&gt;&lt;span&gt;        })
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Here, we initialize the OpenAI client using environment variables, and then build an agent configured for the &lt;code&gt;gpt-4o&lt;&#x2F;code&gt; model. These values are added alongside the existing HTTP and database clients.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;from-simple-to-complex&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#from-simple-to-complex&quot; aria-label=&quot;Anchor link for: from-simple-to-complex&quot;&gt;From Simple to Complex&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Even with these additions, our constructor remains relatively manageable. However, as often happens in production, the requirements grow—and so does the configuration logic. Let’s imagine a more realistic version of this &lt;code&gt;new&lt;&#x2F;code&gt; function:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;App {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub&lt;&#x2F;span&gt;&lt;span&gt; async &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;new(
&lt;&#x2F;span&gt;&lt;span&gt;        db_options: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;str&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        db_journal_mode: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;str&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        http_user_agent: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;str&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        open_ai_key: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;str&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        open_ai_model: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;str&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        llm_preamble: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;str&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    ) -&amp;gt; Result&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self&lt;&#x2F;span&gt;&lt;span&gt;, Error&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; journal_mode = SqliteJournalMode::from_str(db_journal_mode)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;?&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; db_options = SqliteConnectOptions::from_str(db_options)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;?&lt;&#x2F;span&gt;&lt;span&gt;.journal_mode(journal_mode);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; sqlite_pool = SqlitePool::connect_with(db_options).await&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;?&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; http_client = Client::builder()
&lt;&#x2F;span&gt;&lt;span&gt;            .user_agent(http_user_agent)
&lt;&#x2F;span&gt;&lt;span&gt;            .connect_timeout(Duration::from_secs(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;5&lt;&#x2F;span&gt;&lt;span&gt;))
&lt;&#x2F;span&gt;&lt;span&gt;            .build()&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;?&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; open_ai_client = openai::Client::new(open_ai_key);
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; open_ai_agent = open_ai_client
&lt;&#x2F;span&gt;&lt;span&gt;            .agent(open_ai_model)
&lt;&#x2F;span&gt;&lt;span&gt;            .preamble(llm_preamble)
&lt;&#x2F;span&gt;&lt;span&gt;            .build();
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        Ok(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            open_ai_client,
&lt;&#x2F;span&gt;&lt;span&gt;            open_ai_agent,
&lt;&#x2F;span&gt;&lt;span&gt;            sqlite_pool,
&lt;&#x2F;span&gt;&lt;span&gt;            http_client,
&lt;&#x2F;span&gt;&lt;span&gt;        })
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This constructor now handles &lt;em&gt;five&lt;&#x2F;em&gt; separate input parameters, each contributing to the configuration of different parts of the application. It creates a &lt;code&gt;SqliteConnectOptions&lt;&#x2F;code&gt; object to configure the database with the specified journal mode. The HTTP client is set up with a custom user agent and a longer timeout. The AI client is initialized using an explicit API key, and the agent is constructed with a custom model and preamble.&lt;&#x2F;p&gt;
&lt;p&gt;While none of these steps are especially difficult on their own, the function is starting to grow in complexity. It’s also becoming more &lt;strong&gt;fragile&lt;&#x2F;strong&gt;, as all responsibilities are bundled into one place. Every change to a single subsystem — whether it’s database, HTTP, or AI — requires editing the same constructor.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;why-modular-constructor-matters&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#why-modular-constructor-matters&quot; aria-label=&quot;Anchor link for: why-modular-constructor-matters&quot;&gt;Why Modular Constructor Matters&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;As we&#x27;ve seen in the previous example, even modest configurability can cause a constructor&#x27;s complexity to grow rapidly. With just a few additional fields or customization options, the function becomes harder to maintain, test, and reason about.&lt;&#x2F;p&gt;
&lt;p&gt;In many cases, there&#x27;s no single “correct” way to construct an application context. For example, you might want to retain both versions of the &lt;code&gt;new&lt;&#x2F;code&gt; constructor from earlier: a minimal one for unit tests with default values, and a more elaborate, configurable one for production. In fact, it&#x27;s common for different parts of an application to require different levels of configurability—some using defaults, others requiring fine-grained setup.&lt;&#x2F;p&gt;
&lt;p&gt;To manage this complexity, Rust developers often reach for the &lt;a href=&quot;https:&#x2F;&#x2F;rust-unofficial.github.io&#x2F;patterns&#x2F;patterns&#x2F;creational&#x2F;builder.html&quot;&gt;&lt;em&gt;builder pattern&lt;&#x2F;em&gt;&lt;&#x2F;a&gt;. This involves creating a separate builder struct, typically with optional or defaultable fields and fluent setter methods. The builder is used to gradually assemble values before producing the final struct.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;challenges-for-modular-builders&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#challenges-for-modular-builders&quot; aria-label=&quot;Anchor link for: challenges-for-modular-builders&quot;&gt;Challenges for Modular Builders&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;The traditional builder pattern works, but it comes with serious limitations — especially when extensibility and modularity are important.&lt;&#x2F;p&gt;
&lt;p&gt;The first limitation is &lt;strong&gt;tight coupling&lt;&#x2F;strong&gt;. A builder is usually tied directly to a specific target struct. If you create a new context that’s only slightly different from an existing one, you often have to duplicate the entire builder implementation, even if most of the logic is the same.&lt;&#x2F;p&gt;
&lt;p&gt;Second, builders are typically &lt;strong&gt;non-extensible&lt;&#x2F;strong&gt;. If you want to extend the construction logic — say, by adding a new step to initialize an additional field — you usually have to modify the original builder struct. This makes it hard to share construction logic across crates or teams without exposing internal implementation details.&lt;&#x2F;p&gt;
&lt;p&gt;The root cause of these problems is that struct construction in Rust typically requires direct access to the &lt;strong&gt;concrete type&lt;&#x2F;strong&gt;. That means the builder must know the exact shape of the final struct and have access to all its field values up front. If you need intermediate values or want to plug in custom build steps, those values must be manually threaded through the builder and its state.&lt;&#x2F;p&gt;
&lt;p&gt;This rigidity makes it difficult to define reusable, composable building blocks—especially in large or evolving codebases.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;modular-builders-with-cgp&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#modular-builders-with-cgp&quot; aria-label=&quot;Anchor link for: modular-builders-with-cgp&quot;&gt;Modular Builders with CGP&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Earlier versions of CGP also ran into these limitations. When writing &lt;em&gt;context-generic&lt;&#x2F;em&gt; code, we wanted to construct structs in a way that didn’t require knowing their concrete types ahead of time. But because Rust structs require all field values to be present simultaneously at construction time, we couldn’t easily implement flexible or reusable context-generic constructors.&lt;&#x2F;p&gt;
&lt;p&gt;With the latest release, that limitation is fully resolved.&lt;&#x2F;p&gt;
&lt;p&gt;CGP now supports &lt;strong&gt;modular, extensible struct builders&lt;&#x2F;strong&gt; that can be composed from smaller, independent parts. Each module can define how to build a piece of a context struct, and the builder automatically merges them — without needing to know the final shape of the struct ahead of time.&lt;&#x2F;p&gt;
&lt;p&gt;This opens the door to a new style of constructor logic: one that is &lt;strong&gt;modular&lt;&#x2F;strong&gt;, &lt;strong&gt;composable&lt;&#x2F;strong&gt;, and &lt;strong&gt;context-generic&lt;&#x2F;strong&gt;. You can define builders for individual subsystems (e.g., database, HTTP client, AI agent), and combine them to build any compatible application context.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;extensible-builders&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#extensible-builders&quot; aria-label=&quot;Anchor link for: extensible-builders&quot;&gt;Extensible Builders&lt;&#x2F;a&gt;&lt;&#x2F;h1&gt;
&lt;p&gt;In this section, we’ll revisit the constructor examples we’ve already seen — and show how to rewrite them using CGP’s new builder pattern to achieve clean, modular, and reusable construction logic. A full version of the example code covered in this section is available on our &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;contextgeneric&#x2F;cgp-examples&#x2F;tree&#x2F;main&#x2F;builder&quot;&gt;GitHub repository&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;modular-sqlite-builder&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#modular-sqlite-builder&quot; aria-label=&quot;Anchor link for: modular-sqlite-builder&quot;&gt;Modular SQLite Builder&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Let’s now explore how to implement modular construction of the &lt;code&gt;App&lt;&#x2F;code&gt; context using multiple CGP providers. We’ll start by defining a default SQLite builder provider using CGP&#x27;s &lt;code&gt;Handler&lt;&#x2F;code&gt; component:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_new_provider]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;Build, Code: Send, Input: Send&amp;gt; Handler&amp;lt;Build, Code, Input&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;BuildDefaultSqliteClient
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;    Build: HasSqlitePath + CanRaiseAsyncError&amp;lt;sqlx::Error&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Output &lt;&#x2F;span&gt;&lt;span&gt;= SqliteClient;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    async &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;handle(
&lt;&#x2F;span&gt;&lt;span&gt;        build: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;Build,
&lt;&#x2F;span&gt;&lt;span&gt;        _code: PhantomData&amp;lt;Code&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        _input: Input,
&lt;&#x2F;span&gt;&lt;span&gt;    ) -&amp;gt; Result&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;Output, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Build::&lt;&#x2F;span&gt;&lt;span&gt;Error&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; sqlite_pool = SqlitePool::connect(build.db_path())
&lt;&#x2F;span&gt;&lt;span&gt;            .await
&lt;&#x2F;span&gt;&lt;span&gt;            .map_err(Build::raise_error)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;?&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        Ok(SqliteClient { sqlite_pool })
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In this example, we define &lt;code&gt;BuildDefaultSqliteClient&lt;&#x2F;code&gt; as a CGP provider that implements the &lt;code&gt;Handler&lt;&#x2F;code&gt; component. This is the same &lt;code&gt;Handler&lt;&#x2F;code&gt; trait we introduced in &lt;a href=&quot;&#x2F;blog&#x2F;hypershell-release&#x2F;#handler-component&quot;&gt;Hypershell&lt;&#x2F;a&gt;, where it was used to power shell-like pipelines. Here, we repurpose the same trait to construct modular context components. This demonstrates how general-purpose the &lt;code&gt;Handler&lt;&#x2F;code&gt; trait is — it can be used for pipelines, API handlers, visitors, and now, context builders.&lt;&#x2F;p&gt;
&lt;p&gt;The &lt;code&gt;Build&lt;&#x2F;code&gt; type parameter refers to a generic &lt;strong&gt;builder context&lt;&#x2F;strong&gt;, not the final &lt;code&gt;App&lt;&#x2F;code&gt; struct. This context includes the inputs required to construct a &lt;code&gt;SqliteClient&lt;&#x2F;code&gt;. In this case, the builder must be able to provide a database path, as well as a way to raise errors from &lt;code&gt;sqlx&lt;&#x2F;code&gt;. These requirements are expressed through the &lt;code&gt;HasSqlitePath&lt;&#x2F;code&gt; and &lt;code&gt;CanRaiseAsyncError&lt;&#x2F;code&gt; constraints.&lt;&#x2F;p&gt;
&lt;p&gt;The &lt;code&gt;HasSqlitePath&lt;&#x2F;code&gt; trait is defined as follows:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_auto_getter]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;HasSqlitePath {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;db_path(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;str&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;By marking the trait with &lt;a href=&quot;https:&#x2F;&#x2F;patterns.contextgeneric.dev&#x2F;generic-accessor-providers.html#the-cgp_auto_getter-macro&quot;&gt;&lt;code&gt;#[cgp_auto_getter]&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;, CGP can automatically implement this trait for any builder context that contains a &lt;code&gt;db_path&lt;&#x2F;code&gt; field of type &lt;code&gt;String&lt;&#x2F;code&gt;. This automatic implementation reduces boilerplate and ensures that any context with the appropriate fields can satisfy the trait bounds.&lt;&#x2F;p&gt;
&lt;p&gt;Although our example does not make use of the &lt;code&gt;Code&lt;&#x2F;code&gt; or &lt;code&gt;Input&lt;&#x2F;code&gt; parameters, they remain part of the &lt;code&gt;Handler&lt;&#x2F;code&gt; signature. The &lt;code&gt;Code&lt;&#x2F;code&gt; parameter may be used for &lt;em&gt;compile-time options&lt;&#x2F;em&gt; that allow contexts to be constructed in multiple ways. Meanwhile, &lt;code&gt;Input&lt;&#x2F;code&gt; typically refers to the &lt;strong&gt;partial&lt;&#x2F;strong&gt; value of the final struct being built. These capabilities are useful in more advanced scenarios, but we will leave their explanation for a later section.&lt;&#x2F;p&gt;
&lt;p&gt;In this implementation, the &lt;code&gt;handle&lt;&#x2F;code&gt; method simply connects to the SQLite database using the provided path, wraps the resulting pool in a &lt;code&gt;SqliteClient&lt;&#x2F;code&gt; struct, and returns it. The &lt;code&gt;SqliteClient&lt;&#x2F;code&gt; is defined as:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[derive(HasField, HasFields, BuildField)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;SqliteClient {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;sqlite_pool: SqlitePool,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This struct acts as a wrapper around &lt;code&gt;SqlitePool&lt;&#x2F;code&gt; and serves as the output of our modular builder. Although &lt;code&gt;BuildDefaultSqliteClient&lt;&#x2F;code&gt; does not build the full &lt;code&gt;App&lt;&#x2F;code&gt; context, we can merge its output into &lt;code&gt;App&lt;&#x2F;code&gt; using CGP’s &lt;code&gt;build_from&lt;&#x2F;code&gt; mechanism we covered earlier. Deriving &lt;code&gt;HasField&lt;&#x2F;code&gt;, &lt;code&gt;HasFields&lt;&#x2F;code&gt;, and &lt;code&gt;BuildField&lt;&#x2F;code&gt; on &lt;code&gt;SqliteClient&lt;&#x2F;code&gt; allows it to be safely and automatically merged into the final context during composition.&lt;&#x2F;p&gt;
&lt;p&gt;At this point, you might be wondering why so much infrastructure is needed just to call &lt;code&gt;SqlitePool::connect&lt;&#x2F;code&gt;. The answer is that, while this example is simple, real-world construction logic can be much more complex. By encapsulating each part of the logic into modular components, we gain flexibility, reusability, and testability.&lt;&#x2F;p&gt;
&lt;p&gt;To demonstrate this flexibility, consider a more complex version of the SQLite builder. This version uses connection options and journal mode configuration rather than a simple path string:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_new_provider]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;Build, Code: Send, Input: Send&amp;gt; Handler&amp;lt;Build, Code, Input&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;BuildSqliteClient
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;    Build: HasSqliteOptions + CanRaiseAsyncError&amp;lt;sqlx::Error&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Output &lt;&#x2F;span&gt;&lt;span&gt;= SqliteClient;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    async &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;handle(
&lt;&#x2F;span&gt;&lt;span&gt;        build: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;Build,
&lt;&#x2F;span&gt;&lt;span&gt;        _code: PhantomData&amp;lt;Code&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        _input: Input,
&lt;&#x2F;span&gt;&lt;span&gt;    ) -&amp;gt; Result&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;Output, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Build::&lt;&#x2F;span&gt;&lt;span&gt;Error&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; journal_mode =
&lt;&#x2F;span&gt;&lt;span&gt;            SqliteJournalMode::from_str(build.db_journal_mode()).map_err(Build::raise_error)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;?&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; db_options = SqliteConnectOptions::from_str(build.db_options())
&lt;&#x2F;span&gt;&lt;span&gt;            .map_err(Build::raise_error)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;?
&lt;&#x2F;span&gt;&lt;span&gt;            .journal_mode(journal_mode);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; sqlite_pool = SqlitePool::connect_with(db_options)
&lt;&#x2F;span&gt;&lt;span&gt;            .await
&lt;&#x2F;span&gt;&lt;span&gt;            .map_err(Build::raise_error)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;?&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        Ok(SqliteClient { sqlite_pool })
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[cgp_auto_getter]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;HasSqliteOptions {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;db_options(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;str&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;db_journal_mode(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;str&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In this version, &lt;code&gt;BuildSqliteClient&lt;&#x2F;code&gt; constructs a &lt;code&gt;SqliteClient&lt;&#x2F;code&gt; using fully configurable connection options. The &lt;code&gt;Build&lt;&#x2F;code&gt; context must now implement &lt;code&gt;HasSqliteOptions&lt;&#x2F;code&gt;, a trait that provides both the connection URI and the desired journal mode.&lt;&#x2F;p&gt;
&lt;p&gt;This example illustrates the key advantage of modular builders: the builder logic is entirely &lt;strong&gt;decoupled&lt;&#x2F;strong&gt; from the context itself. If we want to use &lt;code&gt;BuildDefaultSqliteClient&lt;&#x2F;code&gt;, we can define a simple builder context with just a &lt;code&gt;db_path&lt;&#x2F;code&gt; field. If we switch to &lt;code&gt;BuildSqliteClient&lt;&#x2F;code&gt;, we only need to provide a different context that includes &lt;code&gt;db_options&lt;&#x2F;code&gt; and &lt;code&gt;db_journal_mode&lt;&#x2F;code&gt;. All other components of the builder can remain unchanged.&lt;&#x2F;p&gt;
&lt;p&gt;Thanks to this decoupling, we can easily swap in different builder providers depending on the needs of the environment — be it development, testing, or production — without rewriting the entire construction logic. This modularity makes CGP builders highly scalable and adaptable to real-world applications.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;http-client-builder&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#http-client-builder&quot; aria-label=&quot;Anchor link for: http-client-builder&quot;&gt;HTTP Client Builder&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Just as we modularized the construction of the SQLite client, we can also define a modular builder for an HTTP client using CGP. In this case, we will construct a custom &lt;code&gt;reqwest&lt;&#x2F;code&gt; client with specific configuration options. To keep the focus on advanced use cases, we will skip the simpler version and go directly to the more complex construction logic.&lt;&#x2F;p&gt;
&lt;p&gt;The HTTP client builder is implemented as follows:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_new_provider]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;Build, Code: Send, Input: Send&amp;gt; Handler&amp;lt;Build, Code, Input&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;BuildHttpClient
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;    Build: HasHttpClientConfig + CanRaiseAsyncError&amp;lt;reqwest::Error&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Output &lt;&#x2F;span&gt;&lt;span&gt;= HttpClient;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    async &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;handle(
&lt;&#x2F;span&gt;&lt;span&gt;        build: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;Build,
&lt;&#x2F;span&gt;&lt;span&gt;        _code: PhantomData&amp;lt;Code&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        _input: Input,
&lt;&#x2F;span&gt;&lt;span&gt;    ) -&amp;gt; Result&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;Output, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Build::&lt;&#x2F;span&gt;&lt;span&gt;Error&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; http_client = Client::builder()
&lt;&#x2F;span&gt;&lt;span&gt;            .user_agent(build.http_user_agent())
&lt;&#x2F;span&gt;&lt;span&gt;            .connect_timeout(Duration::from_secs(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;5&lt;&#x2F;span&gt;&lt;span&gt;))
&lt;&#x2F;span&gt;&lt;span&gt;            .build()
&lt;&#x2F;span&gt;&lt;span&gt;            .map_err(Build::raise_error)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;?&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        Ok(HttpClient { http_client })
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This provider, &lt;code&gt;BuildHttpClient&lt;&#x2F;code&gt;, is structured very similarly to &lt;code&gt;BuildSqliteClient&lt;&#x2F;code&gt;. It implements the &lt;code&gt;Handler&lt;&#x2F;code&gt; trait and defines &lt;code&gt;HttpClient&lt;&#x2F;code&gt; as its output. The &lt;code&gt;Build&lt;&#x2F;code&gt; context is required to implement two traits: &lt;code&gt;HasHttpClientConfig&lt;&#x2F;code&gt;, which supplies the necessary configuration values, and &lt;code&gt;CanRaiseAsyncError&amp;lt;reqwest::Error&amp;gt;&lt;&#x2F;code&gt;, which allows the context to convert &lt;code&gt;reqwest&lt;&#x2F;code&gt; errors into its own error type.&lt;&#x2F;p&gt;
&lt;p&gt;The required configuration is minimal. In this case, we only need a user agent string, which is defined through the following trait:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_auto_getter]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;HasHttpClientConfig {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;http_user_agent(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;str&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;As with the previous examples, the &lt;code&gt;#[cgp_auto_getter]&lt;&#x2F;code&gt; macro ensures that this trait is automatically implemented for any context that includes a &lt;code&gt;http_user_agent&lt;&#x2F;code&gt; field.&lt;&#x2F;p&gt;
&lt;p&gt;The output of this builder is a simple wrapper around &lt;code&gt;reqwest::Client&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[derive(HasField, HasFields, BuildField)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;HttpClient {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;http_client: Client,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Here again, we derive &lt;code&gt;HasField&lt;&#x2F;code&gt;, &lt;code&gt;HasFields&lt;&#x2F;code&gt;, and &lt;code&gt;BuildField&lt;&#x2F;code&gt; to support field merging into the final context later on. This makes the &lt;code&gt;HttpClient&lt;&#x2F;code&gt; output compatible with CGP’s &lt;code&gt;build_from&lt;&#x2F;code&gt; mechanism, allowing it to be composed with other builder outputs.&lt;&#x2F;p&gt;
&lt;p&gt;The &lt;code&gt;handle&lt;&#x2F;code&gt; method creates a new &lt;code&gt;reqwest::Client&lt;&#x2F;code&gt; using the client builder from &lt;code&gt;reqwest&lt;&#x2F;code&gt;. It sets the user agent using a value from the context, and specifies a connection timeout of five seconds. The constructed client is then wrapped in the &lt;code&gt;HttpClient&lt;&#x2F;code&gt; struct and returned.&lt;&#x2F;p&gt;
&lt;p&gt;Although this example remains relatively simple, it illustrates how each field or component in a context can be modularly constructed using dedicated builder logic. Each builder is independently defined, type-safe, and reusable. If the way we configure our HTTP client changes — for example, if we want to support proxies or TLS settings — we can define a new provider that implements a different construction strategy, without needing to change any of the other components in our application context.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;combined-sqlite-and-http-client-builder&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#combined-sqlite-and-http-client-builder&quot; aria-label=&quot;Anchor link for: combined-sqlite-and-http-client-builder&quot;&gt;Combined SQLite and HTTP Client Builder&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Before we move on, it is important to emphasize that CGP does &lt;strong&gt;not&lt;&#x2F;strong&gt; require you to break down the construction logic of every component in your application context into separate builders. While the modular approach can offer more flexibility and reuse, you are entirely free to combine multiple construction tasks into a single provider if that better suits your needs.&lt;&#x2F;p&gt;
&lt;p&gt;For example, here is how you might implement a single builder that constructs &lt;em&gt;both&lt;&#x2F;em&gt; the SQLite client and the HTTP client together:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_new_provider]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;Build, Code: Send, Input: Send&amp;gt; Handler&amp;lt;Build, Code, Input&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;BuildDefaultSqliteAndHttpClient
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;    Build: HasSqlitePath + CanRaiseAsyncError&amp;lt;sqlx::Error&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Output &lt;&#x2F;span&gt;&lt;span&gt;= SqliteAndHttpClient;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    async &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;handle(
&lt;&#x2F;span&gt;&lt;span&gt;        build: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;Build,
&lt;&#x2F;span&gt;&lt;span&gt;        _code: PhantomData&amp;lt;Code&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        _input: Input,
&lt;&#x2F;span&gt;&lt;span&gt;    ) -&amp;gt; Result&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;Output, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Build::&lt;&#x2F;span&gt;&lt;span&gt;Error&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; sqlite_pool = SqlitePool::connect(build.db_path())
&lt;&#x2F;span&gt;&lt;span&gt;            .await
&lt;&#x2F;span&gt;&lt;span&gt;            .map_err(Build::raise_error)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;?&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; http_client = Client::new();
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        Ok(SqliteAndHttpClient { sqlite_pool, http_client })
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[derive(HasField, HasFields, BuildField)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;SqliteAndHttpClient {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;sqlite_pool: SqlitePool,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;http_client: Client,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In this implementation, we define a single provider &lt;code&gt;BuildDefaultSqliteAndHttpClient&lt;&#x2F;code&gt; that returns a combined struct &lt;code&gt;SqliteAndHttpClient&lt;&#x2F;code&gt;, which contains both a &lt;code&gt;SqlitePool&lt;&#x2F;code&gt; and a &lt;code&gt;reqwest::Client&lt;&#x2F;code&gt;. The construction logic is written in one place, which can be convenient when these components are always used together or when their configuration is tightly integrated.&lt;&#x2F;p&gt;
&lt;p&gt;However, the tradeoff of this approach is that it reduces flexibility. This tight coupling can limit reuse and make future changes more difficult.&lt;&#x2F;p&gt;
&lt;p&gt;That said, the choice of whether to combine or separate builders is &lt;strong&gt;entirely up to you&lt;&#x2F;strong&gt;. CGP does &lt;strong&gt;not&lt;&#x2F;strong&gt; impose any rules on how you must structure your builder logic. It provides the tools to compose and reuse components where helpful, but it leaves design decisions to the developer.&lt;&#x2F;p&gt;
&lt;p&gt;For the remainder of this article, we will continue to use the fully modular approach, breaking construction logic down into smaller, independent units. Our goal is to illustrate the full extent of flexibility and reusability that CGP enables. However, if you prefer a different organizational structure, you are free to structure your builders in whatever way best suits your project.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;chatgpt-client-builder&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#chatgpt-client-builder&quot; aria-label=&quot;Anchor link for: chatgpt-client-builder&quot;&gt;ChatGPT Client Builder&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Regardless of whether you prefer to split or combine the construction of components such as the SQLite and HTTP clients, there are many situations where it makes sense to separate construction logic into smaller, more focused units. For instance, you might want to offer two versions of your application — one standard version and one &quot;smart&quot; version that includes AI capabilities. In such cases, it is useful to define a separate builder provider for the ChatGPT client, so that AI-related logic can be included only when necessary.&lt;&#x2F;p&gt;
&lt;p&gt;The implementation for the ChatGPT client builder follows the same general pattern as the previous builders. It is defined as follows:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_new_provider]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;Build, Code: Send, Input: Send&amp;gt; Handler&amp;lt;Build, Code, Input&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;BuildOpenAiClient
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;    Build: HasOpenAiConfig + HasAsyncErrorType,
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Output &lt;&#x2F;span&gt;&lt;span&gt;= OpenAiClient;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    async &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;handle(
&lt;&#x2F;span&gt;&lt;span&gt;        build: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;Build,
&lt;&#x2F;span&gt;&lt;span&gt;        _code: PhantomData&amp;lt;Code&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        _input: Input,
&lt;&#x2F;span&gt;&lt;span&gt;    ) -&amp;gt; Result&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;Output, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Build::&lt;&#x2F;span&gt;&lt;span&gt;Error&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; open_ai_client = openai::Client::new(build.open_ai_key());
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; open_ai_agent = open_ai_client
&lt;&#x2F;span&gt;&lt;span&gt;            .agent(build.open_ai_model())
&lt;&#x2F;span&gt;&lt;span&gt;            .preamble(build.llm_preamble())
&lt;&#x2F;span&gt;&lt;span&gt;            .build();
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        Ok(OpenAiClient {
&lt;&#x2F;span&gt;&lt;span&gt;            open_ai_client,
&lt;&#x2F;span&gt;&lt;span&gt;            open_ai_agent,
&lt;&#x2F;span&gt;&lt;span&gt;        })
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This builder requires the &lt;code&gt;Build&lt;&#x2F;code&gt; context to provide three string fields: the OpenAI API key, the model name, and a custom preamble string. These requirements are captured by the &lt;code&gt;HasOpenAiConfig&lt;&#x2F;code&gt; trait:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_auto_getter]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;HasOpenAiConfig {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;open_ai_key(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;str&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;open_ai_model(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;str&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;llm_preamble(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;str&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;As with the other providers, we use the &lt;code&gt;#[cgp_auto_getter]&lt;&#x2F;code&gt; macro to automatically implement the trait, as long as the builder context contains the corresponding fields and derives &lt;code&gt;HasField&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;The &lt;code&gt;BuildOpenAiClient&lt;&#x2F;code&gt; provider returns an &lt;code&gt;OpenAiClient&lt;&#x2F;code&gt; struct that wraps two values: the low-level &lt;code&gt;openai::Client&lt;&#x2F;code&gt; and the higher-level &lt;code&gt;Agent&lt;&#x2F;code&gt; configured with the specified model and preamble.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[derive(HasField, HasFields, BuildField)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;OpenAiClient {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;open_ai_client: openai::Client,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;open_ai_agent: Agent&amp;lt;openai::CompletionModel&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;By defining this logic in a standalone builder provider, we can easily opt in or out of ChatGPT support in our application context.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;builder-context&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#builder-context&quot; aria-label=&quot;Anchor link for: builder-context&quot;&gt;Builder Context&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Now that we have implemented builder providers for SQLite, HTTP, and ChatGPT clients, we can demonstrate how to combine them in a complete builder context that constructs the final &lt;code&gt;App&lt;&#x2F;code&gt; instance. Defining this context is surprisingly concise and requires only a few lines of code:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_context]
&lt;&#x2F;span&gt;&lt;span&gt;#[derive(HasField, Deserialize)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;FullAppBuilder {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;db_options: String,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;db_journal_mode: String,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;http_user_agent: String,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;open_ai_key: String,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;open_ai_model: String,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;llm_preamble: String,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Here, we define a &lt;code&gt;FullAppBuilder&lt;&#x2F;code&gt; struct that includes all of the fields required by the three individual builder providers. The &lt;code&gt;#[cgp_context]&lt;&#x2F;code&gt; macro enables the CGP capabilities for the context struct, while the &lt;code&gt;HasField&lt;&#x2F;code&gt; derive macro enables automatic implementation of the necessary accessor traits using &lt;code&gt;#[cgp_auto_getter]&lt;&#x2F;code&gt;. In addition, we derive &lt;code&gt;Deserialize&lt;&#x2F;code&gt; so that &lt;code&gt;FullAppBuilder&lt;&#x2F;code&gt; can be easily loaded from a configuration file in formats such as JSON or TOML.&lt;&#x2F;p&gt;
&lt;p&gt;Next, we wire up the builder context using the &lt;code&gt;delegate_components!&lt;&#x2F;code&gt; macro:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;delegate_components! {
&lt;&#x2F;span&gt;&lt;span&gt;    FullAppBuilderComponents {
&lt;&#x2F;span&gt;&lt;span&gt;        ErrorTypeProviderComponent:
&lt;&#x2F;span&gt;&lt;span&gt;            UseAnyhowError,
&lt;&#x2F;span&gt;&lt;span&gt;        ErrorRaiserComponent:
&lt;&#x2F;span&gt;&lt;span&gt;            RaiseAnyhowError,
&lt;&#x2F;span&gt;&lt;span&gt;        HandlerComponent:
&lt;&#x2F;span&gt;&lt;span&gt;            BuildAndMergeOutputs&amp;lt;
&lt;&#x2F;span&gt;&lt;span&gt;                App,
&lt;&#x2F;span&gt;&lt;span&gt;                Product&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;[
&lt;&#x2F;span&gt;&lt;span&gt;                    BuildSqliteClient,
&lt;&#x2F;span&gt;&lt;span&gt;                    BuildHttpClient,
&lt;&#x2F;span&gt;&lt;span&gt;                    BuildOpenAiClient,
&lt;&#x2F;span&gt;&lt;span&gt;                ]&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This macro allows us to delegate the implementation of various components of the builder context. First, we configure error handling by using the &lt;code&gt;cgp-anyhow-error&lt;&#x2F;code&gt; library. The &lt;code&gt;UseAnyhowError&lt;&#x2F;code&gt; provider specifies that our abstract &lt;code&gt;Error&lt;&#x2F;code&gt; type will be instantiated to &lt;code&gt;anyhow::Error&lt;&#x2F;code&gt;, and the &lt;code&gt;RaiseAnyhowError&lt;&#x2F;code&gt; provider allows conversion from error types implementing &lt;code&gt;core::error::Error&lt;&#x2F;code&gt;, like &lt;code&gt;sqlx::Error&lt;&#x2F;code&gt; and &lt;code&gt;reqwest::Error&lt;&#x2F;code&gt;, into &lt;code&gt;anyhow::Error&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;builder-dispatcher&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#builder-dispatcher&quot; aria-label=&quot;Anchor link for: builder-dispatcher&quot;&gt;Builder Dispatcher&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;In the example above, we used a special &lt;strong&gt;builder dispatcher&lt;&#x2F;strong&gt; called &lt;code&gt;BuildAndMergeOutputs&lt;&#x2F;code&gt; to implement the &lt;code&gt;HandlerComponent&lt;&#x2F;code&gt;. This dispatcher allows us to construct the final &lt;code&gt;App&lt;&#x2F;code&gt; type by sequentially combining the outputs of multiple builder providers. We specify the target &lt;code&gt;App&lt;&#x2F;code&gt; type as the output of the build process, and then pass in a &lt;em&gt;type-level list&lt;&#x2F;em&gt; of builder providers using the &lt;code&gt;Product!&lt;&#x2F;code&gt; macro. In this case, we used &lt;code&gt;BuildSqliteClient&lt;&#x2F;code&gt;, &lt;code&gt;BuildHttpClient&lt;&#x2F;code&gt;, and &lt;code&gt;BuildOpenAiClient&lt;&#x2F;code&gt;, all of which we implemented previously.&lt;&#x2F;p&gt;
&lt;p&gt;To understand how &lt;code&gt;BuildAndMergeOutputs&lt;&#x2F;code&gt; operates under the hood, let us walk through a manual implementation that performs the same task:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_new_provider]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;Code: Send, Input: Send&amp;gt; Handler&amp;lt;FullAppBuilder, Code, Input&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;BuildApp {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Output &lt;&#x2F;span&gt;&lt;span&gt;= App;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    async &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;handle(context: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;FullAppBuilder, code: PhantomData&amp;lt;Code&amp;gt;, _input: Input) -&amp;gt; Result&amp;lt;App, Error&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; app = App::builder()
&lt;&#x2F;span&gt;&lt;span&gt;            .build_from(BuildSqliteClient::handle(context, code, ()).await&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;?&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;            .build_from(BuildHttpClient::handle(context, code, ()).await&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;?&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;            .build_from(BuildOpenAiClient::handle(context, code, ()).await&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;?&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;            .finalize_build();
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        Ok(app)
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This manual implementation demonstrates the boilerplate that would be necessary if we did not use &lt;code&gt;BuildAndMergeOutputs&lt;&#x2F;code&gt;. Here, we define &lt;code&gt;BuildApp&lt;&#x2F;code&gt; as a &lt;em&gt;context-specific&lt;&#x2F;em&gt; provider for the &lt;code&gt;FullAppBuilder&lt;&#x2F;code&gt; context. It implements the &lt;code&gt;Handler&lt;&#x2F;code&gt; trait for any &lt;code&gt;Code&lt;&#x2F;code&gt; and &lt;code&gt;Input&lt;&#x2F;code&gt; types.&lt;&#x2F;p&gt;
&lt;p&gt;Within the &lt;code&gt;handle&lt;&#x2F;code&gt; method, we construct the &lt;code&gt;App&lt;&#x2F;code&gt; in a step-by-step manner, similar to how we built complex types earlier in the &lt;a href=&quot;https:&#x2F;&#x2F;www.contextgeneric.dev&#x2F;blog&#x2F;extensible-datatypes-part-1&#x2F;#safe-struct-building&quot;&gt;safe struct building&lt;&#x2F;a&gt; section. We begin by initializing an empty builder with &lt;code&gt;App::builder()&lt;&#x2F;code&gt;. Next, we invoke the &lt;code&gt;handle&lt;&#x2F;code&gt; method on each of the individual providers — &lt;code&gt;BuildSqliteClient&lt;&#x2F;code&gt;, &lt;code&gt;BuildHttpClient&lt;&#x2F;code&gt;, and &lt;code&gt;BuildOpenAiClient&lt;&#x2F;code&gt; — passing them the shared context and &lt;code&gt;PhantomData&lt;&#x2F;code&gt; for the code. The resulting outputs are incrementally merged into the builder using &lt;code&gt;build_from&lt;&#x2F;code&gt;, and finally, &lt;code&gt;finalize_build&lt;&#x2F;code&gt; is called to produce the completed &lt;code&gt;App&lt;&#x2F;code&gt; instance.&lt;&#x2F;p&gt;
&lt;p&gt;In this example, we ignore the original &lt;code&gt;Input&lt;&#x2F;code&gt; parameter and instead pass &lt;code&gt;()&lt;&#x2F;code&gt; to each sub-handler for simplicity. In the actual implementation of &lt;code&gt;BuildAndMergeOutputs&lt;&#x2F;code&gt;, a &lt;em&gt;reference&lt;&#x2F;em&gt; to the intermediate builder is instead passed along as input to each sub-handler to support more advanced use cases. However, we have omitted that detail here to focus on the overall structure.&lt;&#x2F;p&gt;
&lt;p&gt;While the manual implementation of &lt;code&gt;BuildApp&lt;&#x2F;code&gt; is relatively easy to follow, it is also quite repetitive. The main benefit of &lt;code&gt;BuildAndMergeOutputs&lt;&#x2F;code&gt; is that it eliminates this boilerplate by abstracting away the repetitive logic of chaining multiple builder steps and threading intermediary results. Furthermore, &lt;code&gt;BuildAndMergeOutputs&lt;&#x2F;code&gt; is implemented with the necessary generic parameters and constraints to work with &lt;em&gt;any&lt;&#x2F;em&gt; context type, as compared to being tied to the &lt;code&gt;App&lt;&#x2F;code&gt; context that we defined.&lt;&#x2F;p&gt;
&lt;p&gt;Aside from this reduction in verbosity, the behavior remains conceptually the same as what is shown in the manual example.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;building-the-app&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#building-the-app&quot; aria-label=&quot;Anchor link for: building-the-app&quot;&gt;Building the App&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;With the builder context defined, we can now construct the full &lt;code&gt;App&lt;&#x2F;code&gt; by simply instantiating the builder and calling its &lt;code&gt;handle&lt;&#x2F;code&gt; method:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;async &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;main() -&amp;gt; Result&amp;lt;(), Error&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; builder = FullAppBuilder {
&lt;&#x2F;span&gt;&lt;span&gt;        db_options: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;file:.&#x2F;db.sqlite&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;.to_owned(),
&lt;&#x2F;span&gt;&lt;span&gt;        db_journal_mode: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;WAL&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;.to_owned(),
&lt;&#x2F;span&gt;&lt;span&gt;        http_user_agent: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;SUPER_AI_AGENT&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;.to_owned(),
&lt;&#x2F;span&gt;&lt;span&gt;        open_ai_key: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;1234567890&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;.to_owned(),
&lt;&#x2F;span&gt;&lt;span&gt;        open_ai_model: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;gpt-4o&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;.to_owned(),
&lt;&#x2F;span&gt;&lt;span&gt;        llm_preamble: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;You are a helpful assistant&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;.to_owned(),
&lt;&#x2F;span&gt;&lt;span&gt;    };
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; app = builder.handle(PhantomData::&amp;lt;()&amp;gt;, ()).await&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;?&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;* Call methods on the app here *&#x2F;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    Ok(())
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In this example, we initialize &lt;code&gt;FullAppBuilder&lt;&#x2F;code&gt; by filling in the required configuration values. We then call &lt;code&gt;builder.handle()&lt;&#x2F;code&gt; to construct the &lt;code&gt;App&lt;&#x2F;code&gt;. The &lt;code&gt;handle&lt;&#x2F;code&gt; method requires two arguments: a &lt;code&gt;Code&lt;&#x2F;code&gt; type and an &lt;code&gt;Input&lt;&#x2F;code&gt; value. However, because neither of these are constrained in any way in our example, we can simply pass &lt;em&gt;any&lt;&#x2F;em&gt; type we want, such as the unit type &lt;code&gt;()&lt;&#x2F;code&gt; for both. This simplifies to the equivalent of calling &lt;code&gt;builder.handle()&lt;&#x2F;code&gt; with no argument in practice.&lt;&#x2F;p&gt;
&lt;p&gt;This example illustrates how CGP allows new builder contexts to be defined with minimal effort by composing multiple independent builder providers — none of which require knowledge of the final type being constructed.&lt;&#x2F;p&gt;
&lt;p&gt;Rather than writing custom constructor functions that take numerous arguments, we define a builder struct where each required input becomes a field. Instead of manually constructing each component of the context, we use &lt;code&gt;delegate_components!&lt;&#x2F;code&gt; to connect the appropriate builder providers, which handle the construction logic for us.&lt;&#x2F;p&gt;
&lt;p&gt;By embracing this modular builder approach, our code becomes not only more extensible, but also easier to read, test, and maintain.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;more-builder-examples&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#more-builder-examples&quot; aria-label=&quot;Anchor link for: more-builder-examples&quot;&gt;More Builder Examples&lt;&#x2F;a&gt;&lt;&#x2F;h1&gt;
&lt;p&gt;At this point, some readers may still be skeptical about the value of modularity offered by CGP builders. Since we’ve only shown a &lt;strong&gt;single&lt;&#x2F;strong&gt; application context and &lt;strong&gt;one&lt;&#x2F;strong&gt; corresponding builder context so far, it might not be obvious why we couldn’t just use a simple &lt;code&gt;new&lt;&#x2F;code&gt; constructor function like the one defined at the beginning.&lt;&#x2F;p&gt;
&lt;p&gt;To truly demonstrate the power of modular builders, it’s helpful to explore how CGP makes it easy to define &lt;strong&gt;multiple&lt;&#x2F;strong&gt; contexts that are similar but have slight differences. However, if you&#x27;re an &lt;strong&gt;advanced reader&lt;&#x2F;strong&gt; already familiar with the benefits of modular design, feel free to &lt;a href=&quot;https:&#x2F;&#x2F;www.contextgeneric.dev&#x2F;blog&#x2F;extensible-datatypes-part-1&#x2F;#conclusion&quot;&gt;&lt;strong&gt;skip ahead&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt; to the conclusion.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;default-builder&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#default-builder&quot; aria-label=&quot;Anchor link for: default-builder&quot;&gt;Default Builder&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Earlier, we introduced default builders like &lt;code&gt;BuildDefaultSqliteClient&lt;&#x2F;code&gt;, which can construct an &lt;code&gt;App&lt;&#x2F;code&gt; with default configuration values. These defaults can be combined to define a minimal builder for &lt;code&gt;App&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_context]
&lt;&#x2F;span&gt;&lt;span&gt;#[derive(HasField, Deserialize)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;DefaultAppBuilder {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;db_path: String,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;delegate_components! {
&lt;&#x2F;span&gt;&lt;span&gt;    DefaultAppBuilderComponents {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;        HandlerComponent:
&lt;&#x2F;span&gt;&lt;span&gt;            BuildAndMergeOutputs&amp;lt;
&lt;&#x2F;span&gt;&lt;span&gt;                App,
&lt;&#x2F;span&gt;&lt;span&gt;                Product&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;[
&lt;&#x2F;span&gt;&lt;span&gt;                    BuildDefaultSqliteClient,
&lt;&#x2F;span&gt;&lt;span&gt;                    BuildDefaultHttpClient,
&lt;&#x2F;span&gt;&lt;span&gt;                    BuildDefaultOpenAiClient,
&lt;&#x2F;span&gt;&lt;span&gt;                ]&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In this context, the only required configuration is the &lt;code&gt;db_path&lt;&#x2F;code&gt;, simplifying the process of constructing an &lt;code&gt;App&lt;&#x2F;code&gt;, especially for use cases like unit testing or demos.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;postgres-app&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#postgres-app&quot; aria-label=&quot;Anchor link for: postgres-app&quot;&gt;Postgres App&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Now suppose we want an enterprise version of the app that uses &lt;strong&gt;Postgres&lt;&#x2F;strong&gt; instead of SQLite. We can define a new &lt;code&gt;App&lt;&#x2F;code&gt; context that swaps in &lt;code&gt;PgPool&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_context]
&lt;&#x2F;span&gt;&lt;span&gt;#[derive(HasField, HasFields, BuildField)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;App {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;postgres_pool: PgPool,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;http_client: Client,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;open_ai_client: openai::Client,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;open_ai_agent: Agent&amp;lt;openai::CompletionModel&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Since the HTTP and ChatGPT logic remains unchanged, we only need to implement a new builder for Postgres:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_new_provider]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;Build, Code: Send, Input: Send&amp;gt; Handler&amp;lt;Build, Code, Input&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;BuildPostgresClient
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;    Build: HasPostgresUrl + CanRaiseAsyncError&amp;lt;sqlx::Error&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Output &lt;&#x2F;span&gt;&lt;span&gt;= PostgresClient;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    async &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;handle(
&lt;&#x2F;span&gt;&lt;span&gt;        build: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;Build,
&lt;&#x2F;span&gt;&lt;span&gt;        _code: PhantomData&amp;lt;Code&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        _input: Input,
&lt;&#x2F;span&gt;&lt;span&gt;    ) -&amp;gt; Result&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;Output, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Build::&lt;&#x2F;span&gt;&lt;span&gt;Error&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; postgres_pool = PgPool::connect(build.postgres_url())
&lt;&#x2F;span&gt;&lt;span&gt;            .await
&lt;&#x2F;span&gt;&lt;span&gt;            .map_err(Build::raise_error)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;?&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        Ok(PostgresClient { postgres_pool })
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[cgp_auto_getter]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;HasPostgresUrl {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;postgres_url(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;str&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[derive(HasField, HasFields, BuildField)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;PostgresClient {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;postgres_pool: PgPool,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This builder closely mirrors the SQLite version, but reads the &lt;code&gt;postgres_url&lt;&#x2F;code&gt; field from the context instead.&lt;&#x2F;p&gt;
&lt;p&gt;Next, we define a new builder context that includes Postgres configuration:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_context]
&lt;&#x2F;span&gt;&lt;span&gt;#[derive(HasField, Deserialize)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;AppBuilder {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;postgres_url: String,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;http_user_agent: String,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;open_ai_key: String,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;open_ai_model: String,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;llm_preamble: String,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;delegate_components! {
&lt;&#x2F;span&gt;&lt;span&gt;    AppBuilderComponents {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;        HandlerComponent:
&lt;&#x2F;span&gt;&lt;span&gt;            BuildAndMergeOutputs&amp;lt;
&lt;&#x2F;span&gt;&lt;span&gt;                App,
&lt;&#x2F;span&gt;&lt;span&gt;                Product&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;[
&lt;&#x2F;span&gt;&lt;span&gt;                    BuildPostgresClient,
&lt;&#x2F;span&gt;&lt;span&gt;                    BuildHttpClient,
&lt;&#x2F;span&gt;&lt;span&gt;                    BuildOpenAiClient,
&lt;&#x2F;span&gt;&lt;span&gt;                ]&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Here, we simply swap in &lt;code&gt;BuildPostgresClient&lt;&#x2F;code&gt; instead of &lt;code&gt;BuildSqliteClient&lt;&#x2F;code&gt;, while reusing the other builder providers unchanged.&lt;&#x2F;p&gt;
&lt;p&gt;This example highlights a key advantage of CGP over traditional &lt;strong&gt;feature flags&lt;&#x2F;strong&gt;: with CGP, multiple application variants (e.g., SQLite or Postgres) can &lt;strong&gt;coexist&lt;&#x2F;strong&gt; in the same codebase and even be compiled together. In contrast, feature flags often force a binary either&#x2F;or split at compile time.&lt;&#x2F;p&gt;
&lt;p&gt;By enabling different configurations to exist side-by-side, CGP improves testability and reduces the likelihood of missing edge cases caused by untested feature combinations.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;anthropic-app&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#anthropic-app&quot; aria-label=&quot;Anchor link for: anthropic-app&quot;&gt;Anthropic App&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Just as we swapped SQLite for Postgres earlier, we can also substitute the AI model used in the application — such as replacing ChatGPT with &lt;strong&gt;Claude&lt;&#x2F;strong&gt;. With CGP, this becomes straightforward: we simply define a new &lt;code&gt;AnthropicApp&lt;&#x2F;code&gt; that uses the Anthropic client and agent:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_context]
&lt;&#x2F;span&gt;&lt;span&gt;#[derive(HasField, HasFields, BuildField)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;AnthropicApp {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;sqlite_pool: SqlitePool,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;http_client: Client,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;anthropic_client: anthropic::Client,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;anthropic_agent: Agent&amp;lt;anthropic::completion::CompletionModel&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Next, we implement a builder provider to construct the Claude client:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_new_provider]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;Build, Code: Send, Input: Send&amp;gt; Handler&amp;lt;Build, Code, Input&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;BuildDefaultAnthropicClient
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;    Build: HasAnthropicConfig + HasAsyncErrorType,
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Output &lt;&#x2F;span&gt;&lt;span&gt;= AnthropicClient;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    async &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;handle(
&lt;&#x2F;span&gt;&lt;span&gt;        build: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;Build,
&lt;&#x2F;span&gt;&lt;span&gt;        _code: PhantomData&amp;lt;Code&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        _input: Input,
&lt;&#x2F;span&gt;&lt;span&gt;    ) -&amp;gt; Result&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;Output, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Build::&lt;&#x2F;span&gt;&lt;span&gt;Error&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; anthropic_client = ClientBuilder::new(build.anthropic_key())
&lt;&#x2F;span&gt;&lt;span&gt;            .anthropic_version(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;ANTHROPIC_VERSION_LATEST&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;            .build();
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; anthropic_agent = anthropic_client
&lt;&#x2F;span&gt;&lt;span&gt;            .agent(anthropic::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;CLAUDE_3_7_SONNET&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;            .preamble(build.llm_preamble())
&lt;&#x2F;span&gt;&lt;span&gt;            .build();
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        Ok(AnthropicClient {
&lt;&#x2F;span&gt;&lt;span&gt;            anthropic_client,
&lt;&#x2F;span&gt;&lt;span&gt;            anthropic_agent,
&lt;&#x2F;span&gt;&lt;span&gt;        })
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[cgp_auto_getter]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;HasAnthropicConfig {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;anthropic_key(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;str&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;llm_preamble(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;str&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[derive(HasField, HasFields, BuildField)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;AnthropicClient {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;anthropic_client: anthropic::Client,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;anthropic_agent: Agent&amp;lt;CompletionModel&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;With the builder provider in place, we define a new builder context that includes the Anthropic API key and wire it up using &lt;code&gt;BuildDefaultAnthropicClient&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_context]
&lt;&#x2F;span&gt;&lt;span&gt;#[derive(HasField, Deserialize)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;AppBuilder {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;db_options: String,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;db_journal_mode: String,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;http_user_agent: String,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;anthropic_key: String,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;llm_preamble: String,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;delegate_components! {
&lt;&#x2F;span&gt;&lt;span&gt;    AppBuilderComponents {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;        HandlerComponent:
&lt;&#x2F;span&gt;&lt;span&gt;            BuildAndMergeOutputs&amp;lt;
&lt;&#x2F;span&gt;&lt;span&gt;                AnthropicApp,
&lt;&#x2F;span&gt;&lt;span&gt;                Product&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;[
&lt;&#x2F;span&gt;&lt;span&gt;                    BuildSqliteClient,
&lt;&#x2F;span&gt;&lt;span&gt;                    BuildHttpClient,
&lt;&#x2F;span&gt;&lt;span&gt;                    BuildDefaultAnthropicClient,
&lt;&#x2F;span&gt;&lt;span&gt;                ]&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This example shows how effortlessly CGP supports variation and customization. The same modular pattern can be reused to swap in different components — databases, HTTP clients, or agents — without rewriting core application logic.&lt;&#x2F;p&gt;
&lt;p&gt;In fact, the process becomes so systematic that it’s easy to imagine an AI tool like &lt;strong&gt;Claude Code&lt;&#x2F;strong&gt; automating the entire setup given the right prompt and documentation.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;anthropic-and-chatgpt-builder&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#anthropic-and-chatgpt-builder&quot; aria-label=&quot;Anchor link for: anthropic-and-chatgpt-builder&quot;&gt;Anthropic and ChatGPT Builder&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;It’s impressive that CGP lets us easily swap ChatGPT for Claude. But what’s even better is that we don’t have to choose at all — we can include &lt;strong&gt;both&lt;&#x2F;strong&gt; AI agents in the same application.&lt;&#x2F;p&gt;
&lt;p&gt;This could be useful for scenarios where combining the strengths of multiple models improves the overall intelligence or reliability of your application. More importantly, it demonstrates that CGP is not just about selecting one provider over another — it’s also about composing multiple providers together in a clean, modular way.&lt;&#x2F;p&gt;
&lt;p&gt;We begin by defining an &lt;code&gt;AnthropicAndChatGptApp&lt;&#x2F;code&gt; context that includes both Claude and ChatGPT clients:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_context]
&lt;&#x2F;span&gt;&lt;span&gt;#[derive(HasField, HasFields, BuildField)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;AnthropicAndChatGptApp {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;sqlite_pool: SqlitePool,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;http_client: Client,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;anthropic_client: anthropic::Client,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;anthropic_agent: Agent&amp;lt;anthropic::completion::CompletionModel&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;open_ai_client: openai::Client,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;open_ai_agent: Agent&amp;lt;openai::CompletionModel&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Next, we define a builder context that includes configuration fields for both AI platforms:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_context]
&lt;&#x2F;span&gt;&lt;span&gt;#[derive(HasField, Deserialize)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;AnthropicAndChatGptAppBuilder {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;db_options: String,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;db_journal_mode: String,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;http_user_agent: String,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;anthropic_key: String,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;open_ai_key: String,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;open_ai_model: String,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;llm_preamble: String,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In the component wiring, we include both &lt;code&gt;BuildDefaultAnthropicClient&lt;&#x2F;code&gt; and &lt;code&gt;BuildOpenAiClient&lt;&#x2F;code&gt; in the provider list:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;delegate_components! {
&lt;&#x2F;span&gt;&lt;span&gt;    AnthropicAndChatGptAppBuilderComponents {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;        HandlerComponent:
&lt;&#x2F;span&gt;&lt;span&gt;            BuildAndMergeOutputs&amp;lt;
&lt;&#x2F;span&gt;&lt;span&gt;                AnthropicAndChatGptApp,
&lt;&#x2F;span&gt;&lt;span&gt;                Product&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;[
&lt;&#x2F;span&gt;&lt;span&gt;                    BuildSqliteClient,
&lt;&#x2F;span&gt;&lt;span&gt;                    BuildHttpClient,
&lt;&#x2F;span&gt;&lt;span&gt;                    BuildDefaultAnthropicClient,
&lt;&#x2F;span&gt;&lt;span&gt;                    BuildOpenAiClient,
&lt;&#x2F;span&gt;&lt;span&gt;                ]&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;With just a few extra lines, we’ve created a &lt;strong&gt;dual-agent&lt;&#x2F;strong&gt; AI app that can leverage both Claude and ChatGPT simultaneously.&lt;&#x2F;p&gt;
&lt;p&gt;It’s also worth noting that the &lt;code&gt;llm_preamble&lt;&#x2F;code&gt; field is reused by both the Claude and ChatGPT builders. This demonstrates CGP’s flexibility in sharing input values across multiple providers—without requiring any manual coordination or boilerplate.&lt;&#x2F;p&gt;
&lt;p&gt;This kind of seamless reuse and composition is where CGP truly shines: giving you fine-grained control over how your application is assembled, while keeping your code modular and maintainable.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;multi-context-builder&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#multi-context-builder&quot; aria-label=&quot;Anchor link for: multi-context-builder&quot;&gt;Multi-Context Builder&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Looking closely at the &lt;code&gt;AnthropicAndChatGptAppBuilder&lt;&#x2F;code&gt; that we previously defined, we can observe that it already includes all the necessary fields required to construct the Claude-only and ChatGPT-only applications as well. This means we can reuse the same builder to construct &lt;strong&gt;all three&lt;&#x2F;strong&gt; versions of our application contexts, simply by changing how the builder is wired.&lt;&#x2F;p&gt;
&lt;p&gt;To achieve this, we take advantage of the &lt;code&gt;Code&lt;&#x2F;code&gt; type parameter, which allows us to emulate DSL-like behavior similar to what is seen in &lt;a href=&quot;&#x2F;blog&#x2F;hypershell-release&#x2F;#abstract-syntax&quot;&gt;Hypershell&lt;&#x2F;a&gt;. We begin by defining distinct marker types that represent the different build modes:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;BuildChatGptApp;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;BuildAnthropicApp;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;BuildAnthropicAndChatGptApp;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Using these types, we can apply the &lt;a href=&quot;&#x2F;blog&#x2F;hypershell-release&#x2F;#generic-dispatcher&quot;&gt;&lt;code&gt;UseDelegate&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; pattern to route the &lt;code&gt;Handler&lt;&#x2F;code&gt; implementation to different builder pipelines depending on the code passed in. This enables conditional wiring based on the selected application mode:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;delegate_components! {
&lt;&#x2F;span&gt;&lt;span&gt;    AnthropicAndChatGptAppBuilderComponents {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;        HandlerComponent:
&lt;&#x2F;span&gt;&lt;span&gt;            UseDelegate&amp;lt;new BuilderHandlers &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;                BuildAnthropicAndChatGptApp:
&lt;&#x2F;span&gt;&lt;span&gt;                    BuildAndMergeOutputs&amp;lt;
&lt;&#x2F;span&gt;&lt;span&gt;                        AnthropicAndChatGptApp,
&lt;&#x2F;span&gt;&lt;span&gt;                        Product&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;[
&lt;&#x2F;span&gt;&lt;span&gt;                            BuildSqliteClient,
&lt;&#x2F;span&gt;&lt;span&gt;                            BuildHttpClient,
&lt;&#x2F;span&gt;&lt;span&gt;                            BuildDefaultAnthropicClient,
&lt;&#x2F;span&gt;&lt;span&gt;                            BuildOpenAiClient,
&lt;&#x2F;span&gt;&lt;span&gt;                        ]&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;                BuildChatGptApp:
&lt;&#x2F;span&gt;&lt;span&gt;                    BuildAndMergeOutputs&amp;lt;
&lt;&#x2F;span&gt;&lt;span&gt;                        ChatGptApp,
&lt;&#x2F;span&gt;&lt;span&gt;                        Product&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;[
&lt;&#x2F;span&gt;&lt;span&gt;                            BuildSqliteClient,
&lt;&#x2F;span&gt;&lt;span&gt;                            BuildHttpClient,
&lt;&#x2F;span&gt;&lt;span&gt;                            BuildOpenAiClient,
&lt;&#x2F;span&gt;&lt;span&gt;                        ]&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;                BuildAnthropicApp:
&lt;&#x2F;span&gt;&lt;span&gt;                    BuildAndMergeOutputs&amp;lt;
&lt;&#x2F;span&gt;&lt;span&gt;                        AnthropicApp,
&lt;&#x2F;span&gt;&lt;span&gt;                        Product&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;[
&lt;&#x2F;span&gt;&lt;span&gt;                            BuildSqliteClient,
&lt;&#x2F;span&gt;&lt;span&gt;                            BuildHttpClient,
&lt;&#x2F;span&gt;&lt;span&gt;                            BuildDefaultAnthropicClient,
&lt;&#x2F;span&gt;&lt;span&gt;                        ]&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;            }&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now, when we want to construct a specific application context, we only need to change the &lt;code&gt;Code&lt;&#x2F;code&gt; type by using &lt;code&gt;PhantomData&lt;&#x2F;code&gt;. This gives us a flexible, type-safe way to select the desired builder pipeline at runtime:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub&lt;&#x2F;span&gt;&lt;span&gt; async &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;main() -&amp;gt; Result&amp;lt;(), Error&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; builder = AnthropicAndChatGptAppBuilder {
&lt;&#x2F;span&gt;&lt;span&gt;        db_options: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;file:.&#x2F;db.sqlite&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;.to_owned(),
&lt;&#x2F;span&gt;&lt;span&gt;        db_journal_mode: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;WAL&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;.to_owned(),
&lt;&#x2F;span&gt;&lt;span&gt;        http_user_agent: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;SUPER_AI_AGENT&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;.to_owned(),
&lt;&#x2F;span&gt;&lt;span&gt;        anthropic_key: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;1234567890&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;.to_owned(),
&lt;&#x2F;span&gt;&lt;span&gt;        open_ai_key: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;1234567890&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;.to_owned(),
&lt;&#x2F;span&gt;&lt;span&gt;        open_ai_model: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;gpt-4o&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;.to_owned(),
&lt;&#x2F;span&gt;&lt;span&gt;        llm_preamble: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;You are a helpful assistant&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;.to_owned(),
&lt;&#x2F;span&gt;&lt;span&gt;    };
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; chat_gpt_app: ChatGptApp =
&lt;&#x2F;span&gt;&lt;span&gt;        builder.handle(PhantomData::&amp;lt;BuildChatGptApp&amp;gt;, ()).await&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;?&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; anthropic_app: AnthropicApp =
&lt;&#x2F;span&gt;&lt;span&gt;        builder.handle(PhantomData::&amp;lt;BuildAnthropicApp&amp;gt;, ()).await&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;?&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; combined_app: AnthropicAndChatGptApp =
&lt;&#x2F;span&gt;&lt;span&gt;        builder.handle(PhantomData::&amp;lt;BuildAnthropicAndChatGptApp&amp;gt;, ()).await&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;?&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;* Use the application contexts here *&#x2F;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    Ok(())
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This example highlights how CGP&#x27;s DSL features are not limited to building full-fledged domain-specific languages like &lt;a href=&quot;&#x2F;blog&#x2F;hypershell-release&#x2F;&quot;&gt;Hypershell&lt;&#x2F;a&gt;. Even in this lightweight form, they are immensely valuable for &lt;strong&gt;labeling and routing&lt;&#x2F;strong&gt; different behaviors based on combinations of builder providers.&lt;&#x2F;p&gt;
&lt;p&gt;In essence, we are still constructing a mini-DSL, albeit one composed of simple symbolic &quot;statements&quot; without complex language constructs. This approach not only brings expressive power to your builder logic, but also lays the groundwork for future extensions — such as richer abstract syntaxes — using the same techniques introduced by Hypershell.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;conclusion&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#conclusion&quot; aria-label=&quot;Anchor link for: conclusion&quot;&gt;Conclusion&lt;&#x2F;a&gt;&lt;&#x2F;h1&gt;
&lt;p&gt;In this first installment, we explored how CGP v0.4.2 empowers Rust developers to construct application contexts using modular, extensible builders. You’ve seen how individual providers like &lt;code&gt;BuildSqliteClient&lt;&#x2F;code&gt;, &lt;code&gt;BuildHttpClient&lt;&#x2F;code&gt;, and &lt;code&gt;BuildOpenAiClient&lt;&#x2F;code&gt; can be composed to build complex types without tight coupling or boilerplate. We’ve also demonstrated how the same context can be reused across multiple application variants — from SQLite to Postgres, from ChatGPT to Claude — all through declarative builder composition.&lt;&#x2F;p&gt;
&lt;p&gt;This approach dramatically simplifies configuration management, promotes code reuse, and opens the door to highly flexible, plugin-style architectures in Rust. Whether you&#x27;re building minimal test contexts or full-featured production systems, CGP gives you the tools to scale your logic modularly and safely.&lt;&#x2F;p&gt;
&lt;p&gt;In &lt;a href=&quot;&#x2F;blog&#x2F;extensible-datatypes-part-2&#x2F;&quot;&gt;Part 2 of this series, &lt;strong&gt;Modular Interpreters and Extensible Visitors&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;, we’ll shift gears to look at &lt;strong&gt;extensible variants&lt;&#x2F;strong&gt;, where CGP tackles the expression problem with a modular visitor pattern. If you&#x27;ve ever wanted to define interpreters, pattern match over generic enums, or evolve your data types without breaking existing logic — you won’t want to miss what’s coming next.&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>Hypershell: A Type-Level DSL for Shell-Scripting in Rust</title>
        <published>2025-06-14T00:00:00+00:00</published>
        <updated>2025-06-14T00:00:00+00:00</updated>
        
        <author>
          <name>
            Soares Chen
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://www.contextgeneric.dev/blog/hypershell-release/"/>
        <id>https://www.contextgeneric.dev/blog/hypershell-release/</id>
        
        <content type="html" xml:base="https://www.contextgeneric.dev/blog/hypershell-release/">&lt;p&gt;Discuss on &lt;a href=&quot;https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;rust&#x2F;comments&#x2F;1lb296n&#x2F;announcing_hypershell_a_typelevel_dsl_for&#x2F;&quot;&gt;Reddit&lt;&#x2F;a&gt;, &lt;a href=&quot;https:&#x2F;&#x2F;lobste.rs&#x2F;s&#x2F;1swikb&#x2F;hypershell_type_level_dsl_for_shell&quot;&gt;Lobsters&lt;&#x2F;a&gt;, and &lt;a href=&quot;https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=44274767&quot;&gt;Hacker News&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;summary&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#summary&quot; aria-label=&quot;Anchor link for: summary&quot;&gt;Summary&lt;&#x2F;a&gt;&lt;&#x2F;h1&gt;
&lt;p&gt;I am thrilled to introduce &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;contextgeneric&#x2F;hypershell&quot;&gt;&lt;strong&gt;Hypershell&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;, a modular, &lt;em&gt;type-level&lt;&#x2F;em&gt; domain-specific language (DSL) for writing shell-script-like programs in Rust. Hypershell is powered by &lt;a href=&quot;&#x2F;&quot;&gt;&lt;strong&gt;context-generic programming&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt; (CGP), which makes it possible for users to &lt;em&gt;extend&lt;&#x2F;em&gt; or &lt;em&gt;modify&lt;&#x2F;em&gt; both the language syntax and semantics.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;table-of-contents&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#table-of-contents&quot; aria-label=&quot;Anchor link for: table-of-contents&quot;&gt;Table of Contents&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;strong&gt;Estimated reading time:&lt;&#x2F;strong&gt; 1~2 hours (≈16 500 words).&lt;&#x2F;p&gt;
&lt;p&gt;This is a very long blog post, so I have included this section to give you an overview of the content, and know what to expect for each section.&lt;&#x2F;p&gt;
&lt;p&gt;The first section, &lt;a href=&quot;https:&#x2F;&#x2F;www.contextgeneric.dev&#x2F;blog&#x2F;hypershell-release&#x2F;#an-overview-of-hypershell&quot;&gt;&lt;strong&gt;An Overview of Hypershell&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;, gives a high level overview of the Hypershell DSL, together with example programs that we can write with it.&lt;&#x2F;p&gt;
&lt;p&gt;Next, &lt;a href=&quot;https:&#x2F;&#x2F;www.contextgeneric.dev&#x2F;blog&#x2F;hypershell-release&#x2F;#context-generic-programming&quot;&gt;&lt;strong&gt;Context-Generic Programming&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt; gives a quick tour on the high level concepts of CGP, so that readers who are new to CGP can quickly onboard to understanding the rest of the blog post.&lt;&#x2F;p&gt;
&lt;p&gt;Following that, &lt;a href=&quot;https:&#x2F;&#x2F;www.contextgeneric.dev&#x2F;blog&#x2F;hypershell-release&#x2F;#implementation-of-hypershell&quot;&gt;&lt;strong&gt;Implementation of Hypershell&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt; goes into the details of how Hypershell is implemented using CGP.&lt;&#x2F;p&gt;
&lt;p&gt;After that, &lt;a href=&quot;https:&#x2F;&#x2F;www.contextgeneric.dev&#x2F;blog&#x2F;hypershell-release&#x2F;#extending-hypershell&quot;&gt;&lt;strong&gt;Extending Hypershell&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt; walks through how CGP makes it possible to easily extend Hypershell with new language features.&lt;&#x2F;p&gt;
&lt;p&gt;Finally, &lt;a href=&quot;https:&#x2F;&#x2F;www.contextgeneric.dev&#x2F;blog&#x2F;hypershell-release&#x2F;#discussions&quot;&gt;&lt;strong&gt;Discussions&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt; talks about the work related to Hypershell, the pros and cons of our DSL approach, and how readers can get involved or support the project.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;disclaimer&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#disclaimer&quot; aria-label=&quot;Anchor link for: disclaimer&quot;&gt;Disclaimer&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Hypershell serves as an &lt;em&gt;experimental&lt;&#x2F;em&gt; proof of concept, showcasing the capabilities of CGP. As such, its primary purpose is to demonstrate how CGP can be used to build highly modular DSLs in Rust.&lt;&#x2F;p&gt;
&lt;p&gt;The example use case of shell scripting is primarily chosen because it is fun and approachable to programmers of all backgrounds. But regardless of the future outcome, I hope Hypershell can serve as a &lt;em&gt;fun&lt;&#x2F;em&gt; programming example and inspire you to become interested in learning CGP.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;an-overview-of-hypershell&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#an-overview-of-hypershell&quot; aria-label=&quot;Anchor link for: an-overview-of-hypershell&quot;&gt;An Overview of Hypershell&lt;&#x2F;a&gt;&lt;&#x2F;h1&gt;
&lt;h2 id=&quot;getting-started&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#getting-started&quot; aria-label=&quot;Anchor link for: getting-started&quot;&gt;Getting Started&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;You can use Hypershell today by simply adding the &lt;code&gt;hypershell&lt;&#x2F;code&gt; crate to your &lt;code&gt;Cargo.toml&lt;&#x2F;code&gt; dependencies. Since we will also cover the direct use of CGP, you should also add the &lt;code&gt;cgp&lt;&#x2F;code&gt; crate to your dependencies.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;toml&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-toml &quot;&gt;&lt;code class=&quot;language-toml&quot; data-lang=&quot;toml&quot;&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;dependencies&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;cgp         &lt;&#x2F;span&gt;&lt;span&gt;= { &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;version &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;0.4.1&amp;quot; &lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;hypershell  &lt;&#x2F;span&gt;&lt;span&gt;= { &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;version &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;0.1.0&amp;quot; &lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;hello-world&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#hello-world&quot; aria-label=&quot;Anchor link for: hello-world&quot;&gt;Hello World&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;We will begin learning Hypershell with a simple hello world example. Our hello world program runs the CLI command &lt;code&gt;echo hello world!&lt;&#x2F;code&gt; and then streams the output to &lt;code&gt;STDOUT&lt;&#x2F;code&gt;. With Hypershell, our program is written as follows:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;hypershell::prelude::*;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Program &lt;&#x2F;span&gt;&lt;span&gt;= hypershell! {
&lt;&#x2F;span&gt;&lt;span&gt;        SimpleExec&amp;lt;
&lt;&#x2F;span&gt;&lt;span&gt;            StaticArg&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;echo&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;            WithStaticArgs[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;hello&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;world!&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;],
&lt;&#x2F;span&gt;&lt;span&gt;        &amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;|&lt;&#x2F;span&gt;&lt;span&gt;   StreamToStdout
&lt;&#x2F;span&gt;&lt;span&gt;};
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We first import everything from &lt;code&gt;hypershell::prelude&lt;&#x2F;code&gt; to use common Hypershell constructs. Our hello program is then defined as a Rust &lt;em&gt;type&lt;&#x2F;em&gt; named &lt;code&gt;Program&lt;&#x2F;code&gt;. In the body, we use the &lt;code&gt;hypershell!&lt;&#x2F;code&gt; macro to define our program with shell-like syntactic sugar, such as the use of the pipe operator (&lt;code&gt;|&lt;&#x2F;code&gt;). At a high level, a Hypershell program consists of one or more &lt;em&gt;handlers&lt;&#x2F;em&gt; that form a connected &lt;em&gt;pipeline&lt;&#x2F;em&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;In the first part of the program, we use the &lt;code&gt;SimpleExec&lt;&#x2F;code&gt; handler to perform a simplified execution of a CLI command. The first argument to &lt;code&gt;SimpleExec&lt;&#x2F;code&gt; is &lt;code&gt;StaticArg&amp;lt;&quot;echo&quot;&amp;gt;&lt;&#x2F;code&gt;, meaning that the program always executes the hardcoded &lt;code&gt;echo&lt;&#x2F;code&gt; command. The second argument to &lt;code&gt;SimpleExec&lt;&#x2F;code&gt; is &lt;code&gt;WithStaticArgs&lt;&#x2F;code&gt;, which accepts a &lt;em&gt;variadic&lt;&#x2F;em&gt; list of static arguments that are passed to the &lt;code&gt;echo&lt;&#x2F;code&gt; command.&lt;&#x2F;p&gt;
&lt;p&gt;In the second part of the program, we use the &lt;code&gt;|&lt;&#x2F;code&gt; operator to indicate that we want to pipe the result from &lt;code&gt;SimpleExec&lt;&#x2F;code&gt; to the next handler, &lt;code&gt;StreamToStdout&lt;&#x2F;code&gt;. The &lt;code&gt;StreamToStdout&lt;&#x2F;code&gt; handler then streams the output to the &lt;code&gt;STDOUT&lt;&#x2F;code&gt; of the main Rust program so that we can see the output when running the program.&lt;&#x2F;p&gt;
&lt;p&gt;Now that our program is defined, we can define a &lt;code&gt;main&lt;&#x2F;code&gt; function to call the Hypershell program inside our Rust program:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[tokio::main]
&lt;&#x2F;span&gt;&lt;span&gt;async &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;main() -&amp;gt; Result&amp;lt;(), Error&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    HypershellCli
&lt;&#x2F;span&gt;&lt;span&gt;        .handle(PhantomData::&amp;lt;Program&amp;gt;, Vec::new())
&lt;&#x2F;span&gt;&lt;span&gt;        .await&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;?&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    Ok(())
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We use &lt;code&gt;#[tokio::main]&lt;&#x2F;code&gt; to define an async main function. Inside the function body, we make use of &lt;code&gt;HypershellCli&lt;&#x2F;code&gt;, which is a pre-defined context that can be used for running simple CLI-only Hypershell programs. The &lt;code&gt;HypershellCli&lt;&#x2F;code&gt; context is an empty struct, hence we are able to directly construct a value and call the &lt;code&gt;handle&lt;&#x2F;code&gt; method on it.&lt;&#x2F;p&gt;
&lt;p&gt;The &lt;code&gt;handle&lt;&#x2F;code&gt; method comes from the &lt;code&gt;CanHandle&lt;&#x2F;code&gt; trait from &lt;code&gt;cgp&lt;&#x2F;code&gt;, and is automatically implemented by &lt;code&gt;HypershellCli&lt;&#x2F;code&gt; for any supported program. This blanket implementation is a key enabler of CGP&#x27;s modularity, allowing &lt;code&gt;HypershellCli&lt;&#x2F;code&gt; to handle diverse Hypershell programs without explicit implementations for each. We pass our program to the first argument of &lt;code&gt;handle&lt;&#x2F;code&gt; as &lt;code&gt;PhantomData::&amp;lt;Program&amp;gt;&lt;&#x2F;code&gt;, that is, the &lt;code&gt;Program&lt;&#x2F;code&gt; we defined earlier is purely a &lt;em&gt;type-level&lt;&#x2F;em&gt; construct and has no meaningful representation at the value-level. Nevertheless, we use &lt;code&gt;PhantomData&lt;&#x2F;code&gt; to &quot;pass&quot; the type as a value parameter, as this leads to cleaner syntax compared to passing it as a generic argument.&lt;&#x2F;p&gt;
&lt;p&gt;We then pass an empty &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;&#x2F;code&gt; to the second argument of &lt;code&gt;handle&lt;&#x2F;code&gt;; this &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;&#x2F;code&gt; serves as the &lt;code&gt;STDIN&lt;&#x2F;code&gt; input for the executed command. In this specific &lt;code&gt;echo&lt;&#x2F;code&gt; example, it remains empty as &lt;code&gt;echo&lt;&#x2F;code&gt; operates directly on its arguments rather than &lt;code&gt;STDIN&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;The full example program shown here is also available at our &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;contextgeneric&#x2F;hypershell&#x2F;blob&#x2F;main&#x2F;crates&#x2F;hypershell-examples&#x2F;examples&#x2F;hello.rs&quot;&gt;GitHub repository&lt;&#x2F;a&gt;. If you clone the repository, you can run the example program with &lt;code&gt;cargo run&lt;&#x2F;code&gt;, and we should see the familiar &lt;code&gt;hello world!&lt;&#x2F;code&gt; printed out:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;bash&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-bash &quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span&gt;$ cargo run --example hello
&lt;&#x2F;span&gt;&lt;span&gt;hello world!
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;macro-desugaring&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#macro-desugaring&quot; aria-label=&quot;Anchor link for: macro-desugaring&quot;&gt;Macro Desugaring&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;The &lt;code&gt;hypershell!&lt;&#x2F;code&gt; macro is a straightforward procedural macro that performs basic syntax transformations, making Hypershell programs resemble shell scripts. However, its use is entirely &lt;strong&gt;optional&lt;&#x2F;strong&gt;; you can define Hypershell programs without it.&lt;&#x2F;p&gt;
&lt;p&gt;For instance, the previous &quot;hello world&quot; program can be rewritten as follows:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Program &lt;&#x2F;span&gt;&lt;span&gt;= Pipe&amp;lt;Product&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;[
&lt;&#x2F;span&gt;&lt;span&gt;    SimpleExec&amp;lt;
&lt;&#x2F;span&gt;&lt;span&gt;        StaticArg&amp;lt;Symbol&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;(&amp;quot;echo&amp;quot;)&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        WithStaticArgs&amp;lt;Product&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;[
&lt;&#x2F;span&gt;&lt;span&gt;            Symbol&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;hello&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;),
&lt;&#x2F;span&gt;&lt;span&gt;            Symbol&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;world!&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;),
&lt;&#x2F;span&gt;&lt;span&gt;        ]&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    StreamToStdout,
&lt;&#x2F;span&gt;&lt;span&gt;]&amp;gt;;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Compared to the &quot;prettified&quot; version, the raw Hypershell syntax is slightly more verbose but remains relatively readable. The first thing to notice is that handlers chained with &lt;code&gt;|&lt;&#x2F;code&gt; are now placed inside a &lt;strong&gt;&lt;code&gt;Pipe&lt;&#x2F;code&gt;&lt;&#x2F;strong&gt; wrapper. Furthermore, the &lt;strong&gt;&lt;code&gt;Product!&lt;&#x2F;code&gt;&lt;&#x2F;strong&gt; macro from CGP is used to construct a variable-length list at the &lt;em&gt;type-level&lt;&#x2F;em&gt;, enabling &lt;code&gt;Pipe&lt;&#x2F;code&gt; to accept an arbitrary number of handlers.&lt;&#x2F;p&gt;
&lt;p&gt;You can also see that the &lt;code&gt;WithStaticArgs[...]&lt;&#x2F;code&gt; syntax &lt;strong&gt;desugars&lt;&#x2F;strong&gt; to &lt;code&gt;WithStaticArgs&amp;lt;Product![...]&amp;gt;.&lt;&#x2F;code&gt; With &lt;code&gt;hypershell!&lt;&#x2F;code&gt;, syntax that accepts a variable number of arguments can use the &lt;code&gt;[]&lt;&#x2F;code&gt; shorthand to wrap the inner arguments within &lt;code&gt;Product!&lt;&#x2F;code&gt;. This results in cleaner, more concise syntax, making Hypershell programs more readable.&lt;&#x2F;p&gt;
&lt;p&gt;Finally, you might notice that all occurrences of strings are wrapped inside the &lt;strong&gt;&lt;code&gt;Symbol!&lt;&#x2F;code&gt;&lt;&#x2F;strong&gt; macro from CGP. This is because Hypershell programs are types, but string literals are value-level expressions. The &lt;code&gt;Symbol!&lt;&#x2F;code&gt; macro allows you to turn string literals into &lt;em&gt;types&lt;&#x2F;em&gt;, enabling their use within type expressions.&lt;&#x2F;p&gt;
&lt;p&gt;Behind the scenes, &lt;code&gt;Symbol!&lt;&#x2F;code&gt; functions similarly to &lt;strong&gt;const-generics&lt;&#x2F;strong&gt; in Rust. However, since Rust doesn&#x27;t yet support using &lt;code&gt;String&lt;&#x2F;code&gt; or &lt;code&gt;&amp;amp;str&lt;&#x2F;code&gt; as const-generic arguments, the macro desugars the string literal into a type-level list of &lt;code&gt;char&lt;&#x2F;code&gt;, which &lt;em&gt;can&lt;&#x2F;em&gt; be used with const-generics.&lt;&#x2F;p&gt;
&lt;p&gt;With these three syntax transformations, we can now better understand how the &lt;code&gt;hypershell!&lt;&#x2F;code&gt; macro works. In Hypershell&#x27;s DSL architecture, the &lt;code&gt;hypershell!&lt;&#x2F;code&gt; macro provides the &lt;em&gt;surface syntax&lt;&#x2F;em&gt; of the DSL, which is then desugared into Rust types that serve as the &lt;em&gt;abstract syntax&lt;&#x2F;em&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;variable-parameters&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#variable-parameters&quot; aria-label=&quot;Anchor link for: variable-parameters&quot;&gt;Variable Parameters&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Now that we have a better understanding of Hypershell, let&#x27;s move on to a slightly more complex &quot;hello world&quot; example. Suppose we want to run &lt;code&gt;echo&lt;&#x2F;code&gt; with a &lt;em&gt;variable&lt;&#x2F;em&gt; argument &lt;code&gt;name&lt;&#x2F;code&gt;, so that the program prints &quot;Hello&quot;, followed by the value stored in &lt;code&gt;name&lt;&#x2F;code&gt;. To do that, we would redefine our program as follows:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Program &lt;&#x2F;span&gt;&lt;span&gt;= hypershell! {
&lt;&#x2F;span&gt;&lt;span&gt;        SimpleExec&amp;lt;
&lt;&#x2F;span&gt;&lt;span&gt;            StaticArg&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;echo&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;            WithArgs [
&lt;&#x2F;span&gt;&lt;span&gt;                StaticArg&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;Hello&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&amp;gt;,
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;                FieldArg&amp;lt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;name&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&amp;gt;,
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;            ],
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;        &amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;    |   StreamToStdout
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;};
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In our new program, the second argument to &lt;code&gt;SimpleExec&lt;&#x2F;code&gt; is changed from &lt;code&gt;WithStaticArgs&lt;&#x2F;code&gt; to &lt;code&gt;WithArgs&lt;&#x2F;code&gt;. The main difference is that &lt;code&gt;WithStaticArgs&lt;&#x2F;code&gt; accepts a list of static arguments, while &lt;code&gt;WithArgs&lt;&#x2F;code&gt; accepts a list of arguments with explicit specifiers.&lt;&#x2F;p&gt;
&lt;p&gt;For the first argument within &lt;code&gt;WithArgs&lt;&#x2F;code&gt;, we specify &lt;code&gt;StaticArg&amp;lt;&quot;Hello&quot;&amp;gt;&lt;&#x2F;code&gt; to indicate that the string &lt;code&gt;&quot;Hello&quot;&lt;&#x2F;code&gt; should always be printed as the first argument. Following that, we specify &lt;code&gt;FieldArg&amp;lt;&quot;name&quot;&amp;gt;&lt;&#x2F;code&gt; to indicate that the value of the &lt;code&gt;name&lt;&#x2F;code&gt; field from the context should be used as the second argument.&lt;&#x2F;p&gt;
&lt;p&gt;Now that we have defined our program, a question that arises next is: how can we &quot;pass&quot; in the &lt;code&gt;name&lt;&#x2F;code&gt; value to the program? Given that the program itself is only present at the type level, there is no place to hold the &lt;code&gt;name&lt;&#x2F;code&gt; value directly &lt;em&gt;within&lt;&#x2F;em&gt; the program type. If we try to run the program using &lt;code&gt;HypershellCli&lt;&#x2F;code&gt;, we will encounter errors indicating that no &lt;code&gt;name&lt;&#x2F;code&gt; field is present within the &lt;code&gt;HypershellCli&lt;&#x2F;code&gt; context.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;custom-context&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#custom-context&quot; aria-label=&quot;Anchor link for: custom-context&quot;&gt;Custom Context&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;To resolve the problem of variable capture, we&#x27;ll define a &lt;strong&gt;new context type&lt;&#x2F;strong&gt; for running our program. We&#x27;ll define a &lt;code&gt;MyApp&lt;&#x2F;code&gt; context with a &lt;code&gt;name&lt;&#x2F;code&gt; field as follows:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_context(MyAppComponents: HypershellPreset)]
&lt;&#x2F;span&gt;&lt;span&gt;#[derive(HasField)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;MyApp {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;name: String,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;MyApp&lt;&#x2F;code&gt; context is a straightforward struct with a public &lt;code&gt;name&lt;&#x2F;code&gt; field of type &lt;code&gt;String&lt;&#x2F;code&gt;. What makes it special are the two attribute macros used to automatically derive the capabilities needed for running Hypershell programs.&lt;&#x2F;p&gt;
&lt;p&gt;The first macro, &lt;code&gt;#[cgp_context]&lt;&#x2F;code&gt;, enables the wiring of CGP components for use by this context. The argument &lt;code&gt;MyAppComponents&lt;&#x2F;code&gt; is the name given to the &lt;strong&gt;provider&lt;&#x2F;strong&gt; for the &lt;code&gt;MyApp&lt;&#x2F;code&gt; context. For this example, we can largely disregard it as we&#x27;re not including any additional component wiring.&lt;&#x2F;p&gt;
&lt;p&gt;The macro argument is followed by a colon and then &lt;code&gt;HypershellPreset&lt;&#x2F;code&gt;, indicating that the &lt;code&gt;MyAppComponents&lt;&#x2F;code&gt; provider &lt;strong&gt;inherits&lt;&#x2F;strong&gt; from &lt;code&gt;HypershellPreset&lt;&#x2F;code&gt;, which Hypershell provides. This syntax might remind you of Rust&#x27;s supertraits, operating somewhat like object-oriented prototypal inheritance but exclusively at compile-time and the &lt;strong&gt;type-level&lt;&#x2F;strong&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;For the purpose of this example, the key takeaway is that the &lt;code&gt;MyApp&lt;&#x2F;code&gt; context implements all supported Hypershell components through its &lt;code&gt;MyAppComponents&lt;&#x2F;code&gt; provider, with the component wiring inherited from &lt;code&gt;HypershellPreset&lt;&#x2F;code&gt;. We&#x27;ll explore how CGP presets are defined and customized later in this blog post.&lt;&#x2F;p&gt;
&lt;p&gt;The second macro, &lt;code&gt;#[derive(HasField)]&lt;&#x2F;code&gt;, automatically implements the &lt;code&gt;HasField&lt;&#x2F;code&gt; trait for &lt;code&gt;MyApp&lt;&#x2F;code&gt;. This macro exposes the &lt;code&gt;name&lt;&#x2F;code&gt; field in &lt;code&gt;MyApp&lt;&#x2F;code&gt; via a &lt;code&gt;HasField&lt;&#x2F;code&gt; implementation, making it accessible by the &lt;code&gt;FieldArg&amp;lt;&quot;name&quot;&amp;gt;&lt;&#x2F;code&gt; in our Hypershell program.&lt;&#x2F;p&gt;
&lt;p&gt;Now that our custom context is defined, we can construct an instance of it within our &lt;code&gt;main&lt;&#x2F;code&gt; function and use it to execute our program:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[tokio::main]
&lt;&#x2F;span&gt;&lt;span&gt;async &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;main() -&amp;gt; Result&amp;lt;(), Error&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; app = MyApp {
&lt;&#x2F;span&gt;&lt;span&gt;        name: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Alice&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;.to_owned(),
&lt;&#x2F;span&gt;&lt;span&gt;    };
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    app.handle(PhantomData::&amp;lt;Program&amp;gt;, Vec::new()).await&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;?&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    Ok(())
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The complete example is available in the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;contextgeneric&#x2F;hypershell&#x2F;blob&#x2F;main&#x2F;crates&#x2F;hypershell-examples&#x2F;examples&#x2F;hello_name.rs&quot;&gt;Hypershell repository&lt;&#x2F;a&gt;. Since we initialize the &lt;code&gt;MyApp&lt;&#x2F;code&gt; context with the value &lt;code&gt;&quot;Alice&quot;&lt;&#x2F;code&gt; set in the &lt;code&gt;name&lt;&#x2F;code&gt; field, running the program should print &lt;code&gt;&quot;Hello, Alice&quot;&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;bash&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-bash &quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span&gt;$ cargo run --example hello_name
&lt;&#x2F;span&gt;&lt;span&gt;Hello, Alice
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;context-generic-implementation&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#context-generic-implementation&quot; aria-label=&quot;Anchor link for: context-generic-implementation&quot;&gt;Context-Generic Implementation&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;The previous example demonstrates that our custom &lt;code&gt;MyApp&lt;&#x2F;code&gt; context implements all the same functionalities as &lt;code&gt;HypershellCli&lt;&#x2F;code&gt; with only two lines of macro code. This remarkable conciseness is entirely due to Hypershell&#x27;s core implementation being fully &lt;strong&gt;context-generic&lt;&#x2F;strong&gt;. Crucially, none of Hypershell&#x27;s underlying implementation code has direct access to specific concrete types like &lt;code&gt;HypershellCli&lt;&#x2F;code&gt; or &lt;code&gt;MyApp&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Since the Hypershell core implementation lacks direct access to concrete contexts, it&#x27;s designed to be &lt;strong&gt;generic&lt;&#x2F;strong&gt; over any context type that satisfies predefined conditions. This approach makes Hypershell&#x27;s implementation highly customizable and extensible. CGP makes it incredibly &lt;strong&gt;easy&lt;&#x2F;strong&gt; to define custom contexts like &lt;code&gt;MyApp&lt;&#x2F;code&gt;, effectively eliminating tight coupling between implementations and concrete types.&lt;&#x2F;p&gt;
&lt;p&gt;As a side note, if you&#x27;re curious, the &lt;code&gt;#[cgp_context]&lt;&#x2F;code&gt; macro &lt;strong&gt;does not&lt;&#x2F;strong&gt; generate Hypershell implementation code specifically for &lt;code&gt;MyApp&lt;&#x2F;code&gt;. Instead, if you expand the macro, you&#x27;ll find it generates only a few lines of trait implementations that link to the &lt;code&gt;HypershellPreset&lt;&#x2F;code&gt; provider.&lt;&#x2F;p&gt;
&lt;p&gt;This design puts CGP in stark contrast with alternative modular programming libraries in Rust, which often rely on heavy macro expansion to copy &quot;template&quot; code implementations to work with concrete types. In contrast, CGP leverages Rust&#x27;s powerful traits, generics, and type system to ensure that all abstract implementations reliably function regardless of the concrete types they are instantiated with.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;dependency-injection&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#dependency-injection&quot; aria-label=&quot;Anchor link for: dependency-injection&quot;&gt;Dependency Injection&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;A key feature CGP provides, leveraging Rust&#x27;s capabilities, is &lt;strong&gt;dependency injection&lt;&#x2F;strong&gt; within context-generic implementations. Even though Hypershell&#x27;s core implementation is generic over the context type, we can introduce additional trait bounds in &lt;code&gt;impl&lt;&#x2F;code&gt; blocks to impose specific constraints on that context.&lt;&#x2F;p&gt;
&lt;p&gt;The implementation for &lt;code&gt;FieldArg&amp;lt;&quot;name&quot;&amp;gt;&lt;&#x2F;code&gt; exemplifies this by requiring the generic context to contain a &lt;code&gt;name&lt;&#x2F;code&gt; field. Because &lt;code&gt;MyApp&lt;&#x2F;code&gt; exposes its &lt;code&gt;name&lt;&#x2F;code&gt; field via the &lt;code&gt;HasField&lt;&#x2F;code&gt; instance, &lt;code&gt;FieldArg&amp;lt;&quot;name&quot;&amp;gt;&lt;&#x2F;code&gt; automatically works with &lt;code&gt;MyApp&lt;&#x2F;code&gt;. Conversely, attempting to use it with &lt;code&gt;HypershellCli&lt;&#x2F;code&gt; would result in a compilation error, as &lt;code&gt;HypershellCli&lt;&#x2F;code&gt; lacks the required &lt;code&gt;name&lt;&#x2F;code&gt; field.&lt;&#x2F;p&gt;
&lt;p&gt;From this, we also learn that CGP&#x27;s implementation wiring is performed &lt;strong&gt;lazily&lt;&#x2F;strong&gt;. Both &lt;code&gt;HypershellCli&lt;&#x2F;code&gt; and &lt;code&gt;MyApp&lt;&#x2F;code&gt; are wired with the same abstract implementations from &lt;code&gt;HypershellPreset&lt;&#x2F;code&gt;. However, only &lt;em&gt;some&lt;&#x2F;em&gt; of these wirings are valid, depending on the additional capabilities provided by the concrete context.&lt;&#x2F;p&gt;
&lt;p&gt;While it has always been possible to use dependency injection through Rust trait &lt;code&gt;impl&lt;&#x2F;code&gt;s, even in vanilla Rust, CGP elevates this pattern. It enables powerful use cases like the flexible implementation of &lt;code&gt;FieldArg&lt;&#x2F;code&gt; demonstrated in this example, pushing the boundaries of what&#x27;s achievable with dependency injection in Rust.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;streaming-handlers&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#streaming-handlers&quot; aria-label=&quot;Anchor link for: streaming-handlers&quot;&gt;Streaming Handlers&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Now that we&#x27;ve covered the basics of Hypershell, let&#x27;s dive into defining more complex Hypershell programs. In our earlier examples, we executed CLI commands using &lt;code&gt;SimpleExec&lt;&#x2F;code&gt;, which handles inputs and outputs as raw bytes (&lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;&#x2F;code&gt;). This execution mode offers simpler semantics, as you don&#x27;t need to worry about prematurely closed &lt;code&gt;STDIN&lt;&#x2F;code&gt; or &lt;code&gt;STDOUT&lt;&#x2F;code&gt; streams.&lt;&#x2F;p&gt;
&lt;p&gt;However, a significant appeal of shell scripting is the ability to &lt;strong&gt;stream&lt;&#x2F;strong&gt; the &lt;code&gt;STDOUT&lt;&#x2F;code&gt; of one program directly into the &lt;code&gt;STDIN&lt;&#x2F;code&gt; of another, with both programs running in parallel. To support this, Hypershell provides &lt;strong&gt;&lt;code&gt;StreamingExec&lt;&#x2F;code&gt;&lt;&#x2F;strong&gt;, which spawns child processes in the background and manages inputs and outputs as &lt;strong&gt;streams&lt;&#x2F;strong&gt;. Hypershell currently supports three types of streams: &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;futures&#x2F;latest&#x2F;futures&#x2F;prelude&#x2F;trait.Stream.html&quot;&gt;&lt;code&gt;futures::Stream&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;, &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;futures&#x2F;latest&#x2F;futures&#x2F;io&#x2F;trait.AsyncRead.html&quot;&gt;&lt;code&gt;futures::AsyncRead&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;, and &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;tokio&#x2F;latest&#x2F;tokio&#x2F;io&#x2F;trait.AsyncRead.html&quot;&gt;&lt;code&gt;tokio::io::AsyncRead&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;. As we&#x27;ll see later, Hypershell&#x27;s modular design also simplifies extending implementations to support other stream types.&lt;&#x2F;p&gt;
&lt;p&gt;To demonstrate streaming execution, let&#x27;s define an example program that streams the HTTP response from a URL and computes the SHA256 checksum of the webpage. Our program would look like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Program &lt;&#x2F;span&gt;&lt;span&gt;= hypershell! {
&lt;&#x2F;span&gt;&lt;span&gt;    StreamingExec&amp;lt;
&lt;&#x2F;span&gt;&lt;span&gt;        StaticArg&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;curl&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        WithArgs [
&lt;&#x2F;span&gt;&lt;span&gt;            FieldArg&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;url&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&amp;gt;,
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;        ],
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;    &amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;    |   StreamingExec&amp;lt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;            StaticArg&amp;lt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;sha256sum&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&amp;gt;,
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;            WithStaticArgs [],
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;        &amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;    |   StreamingExec&amp;lt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;            StaticArg&amp;lt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;cut&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&amp;gt;,
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;            WithStaticArgs [
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;                &amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;-d&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;,
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;                &amp;quot; &amp;quot;,
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;                &amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;-f&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;,
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;                &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;,
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;            ],
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;        &amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;    |   StreamToStdout
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;};
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Simply put, the Hypershell program above is roughly equivalent to the following bash command:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;bash&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-bash &quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span&gt;curl $url &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;| &lt;&#x2F;span&gt;&lt;span&gt;sha256sum &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;| &lt;&#x2F;span&gt;&lt;span&gt;cut -d &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;#39; &amp;#39;&lt;&#x2F;span&gt;&lt;span&gt; -f 1
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The first handler uses &lt;code&gt;curl&lt;&#x2F;code&gt; to fetch the HTTP response from a &lt;code&gt;url&lt;&#x2F;code&gt; value provided by the context. The second handler uses &lt;code&gt;sha256sum&lt;&#x2F;code&gt; to perform a streaming computation of the checksum. The third handler then uses &lt;code&gt;cut&lt;&#x2F;code&gt; to extract only the checksum value produced by &lt;code&gt;sha256sum&lt;&#x2F;code&gt;, effectively ignoring the filename output in the second column.&lt;&#x2F;p&gt;
&lt;p&gt;As in the previous example, we&#x27;ll define a new &lt;code&gt;MyApp&lt;&#x2F;code&gt; context to provide the &lt;code&gt;url&lt;&#x2F;code&gt; value:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_context(MyAppComponents: HypershellPreset)]
&lt;&#x2F;span&gt;&lt;span&gt;#[derive(HasField)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;MyApp {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;url: String,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We can then call the program with our &lt;code&gt;MyApp&lt;&#x2F;code&gt; context in the &lt;code&gt;main&lt;&#x2F;code&gt; function:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[tokio::main]
&lt;&#x2F;span&gt;&lt;span&gt;async &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;main() -&amp;gt; Result&amp;lt;(), Error&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; app = MyApp {
&lt;&#x2F;span&gt;&lt;span&gt;        url: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;https:&#x2F;&#x2F;nixos.org&#x2F;manual&#x2F;nixpkgs&#x2F;unstable&#x2F;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;.to_owned(),
&lt;&#x2F;span&gt;&lt;span&gt;    };
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    app.handle(PhantomData::&amp;lt;Program&amp;gt;, Vec::new()).await&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;?&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    Ok(())
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;For this example, we&#x27;ve chosen a relatively large public webpage — the &lt;a href=&quot;https:&#x2F;&#x2F;nixos.org&#x2F;manual&#x2F;nixpkgs&#x2F;unstable&#x2F;&quot;&gt;Nix manual&lt;&#x2F;a&gt; — as the &lt;code&gt;url&lt;&#x2F;code&gt; value for &lt;code&gt;MyApp&lt;&#x2F;code&gt;, to make the effect of streaming more noticeable.&lt;&#x2F;p&gt;
&lt;p&gt;The complete example program is also available in the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;contextgeneric&#x2F;hypershell&#x2F;blob&#x2F;main&#x2F;crates&#x2F;hypershell-examples&#x2F;examples&#x2F;http_checksum_cli.rs&quot;&gt;Hypershell repository&lt;&#x2F;a&gt;. If you run it, you should see a checksum similar to this printed to your console:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;bash&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-bash &quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span&gt;$ cargo run --example http_checksum_cli
&lt;&#x2F;span&gt;&lt;span&gt;c5ce4ff8fb2d768d4cbba8f5bee3d910c527deedec063a0aa436f4ae7005c713
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Feel free to tweak the example with different CLI commands to better observe how Hypershell indeed streams handler inputs and outputs in parallel.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;native-http-request&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#native-http-request&quot; aria-label=&quot;Anchor link for: native-http-request&quot;&gt;Native HTTP Request&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;In our previous example, we performed HTTP requests using the &lt;code&gt;curl&lt;&#x2F;code&gt; command before piping the output to &lt;code&gt;sha256sum&lt;&#x2F;code&gt;. But since we&#x27;re already running our program in Rust, a natural progression is to use &lt;em&gt;native&lt;&#x2F;em&gt; Rust HTTP clients for these requests.&lt;&#x2F;p&gt;
&lt;p&gt;Hypershell offers native HTTP support as a separate &lt;strong&gt;extension&lt;&#x2F;strong&gt; built on top of its base CLI implementation. This extension provides the &lt;code&gt;SimpleHttpRequest&lt;&#x2F;code&gt; and &lt;code&gt;StreamingHttpRequest&lt;&#x2F;code&gt; handlers, which are the HTTP equivalents of &lt;code&gt;SimpleExec&lt;&#x2F;code&gt; and &lt;code&gt;StreamingExec&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;We can easily modify our earlier example to use &lt;code&gt;StreamingHttpRequest&lt;&#x2F;code&gt; instead of &lt;code&gt;curl&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Program &lt;&#x2F;span&gt;&lt;span&gt;= hypershell! {
&lt;&#x2F;span&gt;&lt;span&gt;    StreamingHttpRequest&amp;lt;
&lt;&#x2F;span&gt;&lt;span&gt;        GetMethod,
&lt;&#x2F;span&gt;&lt;span&gt;        FieldArg&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;url&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        WithHeaders[ ],
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;|   &lt;&#x2F;span&gt;&lt;span&gt;StreamingExec&amp;lt;
&lt;&#x2F;span&gt;&lt;span&gt;            StaticArg&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;sha256sum&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;            WithStaticArgs [],
&lt;&#x2F;span&gt;&lt;span&gt;        &amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;|   &lt;&#x2F;span&gt;&lt;span&gt;StreamingExec&amp;lt;
&lt;&#x2F;span&gt;&lt;span&gt;            StaticArg&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;cut&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;            WithStaticArgs [
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;-d&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot; &amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;-f&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;1&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;            ],
&lt;&#x2F;span&gt;&lt;span&gt;        &amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;|&lt;&#x2F;span&gt;&lt;span&gt; StreamToStdout
&lt;&#x2F;span&gt;&lt;span&gt;};
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;StreamingHttpRequest&lt;&#x2F;code&gt; handler accepts three arguments. The first, &lt;code&gt;GetMethod&lt;&#x2F;code&gt;, specifies that we want to send a &lt;code&gt;GET&lt;&#x2F;code&gt; HTTP request. The second argument, &lt;code&gt;FieldArg&amp;lt;&quot;url&quot;&amp;gt;&lt;&#x2F;code&gt;, indicates that the request should be sent to the URL provided by the &lt;code&gt;url&lt;&#x2F;code&gt; field in our context. The third argument, &lt;code&gt;WithHeaders[]&lt;&#x2F;code&gt;, allows us to specify HTTP headers, which we&#x27;ve left empty for this example.&lt;&#x2F;p&gt;
&lt;p&gt;As you can see, Hypershell allows you to build seamless streaming pipelines that integrate both native and CLI handlers. In fact, all handlers are simply CGP components that implement the &lt;code&gt;Handler&lt;&#x2F;code&gt; interface. This design makes it incredibly easy to extend the DSL with new handler implementations that can interoperate, as long as the Rust types for their inputs and outputs match.&lt;&#x2F;p&gt;
&lt;p&gt;Behind the scenes, Hypershell&#x27;s native HTTP client is implemented using &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;reqwest&#x2F;&quot;&gt;&lt;code&gt;reqwest&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;. To run the program, the context needs to provide an &lt;code&gt;http_client&lt;&#x2F;code&gt; field containing a &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;reqwest&#x2F;latest&#x2F;reqwest&#x2F;struct.Client.html&quot;&gt;&lt;code&gt;reqwest::Client&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; instance.&lt;&#x2F;p&gt;
&lt;p&gt;Combining this with the &lt;code&gt;url&lt;&#x2F;code&gt; field, we&#x27;ll define our &lt;code&gt;MyApp&lt;&#x2F;code&gt; context like so:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_context(MyAppComponents: HypershellPreset)]
&lt;&#x2F;span&gt;&lt;span&gt;#[derive(HasField)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;MyApp {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;http_client: Client,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;url: String,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We can then construct a &lt;code&gt;MyApp&lt;&#x2F;code&gt; context in our &lt;code&gt;main&lt;&#x2F;code&gt; function and call the Hypershell program:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[tokio::main]
&lt;&#x2F;span&gt;&lt;span&gt;async &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;main() -&amp;gt; Result&amp;lt;(), Error&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; app = MyApp {
&lt;&#x2F;span&gt;&lt;span&gt;        http_client: Client::new(),
&lt;&#x2F;span&gt;&lt;span&gt;        url: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;https:&#x2F;&#x2F;nixos.org&#x2F;manual&#x2F;nixpkgs&#x2F;unstable&#x2F;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;.to_owned(),
&lt;&#x2F;span&gt;&lt;span&gt;    };
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    app.handle(PhantomData::&amp;lt;Program&amp;gt;, Vec::new()).await&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;?&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    Ok(())
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The full example is available in the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;contextgeneric&#x2F;hypershell&#x2F;blob&#x2F;main&#x2F;crates&#x2F;hypershell-examples&#x2F;examples&#x2F;http_checksum_client.rs&quot;&gt;project repository&lt;&#x2F;a&gt;. Running it should produce the same HTTP checksum as before:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;bash&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-bash &quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span&gt;$ cargo run --example http_checksum_client
&lt;&#x2F;span&gt;&lt;span&gt;c5ce4ff8fb2d768d4cbba8f5bee3d910c527deedec063a0aa436f4ae7005c713
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;It&#x27;s also worth noting that, besides &lt;code&gt;reqwest&lt;&#x2F;code&gt;, it&#x27;s possible to customize a context to use alternative HTTP client implementations for &lt;code&gt;SimpleHttpRequest&lt;&#x2F;code&gt; and &lt;code&gt;StreamingHttpRequest&lt;&#x2F;code&gt;. In such cases, you could define contexts without the &lt;code&gt;http_client&lt;&#x2F;code&gt; field if your alternative implementation doesn&#x27;t require it.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;json-encoding&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#json-encoding&quot; aria-label=&quot;Anchor link for: json-encoding&quot;&gt;JSON Encoding&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;As an embedded DSL, Hypershell programs seamlessly integrate shell scripting with the rest of your Rust application. A prime example of this capability is the ability to encode and decode native Rust types as part of a Hypershell program&#x27;s pipeline.&lt;&#x2F;p&gt;
&lt;p&gt;Here&#x27;s an example Hypershell program that submits a Rust code snippet to the &lt;a href=&quot;https:&#x2F;&#x2F;play.rust-lang.org&#x2F;&quot;&gt;Rust Playground&lt;&#x2F;a&gt; and then publishes it as a GitHub Gist:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Program &lt;&#x2F;span&gt;&lt;span&gt;= hypershell! {
&lt;&#x2F;span&gt;&lt;span&gt;    EncodeJson
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;|   &lt;&#x2F;span&gt;&lt;span&gt;SimpleHttpRequest&amp;lt;
&lt;&#x2F;span&gt;&lt;span&gt;            PostMethod,
&lt;&#x2F;span&gt;&lt;span&gt;            StaticArg&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;https:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;play.rust-lang.org&#x2F;meta&#x2F;gist&amp;quot;&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;            WithHeaders [
&lt;&#x2F;span&gt;&lt;span&gt;                Header&amp;lt;
&lt;&#x2F;span&gt;&lt;span&gt;                    StaticArg&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;Content&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;-&lt;&#x2F;span&gt;&lt;span&gt;Type&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;                    StaticArg&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;application&#x2F;json&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&amp;gt;,
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;                &amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;            ],
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;        &amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;    |   DecodeJson&amp;lt;Response&amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;};
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;strong&gt;&lt;code&gt;EncodeJson&lt;&#x2F;code&gt;&lt;&#x2F;strong&gt; handler accepts any input that implements &lt;code&gt;Serialize&lt;&#x2F;code&gt; and encodes it into JSON bytes as its output. Next, we use &lt;strong&gt;&lt;code&gt;SimpleHttpRequest&lt;&#x2F;code&gt;&lt;&#x2F;strong&gt; to submit the HTTP request; streaming isn&#x27;t necessary for small payloads here. Within &lt;code&gt;WithHeaders&lt;&#x2F;code&gt;, we also use &lt;code&gt;Header&lt;&#x2F;code&gt; to set the &lt;code&gt;Content-Type&lt;&#x2F;code&gt; header to &lt;code&gt;application&#x2F;json&lt;&#x2F;code&gt;. Finally, the &lt;strong&gt;&lt;code&gt;DecodeJson&lt;&#x2F;code&gt;&lt;&#x2F;strong&gt; handler decodes its input bytes into the specified Rust type, which is expected to implement &lt;code&gt;Deserialize&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;We define the input and output types as follows:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[derive(Serialize)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;Request {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;code: String,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[derive(Debug, Deserialize)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;Response {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;id: String,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;url: String,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;code: String,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;Request&lt;&#x2F;code&gt; and &lt;code&gt;Response&lt;&#x2F;code&gt; types are defined with their respective &lt;code&gt;Serialize&lt;&#x2F;code&gt; and &lt;code&gt;Deserialize&lt;&#x2F;code&gt; implementations, adhering to the formats expected by the Rust Playground API.&lt;&#x2F;p&gt;
&lt;p&gt;With the program defined, we can now programmatically submit a code snippet to the Rust Playground in our &lt;code&gt;main&lt;&#x2F;code&gt; function:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[tokio::main]
&lt;&#x2F;span&gt;&lt;span&gt;async &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;main() -&amp;gt; Result&amp;lt;(), Error&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; app = HypershellHttp {
&lt;&#x2F;span&gt;&lt;span&gt;        http_client: Client::new(),
&lt;&#x2F;span&gt;&lt;span&gt;    };
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; input = Request {
&lt;&#x2F;span&gt;&lt;span&gt;        code: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;fn main() { println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e3bbab;&quot;&gt;\&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;Hello, world!&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e3bbab;&quot;&gt;\&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;); }&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;.to_owned(),
&lt;&#x2F;span&gt;&lt;span&gt;    };
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; output = app.handle(PhantomData::&amp;lt;Program&amp;gt;, input).await&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;?&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Created new Rust playground gist with response: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{output:#?}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    Ok(())
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;When no additional fields are required, Hypershell provides the predefined &lt;strong&gt;&lt;code&gt;HypershellHttp&lt;&#x2F;code&gt;&lt;&#x2F;strong&gt; context, which can be used to run Hypershell programs with HTTP capabilities. This example code is also available in the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;contextgeneric&#x2F;hypershell&#x2F;blob&#x2F;main&#x2F;crates&#x2F;hypershell-examples&#x2F;examples&#x2F;rust_playground.rs&quot;&gt;project repository&lt;&#x2F;a&gt;. Running it should produce an output similar to this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;bash&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-bash &quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span&gt;$ cargo run --example rust_playground
&lt;&#x2F;span&gt;&lt;span&gt;Created new Rust playground gist with response: Response {
&lt;&#x2F;span&gt;&lt;span&gt;    id: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;ec90cbb6b3e797b15dd1eacbd51ffa8b&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    url: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;https:&#x2F;&#x2F;gist.github.com&#x2F;rust-play&#x2F;ec90cbb6b3e797b15dd1eacbd51ffa8b&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    code: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;fn main() { println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e3bbab;&quot;&gt;\&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;Hello, world!&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e3bbab;&quot;&gt;\&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;); }&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;end-of-overview&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#end-of-overview&quot; aria-label=&quot;Anchor link for: end-of-overview&quot;&gt;End of Overview&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;By now, hopefully the preceding examples have sufficiently demonstrated the power of Hypershell&#x27;s base implementation, suggesting its potential utility in building real-world™ applications.&lt;&#x2F;p&gt;
&lt;p&gt;Now that I&#x27;ve piqued your interest, I hope these examples have also provided you with ample motivation to learn &lt;em&gt;how&lt;&#x2F;em&gt; Hypershell is implemented, and how you can leverage CGP to build other domain-specific languages in a similar fashion.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;context-generic-programming&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#context-generic-programming&quot; aria-label=&quot;Anchor link for: context-generic-programming&quot;&gt;Context-Generic Programming&lt;&#x2F;a&gt;&lt;&#x2F;h1&gt;
&lt;p&gt;At its core, Hypershell&#x27;s modular implementation is made possible by &lt;strong&gt;Context-Generic Programming (CGP)&lt;&#x2F;strong&gt;, a powerful modular programming paradigm for Rust. You can find a comprehensive introduction to CGP on the &lt;a href=&quot;&#x2F;&quot;&gt;website&lt;&#x2F;a&gt; that hosts this blog post. However, for those new to CGP, I&#x27;ll provide a brief overview in this section.&lt;&#x2F;p&gt;
&lt;p&gt;As its name suggests, CGP allows Hypershell&#x27;s core logic to be generic over &lt;em&gt;any&lt;&#x2F;em&gt; context type, such as &lt;code&gt;HypershellCli&lt;&#x2F;code&gt;, &lt;code&gt;HypershellHttp&lt;&#x2F;code&gt;, or &lt;code&gt;MyApp&lt;&#x2F;code&gt;. This means that whenever you define a new concrete context, you can choose to reuse &lt;strong&gt;all&lt;&#x2F;strong&gt;, or more importantly, &lt;strong&gt;some&lt;&#x2F;strong&gt; of Hypershell&#x27;s core implementation based on your application&#x27;s specific needs. Furthermore, external developers can write their own context-generic implementations in the same way, enabling them to &lt;strong&gt;replace&lt;&#x2F;strong&gt; or &lt;strong&gt;extend&lt;&#x2F;strong&gt; existing core implementations.&lt;&#x2F;p&gt;
&lt;p&gt;At a high level, CGP makes it possible to bypass Rust&#x27;s trait &lt;strong&gt;coherence restrictions&lt;&#x2F;strong&gt;, allowing you to define overlapping or &quot;orphan&quot; trait implementations. Everything else in CGP is built on the foundation of asking: what would Rust programs look like if there were no coherence restrictions? CGP works on &lt;strong&gt;safe, stable&lt;&#x2F;strong&gt; versions of Rust today, and all you need to do is include the &lt;a href=&quot;https:&#x2F;&#x2F;crates.io&#x2F;crates&#x2F;cgp&quot;&gt;&lt;code&gt;cgp&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; crate as a dependency.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;consumer-and-provider-traits&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#consumer-and-provider-traits&quot; aria-label=&quot;Anchor link for: consumer-and-provider-traits&quot;&gt;Consumer and Provider Traits&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;The basic idea of how CGP works around coherence is quite simple. Let&#x27;s start with an example &lt;code&gt;CanGreet&lt;&#x2F;code&gt; trait, implemented with CGP as follows:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;cgp::prelude::*;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[cgp_component(Greeter)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;CanGreet {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;greet(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self);
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;CanGreet&lt;&#x2F;code&gt; trait we&#x27;ve defined is a classical Rust trait, which we refer to as a &lt;strong&gt;consumer trait&lt;&#x2F;strong&gt; in CGP. With the &lt;code&gt;#[cgp_component]&lt;&#x2F;code&gt; macro, a &lt;strong&gt;provider trait&lt;&#x2F;strong&gt; and a &lt;strong&gt;name struct&lt;&#x2F;strong&gt; are also generated, as shown below:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;Greeter&amp;lt;Context&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;greet(context: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;Context);
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;GreeterComponent;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Compared to the &lt;code&gt;CanGreet&lt;&#x2F;code&gt; consumer trait, the &lt;code&gt;Greeter&lt;&#x2F;code&gt; provider trait has an additional generic &lt;code&gt;Context&lt;&#x2F;code&gt; parameter that refers to the original &lt;code&gt;Self&lt;&#x2F;code&gt; type from &lt;code&gt;CanGreet&lt;&#x2F;code&gt;. Similarly, all occurrences of &lt;code&gt;Self&lt;&#x2F;code&gt; (i.e., &lt;code&gt;&amp;amp;self&lt;&#x2F;code&gt;) are replaced with the explicit &lt;code&gt;Context&lt;&#x2F;code&gt; (i.e., &lt;code&gt;context: &amp;amp;Context&lt;&#x2F;code&gt;).&lt;&#x2F;p&gt;
&lt;p&gt;In CGP, each implementation of a provider trait like &lt;code&gt;Greeter&lt;&#x2F;code&gt; will choose a &lt;strong&gt;unique type&lt;&#x2F;strong&gt; for its &lt;code&gt;Self&lt;&#x2F;code&gt; parameter (e.g., by defining a dummy struct like &lt;code&gt;struct Provider;&lt;&#x2F;code&gt;). This dummy struct that implements the provider trait is called a &lt;strong&gt;provider&lt;&#x2F;strong&gt;. Because Rust&#x27;s coherence restriction primarily applies to the &lt;code&gt;Self&lt;&#x2F;code&gt; type, by choosing a unique &lt;code&gt;Self&lt;&#x2F;code&gt; type for each implementation, we effectively bypass these restrictions. This allows us to define multiple generic implementations that might otherwise overlap on the &lt;code&gt;Context&lt;&#x2F;code&gt; type.&lt;&#x2F;p&gt;
&lt;p&gt;The macro also generates a &lt;code&gt;GreeterComponent&lt;&#x2F;code&gt; struct. This struct serves as a &lt;strong&gt;name&lt;&#x2F;strong&gt; or &lt;strong&gt;key&lt;&#x2F;strong&gt; for the underlying implementation, used to perform a type-level &lt;strong&gt;lookup&lt;&#x2F;strong&gt; when instantiating the consumer trait&#x27;s implementation from a provider trait implementation. We&#x27;ll revisit this concept shortly.&lt;&#x2F;p&gt;
&lt;p&gt;To demonstrate, here are two example provider implementations for &lt;code&gt;Greeter&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_new_provider]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;Context&amp;gt; Greeter&amp;lt;Context&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;GreetHello {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;greet(context: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;Context) {
&lt;&#x2F;span&gt;&lt;span&gt;        println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Hello!&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[cgp_new_provider]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;Context&amp;gt; Greeter&amp;lt;Context&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;GreetBonjour {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;greet(context: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;Context) {
&lt;&#x2F;span&gt;&lt;span&gt;        println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Bonjour!&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;#[cgp_new_provider]&lt;&#x2F;code&gt; macro automatically defines new structs for &lt;code&gt;GreetHello&lt;&#x2F;code&gt; and &lt;code&gt;GreetBonjour&lt;&#x2F;code&gt;. As you can see, both implementations are generic over the &lt;code&gt;Context&lt;&#x2F;code&gt; type, and no errors arise from overlapping instances.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;components-wiring&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#components-wiring&quot; aria-label=&quot;Anchor link for: components-wiring&quot;&gt;Components Wiring&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;While multiple overlapping provider trait implementations can coexist, they don&#x27;t automatically implement the original consumer trait like &lt;code&gt;CanGreet&lt;&#x2F;code&gt;. To implement the consumer trait for a specific concrete context, &lt;strong&gt;additional wiring steps&lt;&#x2F;strong&gt; are needed to select &lt;em&gt;which&lt;&#x2F;em&gt; provider implementation should be used for that context.&lt;&#x2F;p&gt;
&lt;p&gt;To demonstrate how this wiring works, let&#x27;s define an example &lt;code&gt;MyApp&lt;&#x2F;code&gt; context:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_context(MyAppComponents)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;MyApp;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;delegate_components! {
&lt;&#x2F;span&gt;&lt;span&gt;    MyAppComponents {
&lt;&#x2F;span&gt;&lt;span&gt;        GreeterComponent: GreetHello,
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In this example, we define a concrete &lt;code&gt;MyApp&lt;&#x2F;code&gt; context using the &lt;code&gt;#[cgp_context]&lt;&#x2F;code&gt; macro, which generates a new &lt;code&gt;MyAppComponents&lt;&#x2F;code&gt; struct and associates it with the context. Following this, we use &lt;code&gt;delegate_components!&lt;&#x2F;code&gt; to effectively make &lt;code&gt;MyAppComponents&lt;&#x2F;code&gt; a &lt;strong&gt;type-level lookup table&lt;&#x2F;strong&gt;. This table contains one entry where &lt;code&gt;GreeterComponent&lt;&#x2F;code&gt; acts as the &quot;key&quot; and &lt;code&gt;GreetHello&lt;&#x2F;code&gt; is the &quot;value.&quot;&lt;&#x2F;p&gt;
&lt;p&gt;With this wiring in place, the concrete &lt;code&gt;MyApp&lt;&#x2F;code&gt; context now automatically implements &lt;code&gt;CanGreet&lt;&#x2F;code&gt;, allowing us to call &lt;code&gt;MyApp.greet()&lt;&#x2F;code&gt;. To understand how this &quot;magic&quot; happens, let&#x27;s visualize the underlying implementation:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;blog&#x2F;images&#x2F;cgp-wiring.png&quot; alt=&quot;Diagram&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Starting from the bottom left, our goal is to implement &lt;code&gt;CanGreet&lt;&#x2F;code&gt; for &lt;code&gt;MyApp&lt;&#x2F;code&gt;. First, the Rust trait system observes that &lt;code&gt;MyApp&lt;&#x2F;code&gt; lacks an explicit &lt;code&gt;CanGreet&lt;&#x2F;code&gt; implementation. However, it &lt;em&gt;does&lt;&#x2F;em&gt; have a &lt;code&gt;HasProvider&lt;&#x2F;code&gt; implementation generated by &lt;code&gt;#[cgp_context]&lt;&#x2F;code&gt;, which points to &lt;code&gt;MyAppComponents&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Next, the trait system sees that &lt;code&gt;MyAppComponents&lt;&#x2F;code&gt; doesn&#x27;t directly implement &lt;code&gt;Greeter&amp;lt;MyApp&amp;gt;&lt;&#x2F;code&gt;. So, the system performs a type-level lookup using the &lt;code&gt;GreeterComponent&lt;&#x2F;code&gt; key stored in &lt;code&gt;MyAppComponents&lt;&#x2F;code&gt;. This lookup is facilitated by the &lt;code&gt;DelegateComponent&amp;lt;GreeterComponent&amp;gt;&lt;&#x2F;code&gt; trait, which is generated by the &lt;code&gt;delegate_components!&lt;&#x2F;code&gt; macro. Here, it discovers an entry for &lt;code&gt;GreeterComponent&lt;&#x2F;code&gt; that points to &lt;code&gt;GreetHello&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Subsequently, the trait system confirms that &lt;code&gt;GreetHello&lt;&#x2F;code&gt; has a valid implementation of &lt;code&gt;Greeter&amp;lt;MyApp&amp;gt;&lt;&#x2F;code&gt;. Through this, it generates a blanket implementation of &lt;code&gt;Greeter&amp;lt;MyApp&amp;gt;&lt;&#x2F;code&gt; for &lt;code&gt;MyAppComponents&lt;&#x2F;code&gt;, which simply forwards the call to &lt;code&gt;GreetHello&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Similarly, now that &lt;code&gt;Greeter&amp;lt;MyApp&amp;gt;&lt;&#x2F;code&gt; is implemented for &lt;code&gt;MyAppComponents&lt;&#x2F;code&gt;, the trait system generates a blanket implementation of &lt;code&gt;CanGreet&lt;&#x2F;code&gt; for &lt;code&gt;MyApp&lt;&#x2F;code&gt;. This blanket implementation forwards the call to the &lt;code&gt;Greeter&amp;lt;MyApp&amp;gt;&lt;&#x2F;code&gt; implementation of &lt;code&gt;MyAppComponents&lt;&#x2F;code&gt;, which in turn forwards it to &lt;code&gt;GreetHello&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;These blanket implementations for &lt;code&gt;CanGreet&lt;&#x2F;code&gt; and &lt;code&gt;Greeter&lt;&#x2F;code&gt; were generated by &lt;code&gt;#[cgp_components]&lt;&#x2F;code&gt; when the consumer trait was defined. What we&#x27;ve described above is a high-level visualization of how these blanket implementations function under the hood.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;prototypal-inheritance&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#prototypal-inheritance&quot; aria-label=&quot;Anchor link for: prototypal-inheritance&quot;&gt;Prototypal Inheritance&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;For readers familiar with JavaScript, you might notice that CGP&#x27;s wiring mechanics bear a striking resemblance to how &lt;strong&gt;prototypal inheritance&lt;&#x2F;strong&gt; works in JavaScript. Conceptually, our earlier &lt;code&gt;greet&lt;&#x2F;code&gt; example functions similarly to the following JavaScript code:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;javascript&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-javascript &quot;&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; provider
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;function &lt;&#x2F;span&gt;&lt;span&gt;greet_hello() {
&lt;&#x2F;span&gt;&lt;span&gt;    console.log(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Hello!&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; lookup table
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;var &lt;&#x2F;span&gt;&lt;span&gt;MyAppComponents = {
&lt;&#x2F;span&gt;&lt;span&gt;    greet: greet_hello,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; concrete context
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;var &lt;&#x2F;span&gt;&lt;span&gt;MyApp = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;function&lt;&#x2F;span&gt;&lt;span&gt;() {}
&lt;&#x2F;span&gt;&lt;span&gt;MyApp.prototype = MyAppComponents
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; context value
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;var &lt;&#x2F;span&gt;&lt;span&gt;app = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;new &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;MyApp&lt;&#x2F;span&gt;&lt;span&gt;()
&lt;&#x2F;span&gt;&lt;span&gt;app.greet()
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Since JavaScript is dynamically typed, the concept of a trait or interface can&#x27;t be explicitly specified in the code. However, we can still &lt;em&gt;conceptually&lt;&#x2F;em&gt; think of a &lt;code&gt;CanGreet&lt;&#x2F;code&gt; interface with certain method requirements. The &lt;code&gt;greet_hello&lt;&#x2F;code&gt; function here is the equivalent of a &lt;strong&gt;provider&lt;&#x2F;strong&gt; that implements the imaginary &lt;code&gt;Greeter&lt;&#x2F;code&gt; interface.&lt;&#x2F;p&gt;
&lt;p&gt;Similarly, &lt;code&gt;MyAppComponents&lt;&#x2F;code&gt; acts as a lookup table, mapping the &lt;code&gt;greet&lt;&#x2F;code&gt; method to the &lt;code&gt;greet_hello&lt;&#x2F;code&gt; provider. We then define the &lt;code&gt;MyApp&lt;&#x2F;code&gt; context class and set &lt;code&gt;MyAppComponents&lt;&#x2F;code&gt; as &lt;code&gt;MyApp&lt;&#x2F;code&gt;&#x27;s &lt;strong&gt;prototype&lt;&#x2F;strong&gt;. This mirrors CGP&#x27;s &lt;code&gt;HasProvider&lt;&#x2F;code&gt; trait, which links the consumer trait implementation to the provider trait.&lt;&#x2F;p&gt;
&lt;p&gt;Finally, we can instantiate &lt;code&gt;MyApp&lt;&#x2F;code&gt; using the &lt;code&gt;new&lt;&#x2F;code&gt; keyword, and as expected, the &lt;code&gt;app.greet()&lt;&#x2F;code&gt; method can be called.&lt;&#x2F;p&gt;
&lt;p&gt;If we visualize the prototype wiring in our JavaScript example, we get a diagram very similar to the one for CGP:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;blog&#x2F;images&#x2F;prototypal-inheritance.png&quot; alt=&quot;Diagram&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;We navigate this implementation diagram starting from the top-left corner. For &lt;code&gt;app.greet()&lt;&#x2F;code&gt; to be implemented, its class &lt;code&gt;MyApp&lt;&#x2F;code&gt; needs a &lt;code&gt;prototype&lt;&#x2F;code&gt; field pointing to &lt;code&gt;MyAppComponents&lt;&#x2F;code&gt;. We then perform a lookup on the &lt;code&gt;greet&lt;&#x2F;code&gt; key and find the &lt;code&gt;greet_hello&lt;&#x2F;code&gt; provider function to be called.&lt;&#x2F;p&gt;
&lt;p&gt;During runtime, the &lt;code&gt;MyAppComponents&lt;&#x2F;code&gt; prototype is attached to &lt;code&gt;app.__proto__&lt;&#x2F;code&gt;, which in turn enables &lt;code&gt;app.greet()&lt;&#x2F;code&gt; to be called.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;comparison-to-oop&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#comparison-to-oop&quot; aria-label=&quot;Anchor link for: comparison-to-oop&quot;&gt;Comparison to OOP&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;While CGP shares similarities with OOP, particularly prototype-based programming, its implementation differs significantly in ways that make CGP a far more powerful system.&lt;&#x2F;p&gt;
&lt;p&gt;Crucially, Rust&#x27;s strong type system, combined with advanced features like generics and traits, enables the creation of highly sophisticated constructs that are simply not possible with OOP alone. Furthermore, CGP performs its prototype-like lookup at &lt;strong&gt;compile-time&lt;&#x2F;strong&gt;, thereby eliminating runtime overheads associated with virtual tables and JIT compilation.&lt;&#x2F;p&gt;
&lt;p&gt;Through this comparison, I also hope to convey that CGP is &lt;strong&gt;not&lt;&#x2F;strong&gt; an entirely novel or incomprehensible concept. Many resources explain prototypal inheritance in depth, but there are virtually no third-party articles detailing how CGP works. My intention with this similarity comparison is to help readers from an OOP background better grasp CGP by connecting it to familiar concepts.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;learn-more&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#learn-more&quot; aria-label=&quot;Anchor link for: learn-more&quot;&gt;Learn More&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;We&#x27;ve now concluded our brief introduction to CGP. So far, we&#x27;ve explored CGP at a high level, with minimal technical details or code exploration into its inner workings.&lt;&#x2F;p&gt;
&lt;p&gt;If you&#x27;re eager to learn more about how CGP functions, I recommend reading the in-progress book, &lt;a href=&quot;https:&#x2F;&#x2F;patterns.contextgeneric.dev&#x2F;&quot;&gt;&lt;strong&gt;Context-Generic Programming Patterns&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;. This book walks through all the programming techniques used to build CGP from the ground up. However, if you&#x27;re not concerned with the internal details and simply want to start programming &lt;em&gt;with&lt;&#x2F;em&gt; CGP quickly, you might want to skip the book for now.&lt;&#x2F;p&gt;
&lt;p&gt;Unfortunately, we don&#x27;t yet have simple tutorials available for quickly getting started with CGP. This is partly because the benefits of CGP truly become apparent only in highly complex applications with many cross-cutting concerns, typically after writing 5,000 to 10,000 lines of code. Consequently, if a tutorial only showcases a few hundred lines of example code, some readers might inevitably feel confused about &lt;em&gt;why&lt;&#x2F;em&gt; they should learn to write that code with CGP, rather than using familiar vanilla Rust patterns.&lt;&#x2F;p&gt;
&lt;p&gt;Instead, the current priority for the CGP project is to leverage its full power to build robust DSL frameworks, such as Hypershell. These frameworks aim to demonstrate CGP&#x27;s full potential and undeniable usefulness in showcased domains, thereby giving readers a compelling reason to start &lt;em&gt;learning&lt;&#x2F;em&gt; CGP.&lt;&#x2F;p&gt;
&lt;p&gt;A consequence of this strategy is that many advanced CGP patterns are introduced all at once, as you&#x27;ll see in the next section. Many of these advanced CGP patterns aren&#x27;t yet covered in the book, and currently, there&#x27;s no other documentation besides this blog post that discusses them. As a result, if you&#x27;re entirely new to CGP or just starting to grasp its basic concepts, continuing to the next section might feel overwhelming and confusing.&lt;&#x2F;p&gt;
&lt;p&gt;Nevertheless, I&#x27;ll strive to explain these advanced CGP concepts at as high a level as possible, omitting internal details similar to how the earlier CGP wiring explanation was presented. So, I hope you&#x27;ll bear with me for now as we walk through how Hypershell is implemented with CGP.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;implementation-of-hypershell&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#implementation-of-hypershell&quot; aria-label=&quot;Anchor link for: implementation-of-hypershell&quot;&gt;Implementation of Hypershell&lt;&#x2F;a&gt;&lt;&#x2F;h1&gt;
&lt;p&gt;Now that we have a brief understanding of CGP, let&#x27;s explore how the Hypershell DSL is implemented using it. The programming techniques we&#x27;re about to cover aren&#x27;t exclusive to Hypershell; they apply more generally to any kind of DSL.&lt;&#x2F;p&gt;
&lt;p&gt;The core idea is that programs for this family of DSLs are written as &lt;strong&gt;types&lt;&#x2F;strong&gt; that are &quot;interpreted&quot; at compile time. The primary advantage of this approach is that the DSL can leverage the Rust compiler and zero-cost abstractions to be highly performant. The main drawback is that the DSL program must be available at the same time the Rust program is built. In other words, this approach is less suitable for scripting applications that require dynamic program loading, such as web browsers or plugin systems, unless the system also bundles the full Rust compiler to compile the DSL program.&lt;&#x2F;p&gt;
&lt;p&gt;Nevertheless, this section will be especially useful for readers interested in building DSLs similar to Hypershell. For other readers, I hope this section will still enhance your understanding of CGP and encourage you to consider using it for other modular applications.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;handler-component&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#handler-component&quot; aria-label=&quot;Anchor link for: handler-component&quot;&gt;Handler Component&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;The central component underpinning Hypershell is the &lt;strong&gt;&lt;code&gt;Handler&lt;&#x2F;code&gt;&lt;&#x2F;strong&gt; component, which is implemented by each handler in a Hypershell pipeline. The consumer trait for this component, &lt;strong&gt;&lt;code&gt;CanHandle&lt;&#x2F;code&gt;&lt;&#x2F;strong&gt;, is defined as follows:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_component(Handler)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;CanHandle&amp;lt;Code: Send, Input: Send&amp;gt;: HasAsyncErrorType {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Output&lt;&#x2F;span&gt;&lt;span&gt;: Send;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    async &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;handle(
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self,
&lt;&#x2F;span&gt;&lt;span&gt;        _code: PhantomData&amp;lt;Code&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        input: Input,
&lt;&#x2F;span&gt;&lt;span&gt;    ) -&amp;gt; Result&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;Output, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;Error&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;CanHandle&lt;&#x2F;code&gt; trait is parameterized by two generic types: &lt;code&gt;Code&lt;&#x2F;code&gt; and &lt;code&gt;Input&lt;&#x2F;code&gt;. The &lt;code&gt;Code&lt;&#x2F;code&gt; type represents the DSL program that we want to &quot;run&quot; or &quot;interpret,&quot; while &lt;code&gt;Input&lt;&#x2F;code&gt; is the primary input data passed to the program (e.g., &lt;code&gt;STDIN&lt;&#x2F;code&gt; or an HTTP request body). Both generic types carry an additional &lt;code&gt;Send&lt;&#x2F;code&gt; bound because CGP generally requires async functions to be &lt;code&gt;Send&lt;&#x2F;code&gt; by default, allowing them to be used in spawned tasks like those managed by &lt;code&gt;tokio::spawn&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;The trait also defines an associated type &lt;code&gt;Output&lt;&#x2F;code&gt;, which represents the data produced by the program (e.g., &lt;code&gt;STDOUT&lt;&#x2F;code&gt; or an HTTP response body). As an associated type, it signifies that for each unique combination of &lt;code&gt;Code&lt;&#x2F;code&gt; and &lt;code&gt;Input&lt;&#x2F;code&gt; parameters, there is a &lt;strong&gt;unique&lt;&#x2F;strong&gt; &lt;code&gt;Output&lt;&#x2F;code&gt; type associated with it.&lt;&#x2F;p&gt;
&lt;p&gt;The &lt;code&gt;handle&lt;&#x2F;code&gt; method is an &lt;code&gt;async&lt;&#x2F;code&gt; function with &lt;code&gt;&amp;amp;self&lt;&#x2F;code&gt; as its first argument. This means that in addition to the &lt;code&gt;Input&lt;&#x2F;code&gt;, the handler also has access to the context, which contains dependencies and environmental information. The second parameter, &lt;code&gt;_code&lt;&#x2F;code&gt;, is of type &lt;code&gt;PhantomData&amp;lt;Code&amp;gt;&lt;&#x2F;code&gt;. This is used to pass the &lt;code&gt;Code&lt;&#x2F;code&gt; program as a value to assist with type inference. Beyond that, the &lt;code&gt;_code&lt;&#x2F;code&gt; value is expected to be ignored by the method body, as &lt;code&gt;PhantomData&lt;&#x2F;code&gt; carries no runtime information.&lt;&#x2F;p&gt;
&lt;p&gt;The &lt;code&gt;handle&lt;&#x2F;code&gt; method returns a &lt;code&gt;Result&lt;&#x2F;code&gt;, with &lt;code&gt;Self::Output&lt;&#x2F;code&gt; representing the success value and &lt;code&gt;Self::Error&lt;&#x2F;code&gt; indicating an error. &lt;code&gt;Self::Error&lt;&#x2F;code&gt; is an &lt;strong&gt;abstract type&lt;&#x2F;strong&gt; defined by the &lt;code&gt;ErrorTypeProvider&lt;&#x2F;code&gt; component, which is defined in CGP as follows:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_type]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;HasErrorType {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Error&lt;&#x2F;span&gt;&lt;span&gt;: Debug;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;First, &lt;code&gt;HasErrorType&lt;&#x2F;code&gt; is a consumer trait containing an associated &lt;code&gt;Error&lt;&#x2F;code&gt; type, which is always required to implement &lt;code&gt;Debug&lt;&#x2F;code&gt;. The &lt;code&gt;#[cgp_type]&lt;&#x2F;code&gt; macro is an &lt;em&gt;extension&lt;&#x2F;em&gt; of &lt;code&gt;#[cgp_component]&lt;&#x2F;code&gt;, used to define abstract type components with additional derivations. This macro also generates an &lt;code&gt;ErrorTypeProvider&lt;&#x2F;code&gt; provider trait.&lt;&#x2F;p&gt;
&lt;p&gt;To support the &lt;code&gt;async&lt;&#x2F;code&gt; method in &lt;code&gt;CanHandle&lt;&#x2F;code&gt;, the context and the &lt;code&gt;Error&lt;&#x2F;code&gt; type also need to implement &lt;code&gt;Send&lt;&#x2F;code&gt;. This is provided by &lt;code&gt;HasAsyncErrorType&lt;&#x2F;code&gt; as a &lt;strong&gt;trait alias&lt;&#x2F;strong&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[blanket_trait]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;HasAsyncErrorType:
&lt;&#x2F;span&gt;&lt;span&gt;    Send + Sync + HasErrorType&amp;lt;Error: Send + Sync&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;{}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;HasAsyncErrorType&lt;&#x2F;code&gt; trait is automatically implemented for any &lt;code&gt;Context&lt;&#x2F;code&gt; type that implements &lt;code&gt;HasErrorType&lt;&#x2F;code&gt;, with the additional constraints that &lt;code&gt;Context: Send + Sync&lt;&#x2F;code&gt; and &lt;code&gt;Context::Error: Send + Sync&lt;&#x2F;code&gt;. This ensures that the &lt;code&gt;Future&lt;&#x2F;code&gt; returned by &lt;code&gt;async&lt;&#x2F;code&gt; functions that capture &lt;code&gt;Context&lt;&#x2F;code&gt; or &lt;code&gt;Context::Error&lt;&#x2F;code&gt; will always implement &lt;code&gt;Send&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;The &lt;code&gt;#[blanket_trait]&lt;&#x2F;code&gt; macro is provided by CGP to shorten trait alias definitions. Behind the scenes, it generates a trivial blanket implementation for &lt;code&gt;HasAsyncErrorType&lt;&#x2F;code&gt; that is activated if all supertrait constraints are satisfied.&lt;&#x2F;p&gt;
&lt;p&gt;Returning to &lt;code&gt;CanHandle&lt;&#x2F;code&gt;, the &lt;code&gt;#[cgp_component]&lt;&#x2F;code&gt; macro also generates the provider trait &lt;code&gt;Handler&lt;&#x2F;code&gt; as follows:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;Handler&amp;lt;Context, Code: Send, Input: Send&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;    Context: HasAsyncErrorType,
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Output&lt;&#x2F;span&gt;&lt;span&gt;: Send;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    async &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;handle(
&lt;&#x2F;span&gt;&lt;span&gt;        context: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;Context,
&lt;&#x2F;span&gt;&lt;span&gt;        _tag: PhantomData&amp;lt;Code&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        input: Input,
&lt;&#x2F;span&gt;&lt;span&gt;    ) -&amp;gt; Result&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;Output, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Context::&lt;&#x2F;span&gt;&lt;span&gt;Error&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;As we can see, the main difference between &lt;code&gt;Handler&lt;&#x2F;code&gt; and &lt;code&gt;CanHandle&lt;&#x2F;code&gt; is that the &lt;code&gt;Self&lt;&#x2F;code&gt; type in &lt;code&gt;CanHandle&lt;&#x2F;code&gt; is replaced with an explicit &lt;code&gt;Context&lt;&#x2F;code&gt; parameter in &lt;code&gt;Handler&lt;&#x2F;code&gt;. The supertrait &lt;code&gt;HasAsyncErrorType&lt;&#x2F;code&gt; now becomes a trait bound for &lt;code&gt;Context&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;abstract-syntax&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#abstract-syntax&quot; aria-label=&quot;Anchor link for: abstract-syntax&quot;&gt;Abstract Syntax&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Now that we understand the interface for the handler component, let&#x27;s look at how the &lt;code&gt;Handler&lt;&#x2F;code&gt; trait is implemented for a basic Hypershell code: &lt;code&gt;SimpleExec&lt;&#x2F;code&gt;. As you might recall, &lt;code&gt;SimpleExec&lt;&#x2F;code&gt; allows the execution of shell commands, using raw bytes for both input and output.&lt;&#x2F;p&gt;
&lt;p&gt;If you navigate to the definition of &lt;code&gt;SimpleExec&lt;&#x2F;code&gt;, all you&#x27;ll find is this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;SimpleExec&amp;lt;CommandPath, Args&amp;gt;(pub PhantomData&amp;lt;(CommandPath, Args)&amp;gt;);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;em&gt;Wait, what?&lt;&#x2F;em&gt; Is that it? Yes, you read that right. There are no extra trait implementations directly tied to &lt;code&gt;SimpleExec&lt;&#x2F;code&gt;. In fact, all types used to &quot;write&quot; a Hypershell program are just dummy structs like this one.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;This implies that how a Hypershell program is &quot;written&quot; is completely &lt;em&gt;decoupled&lt;&#x2F;em&gt; from how the program is &quot;interpreted&quot; or &quot;executed&quot; by a concrete context.&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;In other words, when we explored our examples earlier, &lt;code&gt;HypershellCli&lt;&#x2F;code&gt;, &lt;code&gt;HypershellHttp&lt;&#x2F;code&gt;, or &lt;code&gt;MyApp&lt;&#x2F;code&gt; were just a few of the possible &lt;strong&gt;choices&lt;&#x2F;strong&gt; you could make to run your Hypershell programs. More generally, since all these contexts so far only inherit from &lt;code&gt;HypershellPreset&lt;&#x2F;code&gt;, it means you can also build fully customized presets with different ways to run the programs — for example, by changing how &lt;code&gt;SimpleExec&lt;&#x2F;code&gt; should behave.&lt;&#x2F;p&gt;
&lt;p&gt;More formally, a type like &lt;code&gt;SimpleExec&lt;&#x2F;code&gt; represents the &lt;strong&gt;abstract syntax&lt;&#x2F;strong&gt; of the Hypershell DSL. We then leverage CGP and Rust&#x27;s trait system to act as the &quot;interpreter&quot; for the DSL, dispatching the handling of a program fragment to a specific CGP provider. When you define custom contexts, you&#x27;re essentially building custom &quot;interpreters&quot; used for &quot;executing&quot; the Hypershell program at compile time.&lt;&#x2F;p&gt;
&lt;p&gt;It&#x27;s also worth noting that the pattern introduced here is a highly advanced CGP programming technique. Simpler versions of this pattern exist, such as &lt;strong&gt;higher-order providers&lt;&#x2F;strong&gt;, where traits like &lt;code&gt;Handler&lt;&#x2F;code&gt; wouldn&#x27;t contain the &lt;code&gt;Code&lt;&#x2F;code&gt; parameter, and types like &lt;code&gt;SimpleExec&lt;&#x2F;code&gt; would directly implement the &lt;code&gt;Handler&lt;&#x2F;code&gt; trait. In this simplified pattern, the program&#x27;s execution would be tightly coupled with a specific implementation, making it less modular.&lt;&#x2F;p&gt;
&lt;p&gt;Both higher-order providers and the DSL patterns are advanced CGP techniques not yet covered in the CGP patterns book. While such advanced techniques can sometimes be overkill for building simple applications — especially for beginners just trying to make their applications &lt;em&gt;slightly&lt;&#x2F;em&gt; more modular — they are perfect for building DSLs. This is because it&#x27;s good practice to separate the &lt;strong&gt;syntax&lt;&#x2F;strong&gt; from the &lt;strong&gt;semantics&lt;&#x2F;strong&gt; of programming languages.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;handler-implementation-for-simpleexec&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#handler-implementation-for-simpleexec&quot; aria-label=&quot;Anchor link for: handler-implementation-for-simpleexec&quot;&gt;Handler Implementation for &lt;code&gt;SimpleExec&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;For many new to CGP, it&#x27;s likely unclear how to even begin finding the actual implementation for &lt;code&gt;SimpleExec&lt;&#x2F;code&gt; at this point. We&#x27;ll delve into the wiring specifics later. For now, let&#x27;s jump straight to the default provider Hypershell uses to implement &lt;code&gt;SimpleExec&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_new_provider]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;Context, CommandPath, Args, Input&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    Handler&amp;lt;Context, SimpleExec&amp;lt;CommandPath, Args&amp;gt;, Input&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    for HandleSimpleExec
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;    Context: CanExtractCommandArg&amp;lt;CommandPath&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;        + CanUpdateCommand&amp;lt;Args&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;        + CanRaiseAsyncError&amp;lt;std::io::Error&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;        + &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;#39;a&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; CanWrapAsyncError&amp;lt;CommandNotFound&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;#39;a&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;        + ...,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Context::&lt;&#x2F;span&gt;&lt;span&gt;CommandArg: AsRef&amp;lt;OsStr&amp;gt; + Send,
&lt;&#x2F;span&gt;&lt;span&gt;    CommandPath: Send,
&lt;&#x2F;span&gt;&lt;span&gt;    Args: Send,
&lt;&#x2F;span&gt;&lt;span&gt;    Input: Send + AsRef&amp;lt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u8&lt;&#x2F;span&gt;&lt;span&gt;]&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Output &lt;&#x2F;span&gt;&lt;span&gt;= Vec&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u8&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    async &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;handle(
&lt;&#x2F;span&gt;&lt;span&gt;        context: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;Context,
&lt;&#x2F;span&gt;&lt;span&gt;        _tag: PhantomData&amp;lt;SimpleExec&amp;lt;CommandPath, Args&amp;gt;&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        input: Input,
&lt;&#x2F;span&gt;&lt;span&gt;    ) -&amp;gt; Result&amp;lt;Vec&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u8&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Context::&lt;&#x2F;span&gt;&lt;span&gt;Error&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;If you search for &lt;code&gt;SimpleExec&lt;&#x2F;code&gt; in the Hypershell codebase, you&#x27;ll find &lt;code&gt;HandleSimpleExec&lt;&#x2F;code&gt;. This is a provider that implements &lt;code&gt;Handler&lt;&#x2F;code&gt; specifically for &lt;code&gt;SimpleExec&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;The main method body for &lt;code&gt;HandleSimpleExec&lt;&#x2F;code&gt; isn&#x27;t particularly complex; it largely resembles regular Rust code. It primarily uses Tokio&#x27;s &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;tokio&#x2F;latest&#x2F;tokio&#x2F;process&#x2F;struct.Command.html&quot;&gt;&lt;code&gt;Command&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; to spawn a new child process with the specified arguments. It then writes the &lt;code&gt;input&lt;&#x2F;code&gt; to the process&#x27;s &lt;code&gt;STDIN&lt;&#x2F;code&gt; via the returned &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;tokio&#x2F;latest&#x2F;tokio&#x2F;process&#x2F;struct.Child.html&quot;&gt;&lt;code&gt;Child&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; and calls &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;tokio&#x2F;latest&#x2F;tokio&#x2F;process&#x2F;struct.Child.html#method.wait_with_output&quot;&gt;&lt;code&gt;wait_with_output&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; to retrieve the result from &lt;code&gt;STDOUT&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Therefore, to keep this blog post focused, we&#x27;ve omitted the method body and will instead concentrate on the trait signature&#x27;s integration within Hypershell.&lt;&#x2F;p&gt;
&lt;p&gt;Looking at the generic parameters, you might notice that &lt;code&gt;SimpleExec&amp;lt;CommandPath, Args&amp;gt;&lt;&#x2F;code&gt; is used where &lt;code&gt;Code&lt;&#x2F;code&gt; was previously. In essence, &lt;code&gt;HandleSimpleExec&lt;&#x2F;code&gt; implements &lt;code&gt;Handler&lt;&#x2F;code&gt; if &lt;code&gt;Code&lt;&#x2F;code&gt; is specifically in the form &lt;code&gt;SimpleExec&amp;lt;CommandPath, Args&amp;gt;&lt;&#x2F;code&gt;. We&#x27;re using Rust generics here to &quot;pattern match&quot; on a DSL code fragment and extract its inner &lt;code&gt;CommandPath&lt;&#x2F;code&gt; and &lt;code&gt;Args&lt;&#x2F;code&gt; parameters.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;command-arg-extractor&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#command-arg-extractor&quot; aria-label=&quot;Anchor link for: command-arg-extractor&quot;&gt;Command Arg Extractor&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;Within the &lt;code&gt;where&lt;&#x2F;code&gt; clause, we utilize dependency injection to require other dependencies from the generic &lt;code&gt;Context&lt;&#x2F;code&gt;. The first trait, &lt;code&gt;CanExtractCommandArg&lt;&#x2F;code&gt;, is defined as follows:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_component(CommandArgExtractor)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;CanExtractCommandArg&amp;lt;Arg&amp;gt;: HasCommandArgType {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;extract_command_arg(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self, _phantom: PhantomData&amp;lt;Arg&amp;gt;) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;CommandArg;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[cgp_type]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;HasCommandArgType {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;CommandArg&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;CommandArgExtractor&lt;&#x2F;code&gt; component provides an &lt;code&gt;extract_command_arg&lt;&#x2F;code&gt; method to extract a command-line argument from an &lt;code&gt;Arg&lt;&#x2F;code&gt; code type. This method returns an abstract &lt;code&gt;CommandArg&lt;&#x2F;code&gt; type, which can be instantiated with concrete types like &lt;code&gt;PathBuf&lt;&#x2F;code&gt; or &lt;code&gt;String&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;For example, given code like &lt;code&gt;SimpleExec&amp;lt;StaticArg&amp;lt;Symbol!(&quot;echo&quot;)&amp;gt;, ...&amp;gt;&lt;&#x2F;code&gt;, the &lt;code&gt;Arg&lt;&#x2F;code&gt; type passed to &lt;code&gt;CanExtractCommandArg&lt;&#x2F;code&gt; would be &lt;code&gt;StaticArg&amp;lt;Symbol!(&quot;echo&quot;)&amp;gt;&lt;&#x2F;code&gt;. This means that for &lt;code&gt;HandleSimpleExec&lt;&#x2F;code&gt; to implement &lt;code&gt;Handler&amp;lt;Context, SimpleExec&amp;lt;StaticArg&amp;lt;Symbol!(&quot;echo&quot;)&amp;gt;, ...&amp;gt;, Input&amp;gt;&lt;&#x2F;code&gt;, it requires &lt;code&gt;Context&lt;&#x2F;code&gt; to implement &lt;code&gt;CanExtractCommandArg&amp;lt;StaticArg&amp;lt;Symbol!(&quot;echo&quot;)&amp;gt;&amp;gt;&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Since &lt;code&gt;extract_command_arg&lt;&#x2F;code&gt; returns an abstract &lt;code&gt;CommandArg&lt;&#x2F;code&gt; type, &lt;code&gt;HandleSimpleExec&lt;&#x2F;code&gt; also has an additional constraint: &lt;code&gt;Context::CommandArg: AsRef&amp;lt;OsStr&amp;gt; + Send&lt;&#x2F;code&gt;. This implies that the context can instantiate &lt;code&gt;CommandArg&lt;&#x2F;code&gt; with any concrete type that implements &lt;code&gt;AsRef&amp;lt;OsStr&amp;gt; + Send&lt;&#x2F;code&gt;, such as &lt;code&gt;PathBuf&lt;&#x2F;code&gt; or &lt;code&gt;OsString&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;This also highlights how CGP&#x27;s dependency injection is more powerful than typical OOP dependency injection frameworks. We can use it not only with the main &lt;code&gt;Context&lt;&#x2F;code&gt; type but also with all associated types provided by that context.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;command-updater&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#command-updater&quot; aria-label=&quot;Anchor link for: command-updater&quot;&gt;Command Updater&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;Beyond &lt;code&gt;CanExtractCommandArg&lt;&#x2F;code&gt;, &lt;code&gt;HandleSimpleExec&lt;&#x2F;code&gt; also requires &lt;code&gt;Context: CanUpdateCommand&amp;lt;Args&amp;gt;&lt;&#x2F;code&gt; to handle the CLI arguments passed to the command. Let&#x27;s examine this trait&#x27;s definition:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_component(CommandUpdater)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;CanUpdateCommand&amp;lt;Args&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;update_command(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self, _phantom: PhantomData&amp;lt;Args&amp;gt;, command: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span&gt; Command);
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Similar to &lt;code&gt;CanExtractCommandArg&lt;&#x2F;code&gt;, &lt;code&gt;CanUpdateCommand&lt;&#x2F;code&gt; has a generic &lt;code&gt;Args&lt;&#x2F;code&gt; parameter to process the CLI arguments specified in the Hypershell program. However, instead of returning a value, the &lt;code&gt;update_command&lt;&#x2F;code&gt; method takes a mutable reference to a Tokio &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;tokio&#x2F;latest&#x2F;tokio&#x2F;process&#x2F;struct.Command.html&quot;&gt;&lt;code&gt;Command&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; value.&lt;&#x2F;p&gt;
&lt;p&gt;By directly passing a &lt;code&gt;&amp;amp;mut Command&lt;&#x2F;code&gt;, the DSL can provide different argument syntaxes to configure CLI execution in various ways. For instance, &lt;code&gt;WithArgs&lt;&#x2F;code&gt; allows specifying a list of CLI arguments, but we could also define new syntaxes like &lt;code&gt;WithEnvsAndArgs&lt;&#x2F;code&gt; to allow specifying &lt;em&gt;both&lt;&#x2F;em&gt; CLI arguments and environment variables for the child process.&lt;&#x2F;p&gt;
&lt;p&gt;To see this in action, consider the example code:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;SimpleExec&amp;lt;
&lt;&#x2F;span&gt;&lt;span&gt;    StaticArg&amp;lt;Symbol&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;(&amp;quot;echo&amp;quot;)&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    WithStaticArgs&amp;lt;Product&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;[
&lt;&#x2F;span&gt;&lt;span&gt;        Symbol&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;hello&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;),
&lt;&#x2F;span&gt;&lt;span&gt;        Symbol&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;world!&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;),
&lt;&#x2F;span&gt;&lt;span&gt;    ]&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;Args&lt;&#x2F;code&gt; type given to &lt;code&gt;HandleSimpleExec&lt;&#x2F;code&gt; would be &lt;code&gt;WithStaticArgs&amp;lt;Product![Symbol!(&quot;hello&quot;), Symbol!(&quot;world!&quot;)]&amp;gt;&lt;&#x2F;code&gt;. This means the following constraint needs to be satisfied:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;Context: CanUpdateCommand&amp;lt;WithStaticArgs&amp;lt;Product&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;[Symbol&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;hello&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;), Symbol&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;world!&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;)]&amp;gt;&amp;gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;To keep our focus on the core implementation of &lt;code&gt;HandleSimpleExec&lt;&#x2F;code&gt;, we&#x27;ll omit the detailed workings of argument updates. At a high level, the main idea is to perform a &lt;strong&gt;type-level iteration&lt;&#x2F;strong&gt; on the list passed to &lt;code&gt;WithStaticArgs&lt;&#x2F;code&gt;. So, the implementation would be broken down into two smaller constraints:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;Context: CanUpdateCommand&amp;lt;StaticArg&amp;lt;Symbol&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;(&amp;quot;hello&amp;quot;)&amp;gt;&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    + CanUpdateCommand&amp;lt;StaticArg&amp;lt;Symbol&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;(&amp;quot;world!&amp;quot;)&amp;gt;&amp;gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Once we reach each individual argument, we then use &lt;code&gt;CanExtractCommandArg&lt;&#x2F;code&gt; to extract the argument and subsequently call &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;tokio&#x2F;latest&#x2F;tokio&#x2F;process&#x2F;struct.Command.html#method.arg&quot;&gt;&lt;code&gt;Command::arg&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; to add it to the &lt;code&gt;Command&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;It&#x27;s worth noting that the &lt;code&gt;CanUpdateCommand&lt;&#x2F;code&gt; trait is tightly coupled with the Tokio &lt;code&gt;Command&lt;&#x2F;code&gt; type. This means the trait cannot be reused if alternative implementations execute CLI commands without using Tokio. However, this is perfectly acceptable, and nothing in CGP prevents us from defining less-abstract interfaces.&lt;&#x2F;p&gt;
&lt;p&gt;Instead, CGP&#x27;s main advantage is that a trait like &lt;code&gt;CanUpdateCommand&lt;&#x2F;code&gt; can be included by specific providers that need it via dependency injection. This means that if the involved providers aren&#x27;t wired with the concrete context, then the context doesn&#x27;t need to implement a trait like &lt;code&gt;CanUpdateCommand&lt;&#x2F;code&gt; either.&lt;&#x2F;p&gt;
&lt;p&gt;In other words, a CGP trait like &lt;code&gt;CanUpdateCommand&lt;&#x2F;code&gt; might be tightly coupled with Tokio, but the trait itself remains fully decoupled from the rest of Hypershell. Consequently, it wouldn&#x27;t prevent Hypershell from having alternative implementations that don&#x27;t use Tokio at all.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;error-handling&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#error-handling&quot; aria-label=&quot;Anchor link for: error-handling&quot;&gt;Error Handling&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;Within the &lt;code&gt;where&lt;&#x2F;code&gt; clause for &lt;code&gt;HandleSimpleExec&lt;&#x2F;code&gt;, you&#x27;ll notice it also requires &lt;code&gt;Context&lt;&#x2F;code&gt; to implement &lt;code&gt;CanRaiseAsyncError&amp;lt;std::io::Error&amp;gt;&lt;&#x2F;code&gt;. Here, we&#x27;ll briefly explore how CGP offers a distinct and more modular approach to error handling.&lt;&#x2F;p&gt;
&lt;p&gt;When calling upstream Tokio methods, such as &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;tokio&#x2F;latest&#x2F;tokio&#x2F;process&#x2F;struct.Command.html#method.spawn&quot;&gt;&lt;code&gt;Command::spawn&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;, the method returns a &lt;code&gt;std::io::Error&lt;&#x2F;code&gt;. However, since the method signature requires an abstract &lt;code&gt;Context::Error&lt;&#x2F;code&gt; to be returned in case of errors, we need a way to convert, or &quot;upcast&quot;, the &lt;code&gt;std::io::Error&lt;&#x2F;code&gt; into &lt;code&gt;Context::Error&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;A naive approach to error handling would be to require a &lt;strong&gt;concrete error type&lt;&#x2F;strong&gt; for the implementation. For example, we could modify &lt;code&gt;CanHandle&lt;&#x2F;code&gt;&#x27;s method signature to return &lt;code&gt;anyhow::Error&lt;&#x2F;code&gt; instead of &lt;code&gt;Context::Error&lt;&#x2F;code&gt;. Alternatively, we could add a constraint &lt;code&gt;Context: HasErrorType&amp;lt;Error = anyhow::Error&amp;gt;&lt;&#x2F;code&gt; to &lt;em&gt;force&lt;&#x2F;em&gt; the context to provide a specific error type, such as &lt;code&gt;anyhow::Error&lt;&#x2F;code&gt;. However, doing so would introduce unnecessary &lt;em&gt;coupling&lt;&#x2F;em&gt; between the provider implementation and the concrete error type, preventing the context from reusing the provider if it wished to choose a different error type for the application.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;error-raisers&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#error-raisers&quot; aria-label=&quot;Anchor link for: error-raisers&quot;&gt;Error Raisers&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;Instead, CGP provides the &lt;strong&gt;&lt;code&gt;ErrorRaiser&lt;&#x2F;code&gt; component&lt;&#x2F;strong&gt; as a way for context-generic implementations to handle errors without requiring access to the concrete error type. The trait is defined as follows:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_component(ErrorRaiser)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;CanRaiseError&amp;lt;SourceError&amp;gt;: HasErrorType {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;raise_error(error: SourceError) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;Error;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;You can think of &lt;code&gt;CanRaiseError&lt;&#x2F;code&gt; as a more flexible form of Rust&#x27;s &lt;code&gt;From&lt;&#x2F;code&gt; trait for error handling. In fact, if a &lt;code&gt;From&lt;&#x2F;code&gt; instance exists for all &lt;code&gt;SourceError&lt;&#x2F;code&gt;s used by an application, the provider can be trivially implemented:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_new_provider]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;Context, SourceError&amp;gt; ErrorRaiser&amp;lt;Context, SourceError&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;RaiseFrom
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;    Context: HasErrorType,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Context::&lt;&#x2F;span&gt;&lt;span&gt;Error: From&amp;lt;SourceError&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;raise_error(e: SourceError) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Context::&lt;&#x2F;span&gt;&lt;span&gt;Error {
&lt;&#x2F;span&gt;&lt;span&gt;        e.into()
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;When programming with CGP, it&#x27;s generally preferred to use &lt;code&gt;CanRaiseError&lt;&#x2F;code&gt; rather than directly using &lt;code&gt;From&lt;&#x2F;code&gt; to convert a source error to the abstract &lt;code&gt;Context::Error&lt;&#x2F;code&gt;. This is because &lt;code&gt;From&lt;&#x2F;code&gt; is a plain Rust trait subject to coherence rules, making it challenging to customize if a &lt;code&gt;From&lt;&#x2F;code&gt; instance isn&#x27;t implemented by a third-party error type like &lt;code&gt;anyhow::Error&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Conversely, using &lt;code&gt;CanRaiseError&lt;&#x2F;code&gt; grants significantly more freedom to use anything as a &lt;code&gt;SourceError&lt;&#x2F;code&gt; without worrying about compatibility. For instance, it&#x27;s common for context-generic implementations to use &lt;code&gt;CanRaiseError&amp;lt;String&amp;gt;&lt;&#x2F;code&gt; or even &lt;code&gt;CanRaiseError&amp;lt;&amp;amp;&#x27;static str&amp;gt;&lt;&#x2F;code&gt;, especially during early prototyping phases. This would cause issues if we instead required &lt;code&gt;Context::Error: From&amp;lt;String&amp;gt;&lt;&#x2F;code&gt;, as types like &lt;code&gt;anyhow::Error&lt;&#x2F;code&gt; do not implement &lt;code&gt;From&amp;lt;String&amp;gt;&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Returning to our example, with the &lt;code&gt;CanRaiseError&amp;lt;std::io::Error&amp;gt;&lt;&#x2F;code&gt; constraint in place, we can now call &lt;code&gt;Command::spawn()&lt;&#x2F;code&gt; inside &lt;code&gt;HandleSimpleExec&lt;&#x2F;code&gt; and handle the error using &lt;code&gt;.map_err(Context::raise_error)&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; child = command.spawn().map_err(Context::raise_error)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;?&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;default-error-type&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#default-error-type&quot; aria-label=&quot;Anchor link for: default-error-type&quot;&gt;Default Error Type&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;In the default Hypershell contexts, such as &lt;code&gt;HypershellCli&lt;&#x2F;code&gt;, we use &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;anyhow&#x2F;latest&#x2F;anyhow&#x2F;struct.Error.html&quot;&gt;&lt;code&gt;anyhow::Error&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; along with providers from the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;cgp-error-anyhow&#x2F;&quot;&gt;&lt;code&gt;cgp-error-anyhow&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; crate to handle errors from different parts of the application.&lt;&#x2F;p&gt;
&lt;p&gt;However, just like almost everything else in CGP, an application can choose different error providers. For example, it could use &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;eyre&#x2F;latest&#x2F;eyre&#x2F;struct.Report.html&quot;&gt;&lt;code&gt;eyre::Report&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; with &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;cgp-error-eyre&quot;&gt;&lt;code&gt;cgp-error-eyre&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; to handle errors from Hypershell programs. This is especially useful if users want to embed Hypershell programs within larger applications that use their own structured error types defined with &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;thiserror&quot;&gt;&lt;code&gt;thiserror&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;error-wrappers&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#error-wrappers&quot; aria-label=&quot;Anchor link for: error-wrappers&quot;&gt;Error Wrappers&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;In the &lt;code&gt;where&lt;&#x2F;code&gt; clause for &lt;code&gt;HandleSimpleExec&lt;&#x2F;code&gt;, we also see a constraint &lt;code&gt;Context: for&amp;lt;&#x27;a&amp;gt; CanWrapAsyncError&amp;lt;CommandNotFound&amp;lt;&#x27;a&amp;gt;&amp;gt;&lt;&#x2F;code&gt;. Let&#x27;s explore what this entails.&lt;&#x2F;p&gt;
&lt;p&gt;CGP also provides a supplementary &lt;strong&gt;&lt;code&gt;ErrorWrapper&lt;&#x2F;code&gt; component&lt;&#x2F;strong&gt;, which offers similar functionality to &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;anyhow&#x2F;1.0.98&#x2F;anyhow&#x2F;struct.Error.html#method.context&quot;&gt;&lt;code&gt;anyhow::Error::context&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; for adding additional details to an error. The trait is defined as follows:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_component(ErrorWrapper)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;CanWrapError&amp;lt;Detail&amp;gt;: HasErrorType {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;wrap_error(error: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;Error, detail: Detail) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;Error;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Using &lt;code&gt;CanWrapError&lt;&#x2F;code&gt;, we can, for instance, add extra details on top of a &lt;code&gt;std::io::Error&lt;&#x2F;code&gt; to explain that the error occurred while attempting to spawn the child process. A common frustration with the base I&#x2F;O error is that when an executable isn&#x27;t found at the specified command path, only a generic &lt;code&gt;NotFound&lt;&#x2F;code&gt; error is returned without details about &lt;em&gt;what&lt;&#x2F;em&gt; wasn&#x27;t found. Using &lt;code&gt;CanWrapAsyncError&lt;&#x2F;code&gt;, we can now add specific information about the missing command to the error:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; child = command.spawn().map_err(|e| {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; is_not_found = e.kind() == ErrorKind::NotFound;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; e = Context::raise_error(e);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt; is_not_found {
&lt;&#x2F;span&gt;&lt;span&gt;        Context::wrap_error(e, CommandNotFound { command: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;command })
&lt;&#x2F;span&gt;&lt;span&gt;    } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;else &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        e
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;})&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;?&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In this example, we first check if the error kind returned from &lt;code&gt;command.spawn()&lt;&#x2F;code&gt; is &lt;code&gt;ErrorKind::NotFound&lt;&#x2F;code&gt;. We then use &lt;code&gt;raise_error&lt;&#x2F;code&gt; to convert the error into &lt;code&gt;Context::Error&lt;&#x2F;code&gt;. After that, if the error kind was &lt;code&gt;NotFound&lt;&#x2F;code&gt;, we call &lt;code&gt;wrap_error&lt;&#x2F;code&gt; to wrap the error with a custom &lt;code&gt;CommandNotFound&lt;&#x2F;code&gt; detail, defined as follows:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;CommandNotFound&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;#39;a&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;command: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;#39;a&lt;&#x2F;span&gt;&lt;span&gt; Command,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;#39;a&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; Debug &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;CommandNotFound&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;#39;a&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;fmt(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self, f: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;core::fmt::Formatter&amp;lt;&amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;_&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;) -&amp;gt; core::fmt::Result {
&lt;&#x2F;span&gt;&lt;span&gt;        write!(
&lt;&#x2F;span&gt;&lt;span&gt;            f,
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;command not found: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;            self.command.as_std().get_program().to_string_lossy(),
&lt;&#x2F;span&gt;&lt;span&gt;        )
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;CommandNotFound&lt;&#x2F;code&gt; struct holds a reference to the &lt;code&gt;Command&lt;&#x2F;code&gt; we&#x27;re trying to run. We pass the full &lt;code&gt;Command&lt;&#x2F;code&gt; struct here so that a potential &lt;code&gt;ErrorWrapper&lt;&#x2F;code&gt; implementation can display customized error messages about the failing command. We also provide a default &lt;code&gt;Debug&lt;&#x2F;code&gt; implementation for &lt;code&gt;CommandNotFound&lt;&#x2F;code&gt;, which prints only the program path without additional details about the full command.&lt;&#x2F;p&gt;
&lt;p&gt;Similar to &lt;code&gt;ErrorRaiser&lt;&#x2F;code&gt;, CGP allows the &lt;code&gt;ErrorWrapper&lt;&#x2F;code&gt; implementation to be chosen by the context to handle errors differently. For instance, the &lt;code&gt;HypershellCli&lt;&#x2F;code&gt; context uses the &lt;code&gt;DebugAnyhowError&lt;&#x2F;code&gt; provider from &lt;code&gt;cgp-error-anyhow&lt;&#x2F;code&gt;. This provider builds a string using the &lt;code&gt;Debug&lt;&#x2F;code&gt; implementation and then calls &lt;code&gt;anyhow::Error::context&lt;&#x2F;code&gt; with the formatted string. However, if desired, a user of Hypershell is free to override this behavior, such as printing the full command or wrapping the error in other ways.&lt;&#x2F;p&gt;
&lt;p&gt;Since &lt;code&gt;CommandNotFound&lt;&#x2F;code&gt; contains a lifetime, when we specify the constraint, we need to add a &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nomicon&#x2F;hrtb.html&quot;&gt;&lt;strong&gt;higher-ranked trait bound (HRTB)&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt; (&lt;code&gt;for&amp;lt;&#x27;a&amp;gt;&lt;&#x2F;code&gt;) to the constraint. This ensures we can always wrap the error for any lifetime. While it&#x27;s possible to pass an owned &lt;code&gt;Command&lt;&#x2F;code&gt; value without a lifetime here, this isn&#x27;t always feasible when the detail originates from argument references. Furthermore, using a reference encourages the wrapper handler to extract only essential details, avoiding the bloating of the error value with large wrapped values.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;input-type&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#input-type&quot; aria-label=&quot;Anchor link for: input-type&quot;&gt;Input Type&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;The &lt;code&gt;Handler&lt;&#x2F;code&gt; implementation for &lt;code&gt;HandleSimpleExec&lt;&#x2F;code&gt; is designed to work with any generic &lt;code&gt;Input&lt;&#x2F;code&gt; type, provided it satisfies the &lt;code&gt;Input: Send + AsRef&amp;lt;[u8]&amp;gt;&lt;&#x2F;code&gt; constraint. This means that besides &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;&#x2F;code&gt;, you can also pass in compatible types like &lt;code&gt;String&lt;&#x2F;code&gt;, &lt;code&gt;Bytes&lt;&#x2F;code&gt;, or &lt;code&gt;&amp;amp;&#x27;a [u8]&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;However, this constraint also implies that &lt;code&gt;HandleSimpleExec&lt;&#x2F;code&gt; cannot directly accept inputs from stream types that implement traits like &lt;code&gt;AsyncRead&lt;&#x2F;code&gt;. If you try to form a pipeline like &lt;code&gt;StreamingExec&amp;lt;...&amp;gt; | SimpleExec&amp;lt;...&amp;gt;&lt;&#x2F;code&gt;, it would result in a compile-time error due to Hypershell&#x27;s strongly typed nature.&lt;&#x2F;p&gt;
&lt;p&gt;One way to work around this is to incorporate explicit &lt;strong&gt;adapters&lt;&#x2F;strong&gt; provided by Hypershell into your pipeline, transforming the output before it&#x27;s passed as the next input:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;StreamingExec&amp;lt;...&amp;gt; | StreamToBytes | SimpleExec&amp;lt;...&amp;gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The key takeaway here is that the supported &lt;code&gt;Input&lt;&#x2F;code&gt; and &lt;code&gt;Output&lt;&#x2F;code&gt; types in a Hypershell program are determined by the chosen &lt;strong&gt;concrete provider&lt;&#x2F;strong&gt;, not by the abstract syntax itself. A concrete context can choose to wire a different provider to handle &lt;code&gt;SimpleExec&lt;&#x2F;code&gt;, in which case the supported input&#x2F;output types for &lt;code&gt;SimpleExec&lt;&#x2F;code&gt; might change.&lt;&#x2F;p&gt;
&lt;p&gt;Nevertheless, just as with standard programming languages, it&#x27;s possible to define a &lt;strong&gt;standard&lt;&#x2F;strong&gt; around the language syntax to impose expectations and requirements on how the program should behave. For example, a language specification for Hypershell might state that it should always be possible to pipe the output from &lt;code&gt;StreamingExec&lt;&#x2F;code&gt; to &lt;code&gt;SimpleExec&lt;&#x2F;code&gt;, and vice versa. In such scenarios, &lt;code&gt;HandleSimpleExec&lt;&#x2F;code&gt; alone might not suffice to handle all valid Hypershell programs.&lt;&#x2F;p&gt;
&lt;p&gt;But as we&#x27;ll learn later, it&#x27;s also possible to use CGP&#x27;s &lt;strong&gt;generic dispatcher&lt;&#x2F;strong&gt; pattern to perform &lt;strong&gt;ad hoc dispatch&lt;&#x2F;strong&gt; to different handlers, based on the &lt;code&gt;Input&lt;&#x2F;code&gt; type. In such cases, &lt;code&gt;HandleSimpleExec&lt;&#x2F;code&gt; would become part of a larger implementation capable of handling all possible &lt;code&gt;Input&lt;&#x2F;code&gt; types encountered in a Hypershell program.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;modularity-of-handlesimpleexec&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#modularity-of-handlesimpleexec&quot; aria-label=&quot;Anchor link for: modularity-of-handlesimpleexec&quot;&gt;Modularity of &lt;code&gt;HandleSimpleExec&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;If you examine the entire implementation of &lt;code&gt;HandleSimpleExec&lt;&#x2F;code&gt;, you&#x27;ll find that, apart from its dependencies on Tokio, CGP, and Hypershell&#x27;s core traits, the implementation is completely &lt;strong&gt;decoupled&lt;&#x2F;strong&gt; from the rest of the application. In fact, you could move this implementation code to an entirely new crate, include only these three dependencies, and everything would still function correctly.&lt;&#x2F;p&gt;
&lt;p&gt;This illustrates how code written with CGP typically has an &lt;strong&gt;inverted structure&lt;&#x2F;strong&gt; in its dependency graphs. Instead of focusing on &lt;strong&gt;concrete types&lt;&#x2F;strong&gt;, CGP begins with &lt;strong&gt;abstract implementations&lt;&#x2F;strong&gt; and only defines the concrete types at the final stage of the process. This significantly reduces bloat in the dependency graph, as each sub-crate can be compiled with only the exact dependencies it needs.&lt;&#x2F;p&gt;
&lt;p&gt;To demonstrate this benefit in action, let&#x27;s look at how Hypershell structures its crate dependencies:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;hypershell-components&lt;&#x2F;code&gt;&lt;&#x2F;strong&gt;: Defines DSL types and CGP component interfaces, depending solely on &lt;code&gt;cgp&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;hypershell-tokio-components&lt;&#x2F;code&gt;&lt;&#x2F;strong&gt;: Implements Tokio-specific CLI providers and component interfaces. Depends on &lt;code&gt;cgp&lt;&#x2F;code&gt;, &lt;code&gt;hypershell-components&lt;&#x2F;code&gt;, and &lt;code&gt;tokio&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;hypershell-reqwest-components&lt;&#x2F;code&gt;&lt;&#x2F;strong&gt;: Implements Reqwest-specific HTTP providers and component interfaces. Depends on &lt;code&gt;cgp&lt;&#x2F;code&gt;, &lt;code&gt;hypershell-components&lt;&#x2F;code&gt;, and &lt;code&gt;reqwest&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;hypershell&lt;&#x2F;code&gt;&lt;&#x2F;strong&gt;: Defines concrete contexts and wiring, depending on all other Hypershell crates.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;As you can see, even though the full Hypershell application uses both Tokio and Reqwest, the &lt;code&gt;hypershell-tokio-components&lt;&#x2F;code&gt; crate can be built without &lt;code&gt;reqwest&lt;&#x2F;code&gt; being part of its dependencies. While this might seem minor with only two crates, consider a large Rust application with hundreds of dependencies: CGP makes it much easier to break down dependencies, ensuring that each part of the implementation is compiled with only the precise dependencies it requires.&lt;&#x2F;p&gt;
&lt;p&gt;This level of modularity also means it&#x27;s possible to build alternative Hypershell implementations that completely remove &lt;code&gt;tokio&lt;&#x2F;code&gt; from their dependencies. For example, you could use &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;smol-rs&#x2F;async-process&quot;&gt;&lt;code&gt;async-process&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; with &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;smol&#x2F;latest&#x2F;smol&#x2F;&quot;&gt;&lt;code&gt;smol&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; as the runtime to spawn CLI processes. Of course, since &lt;code&gt;reqwest&lt;&#x2F;code&gt; also depends on &lt;code&gt;tokio&lt;&#x2F;code&gt;, fully removing &lt;code&gt;tokio&lt;&#x2F;code&gt; would also require substituting &lt;code&gt;hypershell-reqwest-components&lt;&#x2F;code&gt; with an alternative HTTP library like &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;isahc&quot;&gt;&lt;code&gt;isahc&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;It&#x27;s also worth highlighting that with CGP, there&#x27;s no need to use &lt;strong&gt;feature flags&lt;&#x2F;strong&gt; to switch between underlying implementations. Because CGP providers can be implemented in complete isolation from one another, you can simply create new crates that don&#x27;t depend on the original providers and define new contexts wired with the alternative providers.&lt;&#x2F;p&gt;
&lt;p&gt;This generic approach is also less error-prone than feature flags, as &lt;em&gt;all&lt;&#x2F;em&gt; alternative implementations can coexist and be tested simultaneously, unlike having multiple &lt;em&gt;variants&lt;&#x2F;em&gt; of the code that must be tested separately for each combination of feature flags.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;wiring-for-simpleexec&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#wiring-for-simpleexec&quot; aria-label=&quot;Anchor link for: wiring-for-simpleexec&quot;&gt;Wiring for &lt;code&gt;SimpleExec&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;At this point, we&#x27;ve learned how &lt;code&gt;HandleSimpleExec&lt;&#x2F;code&gt; is implemented to handle the &lt;code&gt;SimpleExec&lt;&#x2F;code&gt; syntax. Next, let&#x27;s look into how the &lt;code&gt;HandleSimpleExec&lt;&#x2F;code&gt; provider is wired up so that it&#x27;s accessible from concrete contexts like &lt;code&gt;HypershellCli&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;generic-dispatcher&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#generic-dispatcher&quot; aria-label=&quot;Anchor link for: generic-dispatcher&quot;&gt;Generic Dispatcher&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;As we know, besides &lt;code&gt;SimpleExec&lt;&#x2F;code&gt;, there are other Hypershell syntaxes such as &lt;code&gt;StreamingExec&lt;&#x2F;code&gt; and &lt;code&gt;SimpleHttpRequest&lt;&#x2F;code&gt;. However, since &lt;code&gt;HandleSimpleExec&lt;&#x2F;code&gt; only implements &lt;code&gt;Handler&lt;&#x2F;code&gt; for &lt;code&gt;SimpleExec&lt;&#x2F;code&gt;, we can&#x27;t directly wire it as the provider for &lt;em&gt;all&lt;&#x2F;em&gt; generic parameters of &lt;code&gt;Handler&lt;&#x2F;code&gt;. Instead, we need an intermediary provider, known as a &lt;strong&gt;generic dispatcher&lt;&#x2F;strong&gt;, to route the handling logic to different providers based on the generic &lt;code&gt;Code&lt;&#x2F;code&gt; parameter.&lt;&#x2F;p&gt;
&lt;p&gt;The pattern for provider dispatching based on generic parameters is common enough that CGP offers options to automatically derive them within the &lt;code&gt;#[cgp_component]&lt;&#x2F;code&gt; macro. For the &lt;code&gt;Handler&lt;&#x2F;code&gt; component, a dispatcher called &lt;strong&gt;&lt;code&gt;UseDelegate&lt;&#x2F;code&gt;&lt;&#x2F;strong&gt; is provided to manage provider dispatching based on the &lt;code&gt;Code&lt;&#x2F;code&gt; parameter.&lt;&#x2F;p&gt;
&lt;p&gt;In CGP, we can declare the dispatching logic in a similar way to normal provider delegation using the &lt;code&gt;delegate_components!&lt;&#x2F;code&gt; macro. The following shows a simplified wiring of providers for &lt;code&gt;HypershellCli&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_context(HypershellCliComponents)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;HypershellCli;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;delegate_components! {
&lt;&#x2F;span&gt;&lt;span&gt;    HypershellCliComponents {
&lt;&#x2F;span&gt;&lt;span&gt;        HandlerComponent:
&lt;&#x2F;span&gt;&lt;span&gt;            UseDelegate&amp;lt;HypershellHandlerComponents&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;HypershellHandlerComponents;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;delegate_components! {
&lt;&#x2F;span&gt;&lt;span&gt;    HypershellHandlerComponents {
&lt;&#x2F;span&gt;&lt;span&gt;        &amp;lt;CommandPath, Args&amp;gt; SimpleExec&amp;lt;CommandPath, Args&amp;gt;:
&lt;&#x2F;span&gt;&lt;span&gt;            HandleSimpleExec,
&lt;&#x2F;span&gt;&lt;span&gt;        &amp;lt;CommandPath, Args&amp;gt; StreamingExec&amp;lt;CommandPath, Args&amp;gt;:
&lt;&#x2F;span&gt;&lt;span&gt;            HandleStreamingExec,
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The first part of the wiring declaration is identical to the hello world example we saw earlier. We define a &lt;code&gt;HypershellCli&lt;&#x2F;code&gt; struct using &lt;code&gt;#[cgp_context]&lt;&#x2F;code&gt; to make it a CGP context with &lt;code&gt;HypershellCliComponents&lt;&#x2F;code&gt; as its provider. We then use &lt;code&gt;delegate_components!&lt;&#x2F;code&gt; on &lt;code&gt;HypershellCliComponents&lt;&#x2F;code&gt; to set up the wiring for all providers used by the context. However, for the &lt;code&gt;HandlerComponent&lt;&#x2F;code&gt; wiring, we map it to &lt;code&gt;UseDelegate&amp;lt;HypershellHandlerComponents&amp;gt;&lt;&#x2F;code&gt; instead of directly to &lt;code&gt;HandleSimpleExec&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Following that, we define a new struct &lt;code&gt;HypershellHandlerComponents&lt;&#x2F;code&gt; and use &lt;code&gt;delegate_components!&lt;&#x2F;code&gt; to define some mappings on it. But this time, instead of mapping CGP component names, we map the Hypershell syntax types to their respective providers. In the first entry, we map &lt;code&gt;SimpleExec&lt;&#x2F;code&gt; to &lt;code&gt;HandleSimpleExec&lt;&#x2F;code&gt;, and then map &lt;code&gt;StreamingExec&lt;&#x2F;code&gt; to a &lt;code&gt;HandleStreamingExec&lt;&#x2F;code&gt; provider, which is implemented separately in Hypershell.&lt;&#x2F;p&gt;
&lt;p&gt;In the mappings for &lt;code&gt;HypershellHandlerComponents&lt;&#x2F;code&gt;, you&#x27;ll also notice the key for &lt;code&gt;SimpleExec&lt;&#x2F;code&gt; specified as &lt;code&gt;&amp;lt;CommandPath, Args&amp;gt; SimpleExec&amp;lt;CommandPath, Args&amp;gt;&lt;&#x2F;code&gt;. The initial part, &lt;code&gt;&amp;lt;CommandPath, Args&amp;gt;&lt;&#x2F;code&gt;, is used as additional &lt;strong&gt;generic parameters&lt;&#x2F;strong&gt; for the mapping. This is because we want to map &lt;em&gt;all&lt;&#x2F;em&gt; possible uses of &lt;code&gt;SimpleExec&lt;&#x2F;code&gt; to &lt;code&gt;HandleSimpleExec&lt;&#x2F;code&gt;. If these weren&#x27;t specified, Rust would instead try to find &lt;em&gt;specific&lt;&#x2F;em&gt; concrete Rust types named &lt;code&gt;CommandPath&lt;&#x2F;code&gt; and &lt;code&gt;Args&lt;&#x2F;code&gt; imported within the module, leading to errors if it couldn&#x27;t find them.&lt;&#x2F;p&gt;
&lt;p&gt;Essentially, we&#x27;re defining &lt;code&gt;HypershellHandlerComponents&lt;&#x2F;code&gt; purely as a &lt;strong&gt;type-level key-value map&lt;&#x2F;strong&gt;, and then using it as a &lt;strong&gt;lookup table&lt;&#x2F;strong&gt; for &lt;code&gt;UseDelegate&lt;&#x2F;code&gt;. We can also see that with &lt;em&gt;types&lt;&#x2F;em&gt; as keys, we gain additional expressivity to specify and capture generic parameters in the keys, which wouldn&#x27;t be possible with value-level lookup tables.&lt;&#x2F;p&gt;
&lt;p&gt;Now that we&#x27;ve walked through the wiring declaration, let&#x27;s visualize how CGP actually implements a trait instance of &lt;code&gt;CanHandle&amp;lt;SimpleExec&amp;lt;Command, Args&amp;gt;, Input&amp;gt;&lt;&#x2F;code&gt; for the &lt;code&gt;HypershellCli&lt;&#x2F;code&gt; context:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;blog&#x2F;images&#x2F;delegate-code.png&quot; alt=&quot;Diagram&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;The first two parts of this diagram are similar to how the implementation was done for the &lt;code&gt;Greeter&lt;&#x2F;code&gt; component example earlier. For the &lt;code&gt;HypershellCli&lt;&#x2F;code&gt; context to implement &lt;code&gt;CanHandle&amp;lt;SimpleExec&amp;lt;Command, Args&amp;gt;, Input&amp;gt;&lt;&#x2F;code&gt;, Rust&#x27;s trait system would first determine that &lt;code&gt;HypershellCli&lt;&#x2F;code&gt; implements &lt;code&gt;HasProvider&lt;&#x2F;code&gt;, which points to &lt;code&gt;HypershellCliComponents&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;The trait system then attempts to find an implementation of &lt;code&gt;Handler&amp;lt;HypershellCli, SimpleExec&amp;lt;Command, Args&amp;gt;, Input&amp;gt;&lt;&#x2F;code&gt; for &lt;code&gt;HypershellCliComponents&lt;&#x2F;code&gt;. Next, it sees that &lt;code&gt;HypershellCliComponents&lt;&#x2F;code&gt; implements &lt;code&gt;DelegateComponent&amp;lt;HandlerComponent&amp;gt;&lt;&#x2F;code&gt;, which points to &lt;code&gt;UseDelegate&amp;lt;HypershellHandlerComponents&amp;gt;&lt;&#x2F;code&gt;, and so the implementation lookup continues there.&lt;&#x2F;p&gt;
&lt;p&gt;This time, the trait system finds that &lt;code&gt;UseDelegate&amp;lt;HypershellHandlerComponents&amp;gt;&lt;&#x2F;code&gt; has a candidate implementation for &lt;code&gt;Handler&amp;lt;HypershellCli, SimpleExec&amp;lt;Command, Args&amp;gt;, Input&amp;gt;&lt;&#x2F;code&gt;. However, for that to be implemented, &lt;code&gt;UseDelegate&lt;&#x2F;code&gt; requires &lt;code&gt;HypershellHandlerComponents&lt;&#x2F;code&gt; to contain a lookup entry for the &lt;code&gt;Code&lt;&#x2F;code&gt; parameter. That is, &lt;code&gt;HypershellHandlerComponents&lt;&#x2F;code&gt; should implement &lt;code&gt;DelegateComponent&amp;lt;SimpleExec&amp;lt;Command, Args&amp;gt;&amp;gt;&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Finally, the system finds that &lt;code&gt;HypershellHandlerComponents&lt;&#x2F;code&gt; contains the specified entry, which points to &lt;code&gt;HandleSimpleExec&lt;&#x2F;code&gt;. It then confirms that &lt;code&gt;HandleSimpleExec&lt;&#x2F;code&gt; implements &lt;code&gt;Handler&amp;lt;HypershellCli, SimpleExec&amp;lt;Command, Args&amp;gt;, Input&amp;gt;&lt;&#x2F;code&gt;, thus completing the implementation.&lt;&#x2F;p&gt;
&lt;p&gt;Compared to the earlier &lt;code&gt;Greeter&lt;&#x2F;code&gt; example, the delegation chain for &lt;code&gt;SimpleExec&lt;&#x2F;code&gt; handling goes four levels deep instead of three. Aside from that, the underlying implementation for &lt;code&gt;UseDelegate&lt;&#x2F;code&gt; follows the same pattern as the blanket implementation of the &lt;code&gt;Handler&lt;&#x2F;code&gt; provider trait. However, instead of being a blanket implementation, &lt;code&gt;UseDelegate&lt;&#x2F;code&gt; is implemented as a &lt;strong&gt;context-generic provider&lt;&#x2F;strong&gt; for &lt;code&gt;Handler&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Furthermore, beyond &lt;code&gt;Handler&lt;&#x2F;code&gt;, the same pattern has been implemented by &lt;code&gt;UseDelegate&lt;&#x2F;code&gt; for many other CGP traits, such as &lt;code&gt;ErrorRaiser&lt;&#x2F;code&gt;, making it a &lt;strong&gt;universal pattern&lt;&#x2F;strong&gt; applicable to any CGP trait that contains additional generic parameters.&lt;&#x2F;p&gt;
&lt;p&gt;The implementation of &lt;code&gt;UseDelegate&lt;&#x2F;code&gt; also demonstrates CGP&#x27;s power, showing that once coherence restrictions are lifted, entirely new categories of patterns can be defined to work consistently across many traits. In addition to &lt;code&gt;UseDelegate&lt;&#x2F;code&gt;, many other CGP patterns have been implemented as context-generic providers, such as &lt;code&gt;UseContext&lt;&#x2F;code&gt;, &lt;code&gt;UseType&lt;&#x2F;code&gt;, &lt;code&gt;UseField&lt;&#x2F;code&gt;, &lt;code&gt;WithProvider&lt;&#x2F;code&gt;, and more.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;cgp-presets&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#cgp-presets&quot; aria-label=&quot;Anchor link for: cgp-presets&quot;&gt;CGP Presets&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Earlier, we saw a simplified way to wire &lt;code&gt;HandleSimpleExec&lt;&#x2F;code&gt; for the &lt;code&gt;HypershellCli&lt;&#x2F;code&gt; context. However, as the initial examples showed, we want to reuse these same wirings for other contexts like &lt;code&gt;HypershellHttp&lt;&#x2F;code&gt; and &lt;code&gt;MyApp&lt;&#x2F;code&gt;. Moreover, given Hypershell&#x27;s modularity, we want to easily extend or customize existing component wirings and create new collections of wirings that can be shared within the community.&lt;&#x2F;p&gt;
&lt;p&gt;CGP offers &lt;strong&gt;presets&lt;&#x2F;strong&gt; as a powerful mechanism to build these extensible component wirings. At a high level, a CGP preset is a &lt;strong&gt;module&lt;&#x2F;strong&gt; that contains a &lt;strong&gt;type-level key-value map&lt;&#x2F;strong&gt;, along with traits and macros that support &lt;strong&gt;operations&lt;&#x2F;strong&gt; on this map.&lt;&#x2F;p&gt;
&lt;p&gt;The operations possible on a preset share some conceptual similarities with &lt;strong&gt;inheritance&lt;&#x2F;strong&gt; in object-oriented programming (OOP), at least from an implementation perspective. More plainly, it allows for &lt;strong&gt;iteration&lt;&#x2F;strong&gt; over the &lt;strong&gt;keys&lt;&#x2F;strong&gt; stored in the preset&#x27;s type-level key-value map. As we know from basic algorithm courses, if we can iterate over a map&#x27;s keys, we can then construct &lt;em&gt;new&lt;&#x2F;em&gt; maps that share the same keys as the original. To put it even more simply, CGP presets allow us to perform the Rust equivalent of &lt;code&gt;map.iter().filter_map()&lt;&#x2F;code&gt; on a &lt;code&gt;HashMap&lt;&#x2F;code&gt; value, but at the type level.&lt;&#x2F;p&gt;
&lt;p&gt;Now that we understand how presets work at a high level, it should be clearer how they support inheritance-like features in CGP. CGP supports two kinds of inheritance operations. The first is a simplified one-level, single inheritance, implemented through Rust traits. This allows a CGP context to implement traits like &lt;code&gt;DelegateComponent&lt;&#x2F;code&gt; based on all keys stored in a single preset.&lt;&#x2F;p&gt;
&lt;p&gt;The second form is a macro-based approach, which enables &lt;strong&gt;nested levels of multiple inheritance&lt;&#x2F;strong&gt; when defining new presets. These macros work by expanding the preset keys as list &lt;strong&gt;syntax&lt;&#x2F;strong&gt; (e.g., &lt;code&gt;[KeyA, KeyB, KeyC, ...]&lt;&#x2F;code&gt;) and then processing these keys syntactically through a separate macro. This means the macro approach can be less reliable, as we lose access to precise type information, and ambiguity can arise if the same identifier refers to multiple types in scope or when &lt;strong&gt;aliases&lt;&#x2F;strong&gt; are used. However, it&#x27;s more flexible, allowing us to work with more than one map, which isn&#x27;t possible with the trait-based approach due to coherence restrictions.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;hypershell-presets&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#hypershell-presets&quot; aria-label=&quot;Anchor link for: hypershell-presets&quot;&gt;Hypershell Presets&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Thanks to presets, Hypershell&#x27;s core implementation is highly customizable. Hypershell defines all its component wirings as extensible presets, allowing users to &lt;strong&gt;extend, replace, or customize&lt;&#x2F;strong&gt; any of them.&lt;&#x2F;p&gt;
&lt;p&gt;The primary preset provided by Hypershell is &lt;strong&gt;&lt;code&gt;HypershellPreset&lt;&#x2F;code&gt;&lt;&#x2F;strong&gt;, which can be directly used by contexts like &lt;code&gt;HypershellCli&lt;&#x2F;code&gt;. However, beneath this main preset, Hypershell actually breaks down its components into several smaller presets, including &lt;strong&gt;&lt;code&gt;HypershellTokioPreset&lt;&#x2F;code&gt;&lt;&#x2F;strong&gt; for CLI components and &lt;strong&gt;&lt;code&gt;HypershellReqwestPreset&lt;&#x2F;code&gt;&lt;&#x2F;strong&gt; for HTTP components. This granular approach allows one sub-part of the presets to be entirely replaced while keeping other parts unmodified.&lt;&#x2F;p&gt;
&lt;p&gt;Furthermore, Hypershell also defines the dispatch tables for components like &lt;code&gt;HandlerComponent&lt;&#x2F;code&gt; as presets. This design enables us to extend the handler component presets, rather than the main preset, to introduce new &lt;strong&gt;syntaxes&lt;&#x2F;strong&gt; to the DSL or customize the wiring for existing syntaxes like &lt;code&gt;SimpleExec&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;high-level-diagram&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#high-level-diagram&quot; aria-label=&quot;Anchor link for: high-level-diagram&quot;&gt;High Level Diagram&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;Let&#x27;s now walk through how &lt;code&gt;HandleSimpleExec&lt;&#x2F;code&gt; is wired within the Hypershell presets. But before we start, here&#x27;s a high-level diagram illustrating the levels of indirection involved:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;blog&#x2F;images&#x2F;preset-wiring.png&quot; alt=&quot;Diagram&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;As you can see, there&#x27;s quite a bit of indirection in that diagram! We&#x27;ll go through each step one by one, along with the relevant code snippets, to give you a clearer understanding of what&#x27;s happening.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;definition-of-hypershellcli&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#definition-of-hypershellcli&quot; aria-label=&quot;Anchor link for: definition-of-hypershellcli&quot;&gt;Definition of &lt;code&gt;HypershellCli&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_context(HypershellCliComponents: HypershellPreset)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;HypershellCli;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We begin with the definition of the &lt;code&gt;HypershellCli&lt;&#x2F;code&gt; context, where &lt;code&gt;HypershellPreset&lt;&#x2F;code&gt; is specified as the preset to be inherited by the context&#x27;s provider, &lt;code&gt;HypershellCliComponents&lt;&#x2F;code&gt;. The initial part of the implementation remains the same: &lt;code&gt;HypershellCli&lt;&#x2F;code&gt; receives a blanket implementation for &lt;code&gt;CanHandle&amp;lt;SimpleExec&amp;lt;Command, Args&amp;gt;, Input&amp;gt;&lt;&#x2F;code&gt; if &lt;code&gt;HypershellCliComponents&lt;&#x2F;code&gt; implements &lt;code&gt;Handler&amp;lt;HypershellCli, SimpleExec&amp;lt;Command, Args&amp;gt;, Input&amp;gt;&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Following this, for &lt;code&gt;HypershellCliComponents&lt;&#x2F;code&gt; to implement the provider trait, the trait system will look for its &lt;code&gt;DelegateComponent&lt;&#x2F;code&gt; entry with &lt;code&gt;HandlerComponent&lt;&#x2F;code&gt; as the key, which now points to &lt;code&gt;HypershellPreset&lt;&#x2F;code&gt;. The system finds this entry via a blanket implementation of &lt;code&gt;DelegateComponent&lt;&#x2F;code&gt; using a special &lt;code&gt;HypershellPreset::IsPreset&lt;&#x2F;code&gt; trait. This blanket implementation is generated by &lt;code&gt;#[cgp_context]&lt;&#x2F;code&gt;, allowing &lt;code&gt;HypershellCliComponents&lt;&#x2F;code&gt; to delegate all components from &lt;code&gt;HypershellPreset&lt;&#x2F;code&gt; without any additional code.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;definition-of-hypershellpreset&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#definition-of-hypershellpreset&quot; aria-label=&quot;Anchor link for: definition-of-hypershellpreset&quot;&gt;Definition of &lt;code&gt;HypershellPreset&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;code&gt;HypershellPreset&lt;&#x2F;code&gt; is defined as follows:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp::re_export_imports]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mod &lt;&#x2F;span&gt;&lt;span&gt;preset {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    cgp_preset! {
&lt;&#x2F;span&gt;&lt;span&gt;        HypershellPreset:
&lt;&#x2F;span&gt;&lt;span&gt;            HypershellTokioPreset
&lt;&#x2F;span&gt;&lt;span&gt;            + HypershellReqwestPreset
&lt;&#x2F;span&gt;&lt;span&gt;            + &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;        {
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;override&lt;&#x2F;span&gt;&lt;span&gt; HandlerComponent:
&lt;&#x2F;span&gt;&lt;span&gt;                HypershellHandlerPreset::Provider,
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;First, when defining CGP presets, we need to wrap the code within a &lt;code&gt;mod preset&lt;&#x2F;code&gt; annotated with &lt;code&gt;#[cgp::re_export_imports]&lt;&#x2F;code&gt;. This macro captures all &lt;code&gt;use&lt;&#x2F;code&gt; statements within the module and creates a hidden &lt;code&gt;pub use&lt;&#x2F;code&gt; variant of these imports. This &quot;hack&quot; is necessary for the macro-based preset operations to work, as we need to re-import all key identifiers in a child preset to bind them to their original types. The macro also re-exports everything in the inner module, so you can import the preset as if the &lt;code&gt;preset&lt;&#x2F;code&gt; wrapper module isn&#x27;t present.&lt;&#x2F;p&gt;
&lt;p&gt;We then define &lt;code&gt;HypershellPreset&lt;&#x2F;code&gt; using the &lt;code&gt;cgp_preset!&lt;&#x2F;code&gt; macro. You can see that this preset leverages &lt;strong&gt;multiple inheritance&lt;&#x2F;strong&gt; to inherit from several other parent presets, including &lt;code&gt;HypershellTokioPreset&lt;&#x2F;code&gt;, which contains all component wirings for implementing Hypershell&#x27;s CLI features using &lt;code&gt;tokio&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;In one of &lt;code&gt;HypershellPreset&lt;&#x2F;code&gt;&#x27;s entries, we see that &lt;code&gt;HandlerComponent&lt;&#x2F;code&gt; is specified with an additional &lt;code&gt;override&lt;&#x2F;code&gt; keyword. An overridden preset entry is useful for handling conflicting entries that arise from multiple inheritance (i.e., the &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Diamond_problem&quot;&gt;diamond problem&lt;&#x2F;a&gt;), as well as allowing the child preset to override parts of the component wiring provided by a parent preset.&lt;&#x2F;p&gt;
&lt;p&gt;In the case of &lt;code&gt;HypershellPreset&lt;&#x2F;code&gt;, &lt;code&gt;override&lt;&#x2F;code&gt; is used because we want to define a new provider, &lt;code&gt;HypershellHandlerPreset&lt;&#x2F;code&gt;, that combines handlers for different groups of syntaxes coming from various parent presets. When specifying the entry value, we use &lt;code&gt;HypershellHandlerPreset::Provider&lt;&#x2F;code&gt; because &lt;code&gt;HypershellHandlerPreset&lt;&#x2F;code&gt; itself is actually a module. When we need to refer to the preset as a type, we access it through the &lt;code&gt;::Provider&lt;&#x2F;code&gt; item within that module.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;definition-of-hypershellhandlerpreset&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#definition-of-hypershellhandlerpreset&quot; aria-label=&quot;Anchor link for: definition-of-hypershellhandlerpreset&quot;&gt;Definition of &lt;code&gt;HypershellHandlerPreset&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;code&gt;HypershellHandlerPreset&lt;&#x2F;code&gt; is defined as follows:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;cgp_preset! {
&lt;&#x2F;span&gt;&lt;span&gt;    #[wrap_provider(UseDelegate)]
&lt;&#x2F;span&gt;&lt;span&gt;    HypershellHandlerPreset:
&lt;&#x2F;span&gt;&lt;span&gt;        TokioHandlerPreset
&lt;&#x2F;span&gt;&lt;span&gt;        + ReqwestHandlerPreset
&lt;&#x2F;span&gt;&lt;span&gt;        + &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;    { }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;From the code above, we can see that &lt;code&gt;HypershellHandlerPreset&lt;&#x2F;code&gt; is defined as a separate preset within the same module. This preset has an empty body; it merely combines the handler wirings from parent presets like &lt;code&gt;TokioHandlerPreset&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;The preset is also annotated with &lt;code&gt;#[wrap_provider(UseDelegate)]&lt;&#x2F;code&gt;. This instructs &lt;code&gt;cgp_preset!&lt;&#x2F;code&gt; to wrap the &lt;code&gt;Preset::Provider&lt;&#x2F;code&gt; type in the preset module with &lt;code&gt;UseDelegate&lt;&#x2F;code&gt;. This is crucial because the component entries themselves don&#x27;t result in a blanket implementation of &lt;code&gt;Handler&lt;&#x2F;code&gt; (or any provider trait). However, by wrapping the entry inside &lt;code&gt;UseDelegate&lt;&#x2F;code&gt;, the &lt;code&gt;Handler&lt;&#x2F;code&gt; trait becomes implemented by performing dispatch to the entries based on the &lt;code&gt;Code&lt;&#x2F;code&gt; type.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;expansion-of-cgp-preset&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#expansion-of-cgp-preset&quot; aria-label=&quot;Anchor link for: expansion-of-cgp-preset&quot;&gt;Expansion of &lt;code&gt;cgp_preset!&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;When all is said and done, the call to &lt;code&gt;cgp_preset!&lt;&#x2F;code&gt; roughly expands into the following:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub mod &lt;&#x2F;span&gt;&lt;span&gt;HypershellHandlerPreset {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Provider &lt;&#x2F;span&gt;&lt;span&gt;= UseDelegate&amp;lt;Components&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;Components;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    delegate_components! {
&lt;&#x2F;span&gt;&lt;span&gt;        Components {
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; pseudo code for bulk delegation
&lt;&#x2F;span&gt;&lt;span&gt;            TokioHandlerPreset::Components::Keys:
&lt;&#x2F;span&gt;&lt;span&gt;                TokioHandlerPreset::Provider,
&lt;&#x2F;span&gt;&lt;span&gt;            ReqwestHandlerPreset::Components::Keys:
&lt;&#x2F;span&gt;&lt;span&gt;                ReqwestHandlerPreset::Provider,
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; other constructs
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;First, &lt;code&gt;cgp_preset!&lt;&#x2F;code&gt; defines a module called &lt;code&gt;HypershellHandlerPreset&lt;&#x2F;code&gt;. Inside this module, a &lt;code&gt;Components&lt;&#x2F;code&gt; struct is defined, and &lt;code&gt;delegate_components!&lt;&#x2F;code&gt; is called with the mappings specified within the &lt;code&gt;cgp_preset!&lt;&#x2F;code&gt; macro&#x27;s body. Additionally, &lt;code&gt;delegate_components!&lt;&#x2F;code&gt; is also applied to all keys in the super presets, with the delegate target set to the super preset&#x27;s &lt;code&gt;Provider&lt;&#x2F;code&gt; type. We&#x27;ve used pseudocode in the example above for clarity, as the actual underlying syntax is more verbose and potentially confusing.&lt;&#x2F;p&gt;
&lt;p&gt;When &lt;code&gt;#[wrap_provider(UseDelegate)]&lt;&#x2F;code&gt; is used, the macro defines &lt;code&gt;Provider&lt;&#x2F;code&gt; as a type alias to &lt;code&gt;UseDelegate&amp;lt;Components&amp;gt;&lt;&#x2F;code&gt;. If &lt;code&gt;#[wrap_provider]&lt;&#x2F;code&gt; is not specified, as when we defined &lt;code&gt;HypershellPreset&lt;&#x2F;code&gt; earlier, &lt;code&gt;Provider&lt;&#x2F;code&gt; is simply a type alias to &lt;code&gt;Components&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;definition-of-tokiohandlerpreset&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#definition-of-tokiohandlerpreset&quot; aria-label=&quot;Anchor link for: definition-of-tokiohandlerpreset&quot;&gt;Definition of &lt;code&gt;TokioHandlerPreset&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;Next, let&#x27;s look at how &lt;code&gt;TokioHandlerPreset&lt;&#x2F;code&gt; is defined:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;cgp_preset! {
&lt;&#x2F;span&gt;&lt;span&gt;    #[wrap_provider(UseDelegate)]
&lt;&#x2F;span&gt;&lt;span&gt;    TokioHandlerPreset {
&lt;&#x2F;span&gt;&lt;span&gt;        &amp;lt;Path, Args&amp;gt; SimpleExec&amp;lt;Path, Args&amp;gt;:
&lt;&#x2F;span&gt;&lt;span&gt;            HandleSimpleExec,
&lt;&#x2F;span&gt;&lt;span&gt;        &amp;lt;Path, Args&amp;gt; StreamingExec&amp;lt;Path, Args&amp;gt;:
&lt;&#x2F;span&gt;&lt;span&gt;            HandleStreamingExec,
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;As you can see, &lt;code&gt;TokioHandlerPreset&lt;&#x2F;code&gt; is defined similarly to &lt;code&gt;HypershellHandlerPreset&lt;&#x2F;code&gt; and is also wrapped with &lt;code&gt;UseDelegate&lt;&#x2F;code&gt;. This preset now contains a non-empty list of entries, with &lt;code&gt;SimpleExec&lt;&#x2F;code&gt; mapped to &lt;code&gt;HandleSimpleExec&lt;&#x2F;code&gt;, &lt;code&gt;StreamingExec&lt;&#x2F;code&gt; mapped to &lt;code&gt;HandleStreamingExec&lt;&#x2F;code&gt;, and so on.&lt;&#x2F;p&gt;
&lt;p&gt;Given that &lt;code&gt;TokioHandlerPreset&lt;&#x2F;code&gt; implements only the handlers for Hypershell&#x27;s CLI syntaxes, you&#x27;ll find mappings for other syntaxes in other presets, such as &lt;code&gt;ReqwestHandlerPreset&lt;&#x2F;code&gt;, which provides mappings for &lt;code&gt;SimpleHttpRequest&lt;&#x2F;code&gt; and &lt;code&gt;StreamingHttpRequest&lt;&#x2F;code&gt;. So, when &lt;code&gt;HypershellHandlerPreset&lt;&#x2F;code&gt; inherits from both &lt;code&gt;TokioHandlerPreset&lt;&#x2F;code&gt; and &lt;code&gt;ReqwestHandlerPreset&lt;&#x2F;code&gt;, we are essentially &quot;merging&quot; the entries from both preset mappings into a single mapping.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;full-trace-of-preset-delegations&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#full-trace-of-preset-delegations&quot; aria-label=&quot;Anchor link for: full-trace-of-preset-delegations&quot;&gt;Full Trace of Preset Delegations&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;Returning to the implementation diagram at the beginning, we can now trace the remaining implementation steps:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;HypershellPreset&lt;&#x2F;code&gt;&lt;&#x2F;strong&gt; (or more specifically, &lt;code&gt;HypershellPreset::Provider&lt;&#x2F;code&gt;) has a blanket implementation for &lt;code&gt;Handler&amp;lt;HypershellCli, SimpleExec&amp;lt;Command, Args&amp;gt;, Input&amp;gt;&lt;&#x2F;code&gt;. This is because it has a &lt;code&gt;DelegateComponent&lt;&#x2F;code&gt; entry for &lt;code&gt;HandlerComponent&lt;&#x2F;code&gt;, which points to &lt;code&gt;HypershellHandlerPreset::Provider&lt;&#x2F;code&gt;, which is &lt;code&gt;UseDelegate&amp;lt;HypershellHandlerPreset::Components&amp;gt;&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;UseDelegate&amp;lt;HypershellHandlerPreset::Components&amp;gt;&lt;&#x2F;code&gt;&lt;&#x2F;strong&gt; has a context-generic implementation for &lt;code&gt;Handler&amp;lt;HypershellCli, SimpleExec&amp;lt;Command, Args&amp;gt;, Input&amp;gt;&lt;&#x2F;code&gt;. This is because &lt;code&gt;HypershellHandlerPreset::Components&lt;&#x2F;code&gt; has a &lt;code&gt;DelegateComponent&lt;&#x2F;code&gt; entry for &lt;code&gt;SimpleExec&amp;lt;Command, Args&amp;gt;&lt;&#x2F;code&gt;, which points to &lt;code&gt;TokioHandlerPreset::Provider&lt;&#x2F;code&gt;, which is &lt;code&gt;UseDelegate&amp;lt;TokioHandlerPreset::Components&amp;gt;&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;UseDelegate&amp;lt;TokioHandlerPreset::Components&amp;gt;&lt;&#x2F;code&gt;&lt;&#x2F;strong&gt; has a context-generic implementation for &lt;code&gt;Handler&amp;lt;HypershellCli, SimpleExec&amp;lt;Command, Args&amp;gt;, Input&amp;gt;&lt;&#x2F;code&gt;. This is because &lt;code&gt;TokioHandlerPreset::Components&lt;&#x2F;code&gt; has a &lt;code&gt;DelegateComponent&lt;&#x2F;code&gt; entry for &lt;code&gt;SimpleExec&amp;lt;Command, Args&amp;gt;&lt;&#x2F;code&gt;, which points to &lt;code&gt;HandleSimpleExec&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;Finally, &lt;strong&gt;&lt;code&gt;HandleSimpleExec&lt;&#x2F;code&gt;&lt;&#x2F;strong&gt; implements &lt;code&gt;Handler&amp;lt;HypershellCli, SimpleExec&amp;lt;Command, Args&amp;gt;, Input&amp;gt;&lt;&#x2F;code&gt;. This completes the implementation chain, and calls are ultimately forwarded to it.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;At this point, you might feel that defining so many levels of indirection just to wire up a single handler like &lt;code&gt;HandleSimpleExec&lt;&#x2F;code&gt; is overly complicated. However, each level of indirection is essential for enabling additional flexibility in customizing Hypershell. This section also lays the groundwork for understanding the next section, where we&#x27;ll explore how to leverage these defined presets to add new language extensions to the Hypershell DSL. After that, you&#x27;ll hopefully better appreciate the level of modularity introduced here.&lt;&#x2F;p&gt;
&lt;p&gt;It&#x27;s also worth noting that this is not necessarily a recommendation for how &lt;em&gt;you&lt;&#x2F;em&gt; should write CGP code in your own applications. In fact, you may not even need presets at all if your initial application has only one concrete context with no further customization needs.&lt;&#x2F;p&gt;
&lt;p&gt;Everything we&#x27;ve described in this section is to explain the internal architecture of Hypershell, which is &lt;em&gt;not&lt;&#x2F;em&gt; required knowledge for end-users who simply want to use Hypershell without additional customization. Instead, this section is primarily useful for developers interested in &lt;em&gt;extending&lt;&#x2F;em&gt; Hypershell or building similar modular DSLs.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;extending-hypershell&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#extending-hypershell&quot; aria-label=&quot;Anchor link for: extending-hypershell&quot;&gt;Extending Hypershell&lt;&#x2F;a&gt;&lt;&#x2F;h1&gt;
&lt;p&gt;We now have a basic understanding of Hypershell&#x27;s structure and how its implementation is modularized. To fully grasp the benefits this provides, let&#x27;s try extending the language by introducing new syntaxes to the DSL.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;checksum-handler&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#checksum-handler&quot; aria-label=&quot;Anchor link for: checksum-handler&quot;&gt;Checksum Handler&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Recall that in an earlier example for &lt;a href=&quot;https:&#x2F;&#x2F;www.contextgeneric.dev&#x2F;blog&#x2F;hypershell-release&#x2F;#native-http-request&quot;&gt;HTTP requests&lt;&#x2F;a&gt;, we fetched web content from a URL and then computed its HTTP checksum using the &lt;code&gt;sha256sum&lt;&#x2F;code&gt; command. While this approach allows for quick iteration and results, there&#x27;s room for improvement once the initial prototype is working.&lt;&#x2F;p&gt;
&lt;p&gt;Specifically, since we&#x27;re within Rust, an obvious optimization would be to use a native library like &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;sha2&quot;&gt;&lt;code&gt;sha2&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; to compute the checksum.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;syntax-extension&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#syntax-extension&quot; aria-label=&quot;Anchor link for: syntax-extension&quot;&gt;Syntax Extension&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Following Hypershell&#x27;s modular DSL design, we first want to define an &lt;strong&gt;abstract syntax&lt;&#x2F;strong&gt; that users can employ in their Hypershell programs. This abstract syntax decouples the language extension from its concrete implementation, allowing users to choose an alternative implementation, such as using the &lt;code&gt;sha256sum&lt;&#x2F;code&gt; command, to compute the checksum.&lt;&#x2F;p&gt;
&lt;p&gt;For this demonstration, we&#x27;ll define an abstract &lt;code&gt;Checksum&lt;&#x2F;code&gt; syntax as follows:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;Checksum&amp;lt;Hasher&amp;gt;(pub PhantomData&amp;lt;Hasher&amp;gt;);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Instead of defining a specific SHA256 syntax, we&#x27;ve created a general &lt;code&gt;Checksum&lt;&#x2F;code&gt; syntax that can be parameterized by a hasher. This design allows other hash algorithms to be used with this syntax as well.&lt;&#x2F;p&gt;
&lt;p&gt;In addition to the &lt;code&gt;Checksum&lt;&#x2F;code&gt; syntax, we&#x27;ll also introduce a new &lt;code&gt;BytesToHex&lt;&#x2F;code&gt; syntax for converting bytes to hexadecimal strings:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;BytesToHex;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The main idea here is to keep the native implementation of the checksum handler flexible for different use cases. Rust libraries like &lt;code&gt;sha2&lt;&#x2F;code&gt; output checksums as raw bytes, which can be more efficient for operations like comparing two checksums. On the other hand, when we want to display the output of a Hypershell program, it might be better to show it as hex strings on the terminal.&lt;&#x2F;p&gt;
&lt;p&gt;By providing explicit conversion, we allow the user to decide whether to convert the checksum bytes into hexadecimal within a Hypershell program, simply by adding it as part of the handler pipeline.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;handlestreamchecksum-provider&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#handlestreamchecksum-provider&quot; aria-label=&quot;Anchor link for: handlestreamchecksum-provider&quot;&gt;&lt;code&gt;HandleStreamChecksum&lt;&#x2F;code&gt; Provider&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;With the &lt;code&gt;Checksum&lt;&#x2F;code&gt; syntax defined, let&#x27;s look at how we can implement a provider for it:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_new_provider]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;Context, Input, Hasher&amp;gt; Handler&amp;lt;Context, Checksum&amp;lt;Hasher&amp;gt;, Input&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;HandleStreamChecksum
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;    Context: CanRaiseAsyncError&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Input::&lt;&#x2F;span&gt;&lt;span&gt;Error&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    Input: Send + Unpin + TryStream,
&lt;&#x2F;span&gt;&lt;span&gt;    Hasher: Send + Digest,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Input::&lt;&#x2F;span&gt;&lt;span&gt;Ok: AsRef&amp;lt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u8&lt;&#x2F;span&gt;&lt;span&gt;]&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Output &lt;&#x2F;span&gt;&lt;span&gt;= GenericArray&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u8&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Hasher::&lt;&#x2F;span&gt;&lt;span&gt;OutputSize&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    async &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;handle(
&lt;&#x2F;span&gt;&lt;span&gt;        _context: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;Context,
&lt;&#x2F;span&gt;&lt;span&gt;        _tag: PhantomData&amp;lt;Checksum&amp;lt;Hasher&amp;gt;&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mut &lt;&#x2F;span&gt;&lt;span&gt;input: Input,
&lt;&#x2F;span&gt;&lt;span&gt;    ) -&amp;gt; Result&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;Output, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Context::&lt;&#x2F;span&gt;&lt;span&gt;Error&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; hasher = Hasher::new();
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;while let &lt;&#x2F;span&gt;&lt;span&gt;Some(bytes) = input.try_next().await.map_err(Context::raise_error)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;? &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            hasher.update(bytes);
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        Ok(hasher.finalize())
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The code above defines a &lt;code&gt;HandleStreamChecksum&lt;&#x2F;code&gt; provider that implements &lt;code&gt;Handler&lt;&#x2F;code&gt; for the &lt;code&gt;Checksum&amp;lt;Hasher&amp;gt;&lt;&#x2F;code&gt; syntax, provided that &lt;code&gt;Hasher&lt;&#x2F;code&gt; implements &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;sha2&#x2F;latest&#x2F;sha2&#x2F;trait.Digest.html&quot;&gt;&lt;code&gt;Digest&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Additionally, to support streaming input, &lt;code&gt;HandleStreamChecksum&lt;&#x2F;code&gt; works on any &lt;code&gt;Input&lt;&#x2F;code&gt; type that implements &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;futures&#x2F;latest&#x2F;futures&#x2F;prelude&#x2F;trait.TryStream.html&quot;&gt;&lt;code&gt;TryStream&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;, with its &lt;code&gt;Ok&lt;&#x2F;code&gt; type implementing &lt;code&gt;AsRef&amp;lt;[u8]&amp;gt;&lt;&#x2F;code&gt;. The provider also requires &lt;code&gt;Context&lt;&#x2F;code&gt; to implement &lt;code&gt;CanRaiseAsyncError&amp;lt;Input::Error&amp;gt;&lt;&#x2F;code&gt;, ensuring that any error in the input stream will be handled by the context.&lt;&#x2F;p&gt;
&lt;p&gt;The &lt;code&gt;Output&lt;&#x2F;code&gt; type is defined as &lt;code&gt;GenericArray&amp;lt;u8, Hasher::OutputSize&amp;gt;&lt;&#x2F;code&gt;, which is the type returned by &lt;code&gt;Digest::finalize&lt;&#x2F;code&gt;. We choose this over &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;&#x2F;code&gt; because it assures the caller that the size of the checksum bytes will always be fixed. This is also fine for Hypershell&#x27;s use case, as &lt;code&gt;GenericArray&lt;&#x2F;code&gt; is byte-like and implements &lt;code&gt;AsRef&amp;lt;[u8]&amp;gt;&lt;&#x2F;code&gt;, allowing it to interoperate easily with other handlers that accept bytes-like input.&lt;&#x2F;p&gt;
&lt;p&gt;Within the method body, we implement the hashing by creating a &lt;code&gt;Hasher&lt;&#x2F;code&gt; instance, asynchronously iterating over the &lt;code&gt;TryStream&lt;&#x2F;code&gt;, and calling &lt;code&gt;update&lt;&#x2F;code&gt; on the incoming bytes. Finally, we call &lt;code&gt;finalize&lt;&#x2F;code&gt; to compute and return the checksum result.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;bytestohex-provider&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#bytestohex-provider&quot; aria-label=&quot;Anchor link for: bytestohex-provider&quot;&gt;&lt;code&gt;BytesToHex&lt;&#x2F;code&gt; Provider&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Similar to &lt;code&gt;HandleStreamChecksum&lt;&#x2F;code&gt;, we can also implement the &lt;code&gt;Handler&lt;&#x2F;code&gt; provider for &lt;code&gt;BytesToHex&lt;&#x2F;code&gt; quite easily. In fact, this implementation is simpler, as it works directly on a byte slice instead of a stream of bytes.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_new_provider]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;Context, Code, Input&amp;gt; Handler&amp;lt;Context, Code, Input&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;HandleBytesToHex
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;    Context: HasAsyncErrorType,
&lt;&#x2F;span&gt;&lt;span&gt;    Code: Send,
&lt;&#x2F;span&gt;&lt;span&gt;    Input: Send + AsRef&amp;lt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u8&lt;&#x2F;span&gt;&lt;span&gt;]&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Output &lt;&#x2F;span&gt;&lt;span&gt;= String;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    async &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;handle(
&lt;&#x2F;span&gt;&lt;span&gt;        _context: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;Context,
&lt;&#x2F;span&gt;&lt;span&gt;        _tag: PhantomData&amp;lt;Code&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        input: Input,
&lt;&#x2F;span&gt;&lt;span&gt;    ) -&amp;gt; Result&amp;lt;String, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Context::&lt;&#x2F;span&gt;&lt;span&gt;Error&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; output = hex::encode(input);
&lt;&#x2F;span&gt;&lt;span&gt;        Ok(output)
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;HandleBytesToHex&lt;&#x2F;code&gt; provider is implemented to work with any &lt;code&gt;Input&lt;&#x2F;code&gt; type that implements &lt;code&gt;AsRef&amp;lt;[u8]&amp;gt;&lt;&#x2F;code&gt;. It produces a &lt;code&gt;String&lt;&#x2F;code&gt; output type and simply calls &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;hex&#x2F;latest&#x2F;hex&#x2F;fn.encode.html&quot;&gt;&lt;code&gt;hex::encode&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; to encode the input bytes into a hexadecimal string.&lt;&#x2F;p&gt;
&lt;p&gt;Notice that &lt;code&gt;HandleBytesToHex&lt;&#x2F;code&gt; can be implemented with a generic &lt;code&gt;Code&lt;&#x2F;code&gt;, rather than specifically the &lt;code&gt;BytesToHex&lt;&#x2F;code&gt; syntax. We can do this because we don&#x27;t need to access any information from the &lt;code&gt;Code&lt;&#x2F;code&gt; to implement the provider. It&#x27;s common practice with CGP to implement providers as generically as possible, at least within certain codebases. By doing so, we allow the provider to be more easily reused in other places, such as handling other syntaxes.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;preset-extension&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#preset-extension&quot; aria-label=&quot;Anchor link for: preset-extension&quot;&gt;Preset Extension&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;We can now extend &lt;code&gt;HypershellPreset&lt;&#x2F;code&gt; to include the new syntaxes and providers we&#x27;ve introduced. Extending the preset requires a relatively minimal amount of code:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp::re_export_imports]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mod &lt;&#x2F;span&gt;&lt;span&gt;preset {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    cgp_preset! {
&lt;&#x2F;span&gt;&lt;span&gt;        ExtendedHypershellPreset: HypershellPreset {
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;override&lt;&#x2F;span&gt;&lt;span&gt; HandlerComponent:
&lt;&#x2F;span&gt;&lt;span&gt;                ExtendedHandlerPreset::Provider,
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    cgp_preset! {
&lt;&#x2F;span&gt;&lt;span&gt;        #[wrap_provider(UseDelegate)]
&lt;&#x2F;span&gt;&lt;span&gt;        ExtendedHandlerPreset: HypershellHandlerPreset {
&lt;&#x2F;span&gt;&lt;span&gt;            BytesToHex:
&lt;&#x2F;span&gt;&lt;span&gt;                HandleBytesToHex,
&lt;&#x2F;span&gt;&lt;span&gt;            &amp;lt;Hasher&amp;gt; Checksum&amp;lt;Hasher&amp;gt;:
&lt;&#x2F;span&gt;&lt;span&gt;                PipeHandlers&amp;lt;Product&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;[
&lt;&#x2F;span&gt;&lt;span&gt;                    FuturesToTokioAsyncRead,
&lt;&#x2F;span&gt;&lt;span&gt;                    AsyncReadToStream,
&lt;&#x2F;span&gt;&lt;span&gt;                    HandleStreamChecksum,
&lt;&#x2F;span&gt;&lt;span&gt;                ]&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We first define &lt;code&gt;ExtendedHypershellPreset&lt;&#x2F;code&gt; to extend from &lt;code&gt;HypershellPreset&lt;&#x2F;code&gt;. In its body, we don&#x27;t introduce new component wiring, except to override the wiring of &lt;code&gt;HandlerComponent&lt;&#x2F;code&gt; to use &lt;code&gt;ExtendedHandlerPreset&lt;&#x2F;code&gt;, which we define next.&lt;&#x2F;p&gt;
&lt;p&gt;We define &lt;code&gt;ExtendedHandlerPreset&lt;&#x2F;code&gt; to extend from &lt;code&gt;HypershellHandlerPreset&lt;&#x2F;code&gt;. Inside its body, we wire up the provider for &lt;code&gt;BytesToHex&lt;&#x2F;code&gt; to &lt;code&gt;HandleBytesToHex&lt;&#x2F;code&gt;. Following that, the wiring for &lt;code&gt;Checksum&lt;&#x2F;code&gt; actually consists of an &lt;strong&gt;inner pipeline&lt;&#x2F;strong&gt; of handlers, rather than just &lt;code&gt;HandleStreamChecksum&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;To understand what&#x27;s happening here, we first need to recognize that &lt;code&gt;HandleStreamChecksum&lt;&#x2F;code&gt; can work with any &lt;code&gt;Input&lt;&#x2F;code&gt; type that implements &lt;code&gt;TryStream&lt;&#x2F;code&gt;. However, the output type returned by &lt;code&gt;HandleStreamingHttpRequest&lt;&#x2F;code&gt;, which we want to use with &lt;code&gt;Checksum&lt;&#x2F;code&gt; in our example, only implements &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;futures&#x2F;latest&#x2F;futures&#x2F;io&#x2F;trait.AsyncRead.html&quot;&gt;&lt;code&gt;futures::AsyncRead&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; instead of &lt;code&gt;TryStream&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;To convert the output from &lt;code&gt;HandleStreamingHttpRequest&lt;&#x2F;code&gt; into a &lt;code&gt;TryStream&lt;&#x2F;code&gt;, we need to perform two conversion steps. First, we use &lt;code&gt;FuturesToTokioAsyncRead&lt;&#x2F;code&gt; (provided by &lt;code&gt;hypershell-tokio-components&lt;&#x2F;code&gt;) to convert a &lt;code&gt;futures::AsyncRead&lt;&#x2F;code&gt; into &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;tokio&#x2F;latest&#x2F;tokio&#x2F;io&#x2F;trait.AsyncRead.html&quot;&gt;&lt;code&gt;tokio::AsyncRead&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;. Then, we use &lt;code&gt;AsyncReadToStream&lt;&#x2F;code&gt; (also provided by Hypershell) to convert a &lt;code&gt;tokio::AsyncRead&lt;&#x2F;code&gt; into a &lt;code&gt;TryStream&lt;&#x2F;code&gt;. These two levels of conversion are necessary because, unfortunately, there&#x27;s no simple direct way to convert a &lt;code&gt;futures::AsyncRead&lt;&#x2F;code&gt; into a &lt;code&gt;TryStream&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Finally, we use &lt;code&gt;PipeHandlers&lt;&#x2F;code&gt; to combine the three handler providers into a single &lt;code&gt;Handler&lt;&#x2F;code&gt; provider. Notice that while &lt;code&gt;Pipe&lt;&#x2F;code&gt; is an abstract &lt;strong&gt;syntax&lt;&#x2F;strong&gt; that works with a list of inner handler &lt;strong&gt;syntaxes&lt;&#x2F;strong&gt;, &lt;code&gt;PipeHandlers&lt;&#x2F;code&gt; is a &lt;strong&gt;provider&lt;&#x2F;strong&gt; for &lt;code&gt;Handler&lt;&#x2F;code&gt; that works with a list of inner handler &lt;strong&gt;providers&lt;&#x2F;strong&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;example-program&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#example-program&quot; aria-label=&quot;Anchor link for: example-program&quot;&gt;Example Program&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;With the new &lt;code&gt;ExtendedHypershellPreset&lt;&#x2F;code&gt; defined, we can now define an example Hypershell program that utilizes the new &lt;code&gt;Checksum&lt;&#x2F;code&gt; and &lt;code&gt;BytesToHex&lt;&#x2F;code&gt; syntaxes:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Program &lt;&#x2F;span&gt;&lt;span&gt;= hypershell! {
&lt;&#x2F;span&gt;&lt;span&gt;    StreamingHttpRequest&amp;lt;
&lt;&#x2F;span&gt;&lt;span&gt;        GetMethod,
&lt;&#x2F;span&gt;&lt;span&gt;        FieldArg&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;url&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        WithHeaders[ ],
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;| &lt;&#x2F;span&gt;&lt;span&gt;Checksum&amp;lt;Sha256&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;|&lt;&#x2F;span&gt;&lt;span&gt; BytesToHex
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;|&lt;&#x2F;span&gt;&lt;span&gt; StreamToStdout
&lt;&#x2F;span&gt;&lt;span&gt;};
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;With the new syntaxes in place, our program becomes much simpler compared to having to explicitly call shell commands. Next, we define a concrete context that uses our &lt;code&gt;ExtendedHypershellPreset&lt;&#x2F;code&gt; to run the program:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_context(MyAppComponents: ExtendedHypershellPreset)]
&lt;&#x2F;span&gt;&lt;span&gt;#[derive(HasField)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;MyApp {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;http_client: Client,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;url: String,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Instead of extending from &lt;code&gt;HypershellPreset&lt;&#x2F;code&gt;, our context provider &lt;code&gt;MyAppComponents&lt;&#x2F;code&gt; now extends from &lt;code&gt;ExtendedHypershellPreset&lt;&#x2F;code&gt;. With this change, it can now support the new syntaxes we&#x27;ve introduced into our Hypershell program.&lt;&#x2F;p&gt;
&lt;p&gt;With everything defined, we just need to write a &lt;code&gt;main&lt;&#x2F;code&gt; function that builds a &lt;code&gt;MyApp&lt;&#x2F;code&gt; context and calls the Hypershell program with it:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[tokio::main]
&lt;&#x2F;span&gt;&lt;span&gt;async &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;main() -&amp;gt; Result&amp;lt;(), Error&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; app = MyApp {
&lt;&#x2F;span&gt;&lt;span&gt;        http_client: Client::new(),
&lt;&#x2F;span&gt;&lt;span&gt;        url: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;https:&#x2F;&#x2F;nixos.org&#x2F;manual&#x2F;nixpkgs&#x2F;unstable&#x2F;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;.to_owned(),
&lt;&#x2F;span&gt;&lt;span&gt;    };
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    app.handle(PhantomData::&amp;lt;Program&amp;gt;, Vec::new()).await&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;?&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    Ok(())
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The full example code is available in the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;contextgeneric&#x2F;hypershell&#x2F;blob&#x2F;main&#x2F;crates&#x2F;hypershell-examples&#x2F;examples&#x2F;http_checksum_native.rs&quot;&gt;project repository&lt;&#x2F;a&gt;, and the checksum implementation is available as the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;contextgeneric&#x2F;hypershell&#x2F;tree&#x2F;main&#x2F;crates&#x2F;hypershell-hash-components&quot;&gt;&lt;code&gt;hypershell-hash-components&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; crate. We can run the example program, and it should produce the same output as the previous example that called the &lt;code&gt;sha256sum&lt;&#x2F;code&gt; command:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt; cargo run --example http_checksum_native
&lt;&#x2F;span&gt;&lt;span&gt;c5ce4ff8fb2d768d4cbba8f5bee3d910c527deedec063a0aa436f4ae7005c713
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;language-extension-made-easy&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#language-extension-made-easy&quot; aria-label=&quot;Anchor link for: language-extension-made-easy&quot;&gt;Language Extension Made Easy&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;As we&#x27;ve seen with the final example, with just a few dozen lines of code, we&#x27;ve successfully extended the Hypershell language and added new syntaxes and features. Beyond this simple checksum example, we can imagine more complex features being added to Hypershell in similar ways.&lt;&#x2F;p&gt;
&lt;p&gt;The real beauty of this approach is that &lt;strong&gt;a language extension doesn&#x27;t affect Hypershell&#x27;s core implementation or require any upstream patches or coordination.&lt;&#x2F;strong&gt; &lt;em&gt;Anyone&lt;&#x2F;em&gt; can build a language extension for Hypershell without needing permission from the Hypershell project or having to fork it.&lt;&#x2F;p&gt;
&lt;p&gt;Furthermore, an application that doesn&#x27;t need the extension can choose to continue using only the core implementation, avoiding bloat from the extension&#x27;s dependencies. As a result, developers can freely experiment with and extend the core language without worrying about negatively affecting all users of the language.&lt;&#x2F;p&gt;
&lt;p&gt;With the decoupling of the language syntax from its implementation, we&#x27;re also able to separate the design of new syntaxes from their concrete implementation. For example, we could imagine the &lt;code&gt;Checksum&lt;&#x2F;code&gt; syntax being hosted in a dedicated crate, complete with RFC-like documentation describing its expected behavior. This would allow multiple alternative implementations to coexist and encourage community coordination beyond just library APIs.&lt;&#x2F;p&gt;
&lt;p&gt;For some readers, it might seem like overkill to introduce a feature like a checksum as an extension to a language like Hypershell. However, our main goal here is for you to &lt;strong&gt;imagine&lt;&#x2F;strong&gt; how to apply similar techniques to more complex languages and extensions, especially in problem domains where such decoupling could be highly beneficial.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;future-exercises&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#future-exercises&quot; aria-label=&quot;Anchor link for: future-exercises&quot;&gt;Future Exercises&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;The checksum extension example we demonstrated was intentionally simplified to avoid overwhelming you with too many details. As a result, there are a few straightforward improvements that could enhance the extension&#x27;s quality. I&#x27;ll leave these as exercises for you to implement, serving as a practical first step to getting hands-on with Hypershell and CGP.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;abstract-hasher-syntax&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#abstract-hasher-syntax&quot; aria-label=&quot;Anchor link for: abstract-hasher-syntax&quot;&gt;Abstract Hasher Syntax&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;While the &lt;code&gt;Checksum&amp;lt;Hasher&amp;gt;&lt;&#x2F;code&gt; syntax itself is abstract, the &lt;code&gt;HandleStreamChecksum&lt;&#x2F;code&gt; implementation currently requires the &lt;code&gt;Hasher&lt;&#x2F;code&gt; type to directly implement the &lt;code&gt;Digest&lt;&#x2F;code&gt; trait. Consequently, users of &lt;code&gt;Checksum&lt;&#x2F;code&gt; are forced to include &lt;code&gt;sha2&lt;&#x2F;code&gt; as a dependency in their program to use types like &lt;code&gt;Sha256&lt;&#x2F;code&gt; from that crate.&lt;&#x2F;p&gt;
&lt;p&gt;As an exercise, try to define your own structs (e.g., &lt;code&gt;struct Sha256;&lt;&#x2F;code&gt;) as abstract syntaxes in the crate to be used with &lt;code&gt;Checksum&lt;&#x2F;code&gt;. Then, utilize dependency injection in &lt;code&gt;HandleStreamChecksum&lt;&#x2F;code&gt; to &quot;convert&quot; the abstract &lt;code&gt;Hasher&lt;&#x2F;code&gt; type into a type that implements &lt;code&gt;Digest&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;As a hint, you might need to define an additional trait to provide this mapping, such as:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_type]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;HasHashDigestType&amp;lt;Hasher&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;HashDigest&lt;&#x2F;span&gt;&lt;span&gt;: Digest;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;input-based-dispatch&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#input-based-dispatch&quot; aria-label=&quot;Anchor link for: input-based-dispatch&quot;&gt;Input-Based Dispatch&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;In the wiring of &lt;code&gt;ExtendedHandlerPreset&lt;&#x2F;code&gt;, we defined a pipeline handler for &lt;code&gt;Checksum&lt;&#x2F;code&gt; to process input as a &lt;code&gt;futures::AsyncRead&lt;&#x2F;code&gt; stream. This design means you would encounter type errors when trying to use &lt;code&gt;Checksum&lt;&#x2F;code&gt; with the output from other handlers, such as &lt;code&gt;SimpleExec&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;The &lt;code&gt;Handler&lt;&#x2F;code&gt; component from CGP also provides a &lt;code&gt;UseInputDelegate&lt;&#x2F;code&gt; wrapper. This wrapper dispatches the &lt;code&gt;Handler&lt;&#x2F;code&gt; implementation to inner providers based on the &lt;strong&gt;&lt;code&gt;Input&lt;&#x2F;code&gt; type&lt;&#x2F;strong&gt; rather than the &lt;code&gt;Code&lt;&#x2F;code&gt; type. Try to figure out how you can use &lt;code&gt;UseInputDelegate&lt;&#x2F;code&gt; to define different input conversion pipelines depending on the &lt;code&gt;Input&lt;&#x2F;code&gt; type.&lt;&#x2F;p&gt;
&lt;p&gt;You can look for example implementations within Hypershell itself, where &lt;code&gt;UseInputDelegate&lt;&#x2F;code&gt; is already used to support multiple input stream types.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;alternative-providers&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#alternative-providers&quot; aria-label=&quot;Anchor link for: alternative-providers&quot;&gt;Alternative Providers&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;Our original examples performed the checksum computation using the &lt;code&gt;sha256sum&lt;&#x2F;code&gt; command. This implies that the &lt;code&gt;Checksum&lt;&#x2F;code&gt; syntax could technically also be implemented using the &lt;code&gt;sha256sum&lt;&#x2F;code&gt; command. Try to devise a way to define a second extension preset that contains wiring to forward the &lt;code&gt;Checksum&amp;lt;Sha256&amp;gt;&lt;&#x2F;code&gt; implementation to &lt;code&gt;StreamingExec&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;As a hint, Hypershell provides a &lt;code&gt;Call&lt;&#x2F;code&gt; provider that you can use to implement a provider that &quot;calls&quot; another Hypershell program to implement a given program. Look for how &lt;code&gt;Call&lt;&#x2F;code&gt; is used in the codebase to understand its usage.&lt;&#x2F;p&gt;
&lt;p&gt;You may also need to decide whether &lt;code&gt;Checksum&lt;&#x2F;code&gt; should produce the checksum as raw bytes or a hex string. This is because &lt;code&gt;HandleStreamChecksum&lt;&#x2F;code&gt; currently implements &lt;code&gt;Checksum&lt;&#x2F;code&gt; by returning raw bytes.&lt;&#x2F;p&gt;
&lt;p&gt;As a hint, if you want &lt;code&gt;Checksum&lt;&#x2F;code&gt; to return a hex string, you should add &lt;code&gt;BytesToHex&lt;&#x2F;code&gt; after &lt;code&gt;HandleStreamChecksum&lt;&#x2F;code&gt; within the pipeline for the &lt;code&gt;Checksum&lt;&#x2F;code&gt;&#x27;s wiring. Otherwise, you should implement a &lt;code&gt;HexToBytes&lt;&#x2F;code&gt; handler to convert the hex string returned from &lt;code&gt;sha256sum&lt;&#x2F;code&gt; into bytes.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;discussions&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#discussions&quot; aria-label=&quot;Anchor link for: discussions&quot;&gt;Discussions&lt;&#x2F;a&gt;&lt;&#x2F;h1&gt;
&lt;p&gt;We&#x27;ve finally reached the end of this blog post. Thank you for your patience if you&#x27;re still reading! Although this was a lengthy read, I hope it has covered all essential topics, helping you understand the strengths of Hypershell and CGP.&lt;&#x2F;p&gt;
&lt;p&gt;Hopefully, by now, you&#x27;ve grasped enough about CGP to be interested in learning more. If you&#x27;re intrigued by the project, this section summarizes some follow-up discussions and future work for CGP.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;background&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#background&quot; aria-label=&quot;Anchor link for: background&quot;&gt;Background&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Here&#x27;s a little backstory about the name &quot;Hypershell&quot;. Many years ago, around 2012, I started a project called Hypershell, sparked by the idea of designing HTTP APIs to be pipeable, similar to CLI applications. The idea didn&#x27;t last long, as I eventually discovered better levels of abstraction than the raw HTTP protocol that could achieve similar shell-like pipelines.&lt;&#x2F;p&gt;
&lt;p&gt;Nevertheless, the concepts behind Hypershell and the learning experience ultimately led to the development of CGP. Compared to my initial idea, CGP is far more general and supports more than just constructing pipelines between shell-like applications.&lt;&#x2F;p&gt;
&lt;p&gt;More recently, while searching for suitable examples for CGP, I remembered Hypershell and thought it would serve as a fitting homage to the original project I started.&lt;&#x2F;p&gt;
&lt;p&gt;Many years have passed since then, and the word &quot;Hypershell&quot; has become much more popular than when I first came up with the name, now used for various products and projects. Nonetheless, I still like to reuse the name for this project, as it holds personal meaning for my programming journey.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;advantages&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#advantages&quot; aria-label=&quot;Anchor link for: advantages&quot;&gt;Advantages&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Let&#x27;s discuss the pros and cons of using the approach outlined in this blog post to implement a DSL in Rust with CGP.&lt;&#x2F;p&gt;
&lt;p&gt;The greatest advantage of our approach is the &lt;em&gt;extensibility and interoperability&lt;&#x2F;em&gt; it offers. With CGP as the base framework, the DSL can decouple its syntax from its semantics, allowing language extensions to be implemented as new presets.&lt;&#x2F;p&gt;
&lt;p&gt;Furthermore, the ease of extension makes it very straightforward for DSL programs to interoperate seamlessly with Rust, without needing interoperability layers like FFI. CGP even facilitates interoperability between &lt;em&gt;multiple&lt;&#x2F;em&gt; DSLs, as, at the end of the day, we&#x27;re simply writing CGP programs that happen to resemble DSLs.&lt;&#x2F;p&gt;
&lt;p&gt;Additionally, by hosting the DSL programs as types and interpreting them at compile time, we can bypass any runtime overhead associated with hosting a DSL, allowing it to run at native speed.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;disadvantages&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#disadvantages&quot; aria-label=&quot;Anchor link for: disadvantages&quot;&gt;Disadvantages&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;steep-learning-curve&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#steep-learning-curve&quot; aria-label=&quot;Anchor link for: steep-learning-curve&quot;&gt;Steep Learning Curve&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;The primary drawback of building a CGP-based DSL is the potentially &lt;strong&gt;high learning curve&lt;&#x2F;strong&gt;, especially due to the need to learn CGP itself. Despite this lengthy blog post, we&#x27;ve only scratched the surface of CGP and haven&#x27;t even delved into the actual &lt;em&gt;code&lt;&#x2F;em&gt; that powers it. However, this learning curve barrier is more applicable to DSL &lt;em&gt;developers&lt;&#x2F;em&gt; than to DSL &lt;em&gt;users&lt;&#x2F;em&gt;, who generally don&#x27;t need extensive CGP knowledge to write programs for that DSL.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;poor-error-messages&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#poor-error-messages&quot; aria-label=&quot;Anchor link for: poor-error-messages&quot;&gt;Poor Error Messages&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;That said, a significant barrier for DSL users is the potentially poor experience when encountering errors. A major problem is that when a type error occurs, users would see errors displayed for the &lt;em&gt;entire&lt;&#x2F;em&gt; DSL program. Furthermore, with many levels of indirection, even a single mistake can trigger dozens of error messages from the Rust compiler.&lt;&#x2F;p&gt;
&lt;p&gt;There are potential ways to improve the Rust compiler to show more helpful error messages. However, this work could take a long time and might require sufficient demand from CGP users to justify the requested changes.&lt;&#x2F;p&gt;
&lt;p&gt;As an alternative, some preliminary experiments have shown AI editors like Cursor are getting pretty good at deciphering the error messages and give the right intuitions on how to fix the errors.&lt;&#x2F;p&gt;
&lt;p&gt;In fact, I have a feeling that DSLs might be much better suited for &quot;vibe coding&quot; compared to general-purpose languages, as they are closer to human languages and thus easier for both humans and AI to work with.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;dynamic-loading&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#dynamic-loading&quot; aria-label=&quot;Anchor link for: dynamic-loading&quot;&gt;Dynamic Loading&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;Another disadvantage of our DSL approach is the flip side of its strength: since the DSL is hosted at compile time, this technique cannot be easily used to run DSL programs loaded into a host application during runtime. This means that, at least for now, we cannot use this technique to build DSLs for use cases such as configuration files, plugins, or game mods.&lt;&#x2F;p&gt;
&lt;p&gt;While I have some ideas to blend static and dynamic approaches for building DSLs, that research will likely only occur in the distant future.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;slow-compilation-time&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#slow-compilation-time&quot; aria-label=&quot;Anchor link for: slow-compilation-time&quot;&gt;Slow Compilation Time&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;Lastly, there&#x27;s a more general problem of slow compile times for CGP-based programs, especially when the final executable is built. Since CGP programs are written as highly generic code with minimal dependencies, most CGP crates can actually compile &lt;em&gt;much faster&lt;&#x2F;em&gt; than regular Rust dependencies. However, as most abstract implementations are only instantiated &lt;em&gt;lazily&lt;&#x2F;em&gt; at the end when a method is called on the concrete type, that&#x27;s when compilation becomes very slow.&lt;&#x2F;p&gt;
&lt;p&gt;In particular, CGP program compilation becomes slow when Rust builds executables and tests that contain &lt;code&gt;main&lt;&#x2F;code&gt; functions. This is especially problematic when multiple executables need to be compiled. This is likely because each executable triggers its own generic instantiation that isn&#x27;t shared between other compilation units, so nothing speeds up subsequent builds even when they&#x27;re instantiated with the same generic parameters.&lt;&#x2F;p&gt;
&lt;p&gt;When using CGP with DSLs, slow compilation can potentially worsen, as each DSL program would trigger unique generic instantiations that need to be compiled separately. Additionally, even though we can easily define new CGP contexts that share the same preset, doing so would likely cause Rust to recompile all generic code with the new context, significantly slowing down compilation.&lt;&#x2F;p&gt;
&lt;p&gt;On the other hand, I&#x27;ve conducted some rough experiments to test whether the &lt;em&gt;size&lt;&#x2F;em&gt; of a DSL program affects compilation time. It appears that doubling the program size results in relatively little increase in compile time, at least if the same set of features are used in the program. This suggests that the main penalty occurs the first time a heavyweight dependency is loaded, such as when the provider that uses &lt;code&gt;reqwest&lt;&#x2F;code&gt; is loaded. After that, it matters less whether our DSL program uses the same provider once or many times.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;related-work&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#related-work&quot; aria-label=&quot;Anchor link for: related-work&quot;&gt;Related Work&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Let&#x27;s briefly discuss some related work that influenced the design of Hypershell and CGP. It would be impractical to list all related work, so I&#x27;ll only cover the topics I find most interesting.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;tagless-final&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#tagless-final&quot; aria-label=&quot;Anchor link for: tagless-final&quot;&gt;Tagless Final&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;First and foremost, the techniques used by CGP and Hypershell are closely related to the &lt;strong&gt;tagless final&lt;&#x2F;strong&gt; style of programming. In particular, we make extensive use of traits (typeclasses) to implement and compose each part of the DSL into a full language.&lt;&#x2F;p&gt;
&lt;p&gt;However, our approach differs enough from tagless final that I want to avoid people thinking they&#x27;re identical. Specifically, CGP focuses on having an additional &lt;code&gt;Context&lt;&#x2F;code&gt; parameter that provides dependency injection, and provider traits with unique &lt;code&gt;Self&lt;&#x2F;code&gt; types. The original tagless final approach lacks such a context type or provider type, making it less flexible in modularizing the DSL implementation.&lt;&#x2F;p&gt;
&lt;p&gt;Furthermore, many DSL approaches, including tagless final, focus on defining the DSL program at the &lt;em&gt;term-level&lt;&#x2F;em&gt;, whereas Hypershell DSL programs are defined at the &lt;em&gt;type-level&lt;&#x2F;em&gt;.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;servant&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#servant&quot; aria-label=&quot;Anchor link for: servant&quot;&gt;Servant&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;Our approach of defining DSL programs as types shares many similarities with the type-level DSL techniques used by &lt;a href=&quot;https:&#x2F;&#x2F;www.servant.dev&#x2F;posts&#x2F;2018-07-12-servant-dsl-typelevel.html&quot;&gt;Servant&lt;&#x2F;a&gt;, which provides a DSL for defining server-side web APIs. Similar to Hypershell, Servant also defines abstract syntaxes as dummy types and performs type-level interpretation using typeclasses.&lt;&#x2F;p&gt;
&lt;p&gt;Compared to Hypershell, Servant implements its traits directly on its syntax types. This is similar to a simpler CGP programming pattern called &lt;strong&gt;higher-order providers&lt;&#x2F;strong&gt;. On the other hand, Hypershell decouples the implementation of provider traits from the definition of abstract syntax. This allows Hypershell users to replace a syntax&#x27;s underlying implementation with a different provider. With Servant, the DSL can only support language extension with new syntaxes by directly implementing typeclass instances for that new syntax.&lt;&#x2F;p&gt;
&lt;p&gt;Ergonomically, Servant is heavily based on the &lt;code&gt;Handler&lt;&#x2F;code&gt; monad, while Hypershell provides the same functionality through the &lt;code&gt;Handler&lt;&#x2F;code&gt; trait without directly exposing monads to users. Although this might be less powerful than using full-blown monads, Hypershell&#x27;s approach aligns better with Rust&#x27;s ergonomics and reduces the learning barrier for potential users who may be unfamiliar with functional programming jargon.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;future-dsls&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#future-dsls&quot; aria-label=&quot;Anchor link for: future-dsls&quot;&gt;Future DSLs&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;As mentioned earlier, Hypershell is only the first DSL built using CGP. Using the same DSL techniques, we can build other DSLs that could potentially be more useful in solving practical real-world problems. This section outlines some DSL ideas that I&#x27;d like to see developed in the near future, either by me or perhaps by some of you in the community.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;lambda-calculus&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#lambda-calculus&quot; aria-label=&quot;Anchor link for: lambda-calculus&quot;&gt;Lambda Calculus&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;One idea I&#x27;d like to try after this blog post is to implement a simple &lt;strong&gt;lambda calculus&lt;&#x2F;strong&gt; DSL using the same programming techniques outlined here. While embedding lambda calculus itself isn&#x27;t particularly interesting, the groundwork of this experiment will explore the feasibility of embedding general-purpose languages as type-level DSLs in Rust.&lt;&#x2F;p&gt;
&lt;p&gt;In particular, if we can demonstrate that it&#x27;s possible to build a Turing-complete DSL with CGP, it will open doors to new ways of implementing programming languages with CGP and Rust. A follow-up to this experiment would also include mixing both static and dynamic interpretation of the language, along with some just-in-time optimization techniques to run a scripting language with CGP.&lt;&#x2F;p&gt;
&lt;p&gt;This experiment will probably involve a more complex procedural macro that desugars a surface syntax containing named variables into an abstract syntax that works with &lt;strong&gt;De Bruijn indices&lt;&#x2F;strong&gt;, since we likely can&#x27;t perform generic named field access over an &lt;em&gt;anonymous&lt;&#x2F;em&gt; product type for closures due to coherence restrictions.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;html&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#html&quot; aria-label=&quot;Anchor link for: html&quot;&gt;HTML&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;An idea I&#x27;ve been keen to work on is to use CGP to build a DSL for &lt;strong&gt;HTML&lt;&#x2F;strong&gt;, or more generally, &lt;strong&gt;web frontends&lt;&#x2F;strong&gt;, so I can rebuild this current website using CGP.&lt;&#x2F;p&gt;
&lt;p&gt;The idea behind an HTML-based DSL is quite simple: whether we&#x27;re building a static webpage, performing server-side rendering, or client-side rendering, we&#x27;re essentially writing our frontend code as an abstract DSL program that is interpreted by &lt;em&gt;different contexts&lt;&#x2F;em&gt; based on the use case.&lt;&#x2F;p&gt;
&lt;p&gt;A static webpage would then be a simple program with minimal dependencies that can run with all concrete contexts, just as a Hypershell program that only uses CLI features can be run by both &lt;code&gt;HypershellCli&lt;&#x2F;code&gt; and &lt;code&gt;HypershellHttp&lt;&#x2F;code&gt;. On the other hand, a more complex program that utilizes more dependencies might only run with a more feature-complete context, such as one that works with client-side rendering.&lt;&#x2F;p&gt;
&lt;p&gt;While I believe there&#x27;s potential for solving frontend development with CGP, I&#x27;ve opted to start with Hypershell as a proof of concept, as it has significantly less complexity than frontend development. Furthermore, even if we had a proof-of-concept version of the HTML DSL, there might be never-ending rabbit holes to fill before the prototype becomes &quot;production-ready&quot; enough to rival React or Leptos.&lt;&#x2F;p&gt;
&lt;p&gt;Aside from that, although I would love to explore developing frontend applications using CGP, the future prospects of becoming a professional frontend developer who needs to convince everyone else to use Rust&#x2F;CGP don&#x27;t align well with my long-term career goals. As a result, I&#x27;ve personally tried not to associate CGP too closely with web development to avoid accidentally falling back into the wrong career track.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;parsers&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#parsers&quot; aria-label=&quot;Anchor link for: parsers&quot;&gt;Parsers&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;Another idea I&#x27;m keen to work on is building &lt;strong&gt;parsers&lt;&#x2F;strong&gt; as a CGP DSL, particularly for parsing Rust&#x27;s &lt;code&gt;TokenStream&lt;&#x2F;code&gt; as a starting point. The DSL approach we use here is quite similar to &lt;strong&gt;parser combinator&lt;&#x2F;strong&gt; techniques but with further modularity for even more flexible parsing.&lt;&#x2F;p&gt;
&lt;p&gt;The initial use case for this would be for dog-fooding — implementing the CGP procedural macros using CGP itself. Currently, the CGP macro implementation contains a lot of ad-hoc parsing code implemented using &lt;code&gt;syn&lt;&#x2F;code&gt; and the &lt;code&gt;Parse&lt;&#x2F;code&gt; trait. As CGP&#x27;s surface syntax becomes more complex, there&#x27;s an increasing need to leverage CGP in its own procedural macros to modularize how macros like &lt;code&gt;delegate_components!&lt;&#x2F;code&gt; and &lt;code&gt;cgp_preset!&lt;&#x2F;code&gt; are implemented.&lt;&#x2F;p&gt;
&lt;p&gt;The implementation of this CGP-based parser DSL will share some similarities with the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;unsynn&quot;&gt;&lt;code&gt;unsynn&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; crate, which already offers a more declarative parsing approach compared to &lt;code&gt;syn&lt;&#x2F;code&gt;. However, with CGP, there should be less need to declare structs and syntax rules inside macros, as we can use CGP itself to perform the wiring and generic implementations.&lt;&#x2F;p&gt;
&lt;p&gt;That said, there&#x27;s still a feature lacking in CGP that I need to implement first: the &lt;strong&gt;builder pattern&lt;&#x2F;strong&gt;. In short, the CGP builder pattern involves defining &lt;em&gt;partial structs&lt;&#x2F;em&gt; that may contain uninitialized fields, which will be filled incrementally by different parser providers. Just as the CGP accessor pattern supports generic access to fields using &lt;code&gt;HasField&lt;&#x2F;code&gt;, the CGP builder pattern will support generic &lt;em&gt;construction&lt;&#x2F;em&gt; of struct fields using new traits that will be introduced.&lt;&#x2F;p&gt;
&lt;p&gt;As a result, we may need to wait until the next major version of CGP is released before we can start building a parser DSL with CGP.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;monadic-computation&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#monadic-computation&quot; aria-label=&quot;Anchor link for: monadic-computation&quot;&gt;Monadic Computation&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;In a longer time horizon, once we&#x27;ve proven the feasibility of implementing lambda calculus with CGP, a potential avenue I&#x27;d like to explore is enabling &lt;strong&gt;monadic computation&lt;&#x2F;strong&gt; as a DSL with CGP. The main use case for this is to better support property testing and model checking in Rust, but it could also be extended further to support full algebraic effects.&lt;&#x2F;p&gt;
&lt;p&gt;The main idea here is to enable something similar to Haskell&#x27;s &lt;code&gt;do&lt;&#x2F;code&gt;-notation as a DSL, without directly exposing monads in Rust programs. This DSL is expected to be used only for writing very high-level core logic, where method calls may return non-deterministic results. With this, a test context can use monads to perform non-deterministic computation on the logic, while a production context can run the same program without using monads at all.&lt;&#x2F;p&gt;
&lt;p&gt;It&#x27;s worth noting that we aim to introduce monads as a DSL not for writing &quot;fancy&quot; functional programs, but out of necessity for writing better tests in Rust. For instance, the &lt;code&gt;Arbitrary&lt;&#x2F;code&gt; monad used by property testing frameworks like QuickCheck is essential for writing property test code with cleaner syntax. Without monads, Rust crates like &lt;code&gt;proptest&lt;&#x2F;code&gt; resort to complex macros and ad-hoc type signatures to emulate what could easily be done with monads and the &lt;code&gt;do&lt;&#x2F;code&gt; notation.&lt;&#x2F;p&gt;
&lt;p&gt;More generally, having support for non-deterministic monads will allow us to write some form of model checking code similar to TLA+, but directly within Rust. At the moment, similar functionality can also be achieved using &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;model-checking&#x2F;kani&quot;&gt;Kani&lt;&#x2F;a&gt;; however, that requires dedicated toolchains to compile the Rust code to run with external verifiers.&lt;&#x2F;p&gt;
&lt;p&gt;On one hand, I think CGP has great potential to make Rust code play well with Kani by decoupling application code from complex libraries that cannot run easily with Kani. On the other hand, I&#x27;m also curious to explore how much model checking we can do within Rust itself without external tools like Kani, if we had some form of access to the full power of monads in Rust.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;non-dsl-use-cases&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#non-dsl-use-cases&quot; aria-label=&quot;Anchor link for: non-dsl-use-cases&quot;&gt;Non-DSL Use Cases&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;While this blog post focuses on building DSLs, it&#x27;s entirely feasible to create modular applications using only CGP, without turning them into DSLs. We&#x27;ll explore normal application development with CGP in future posts.&lt;&#x2F;p&gt;
&lt;p&gt;The CGP project is currently prioritizing DSL development, mainly because it&#x27;s a relatively unexplored niche in Rust, making it easier to gain traction, as compared to the negative connotation that is often associated to the term &quot;framework&quot;. Furthermore, DSLs have a clearer separation between two groups of people: the implementor of the DSL and its users.&lt;&#x2F;p&gt;
&lt;p&gt;In contrast, normal application development has less defined boundaries, reducing the appeal of modularity. While there are &lt;a href=&quot;https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=mfdVAyA443Q&quot;&gt;clear technical benefits&lt;&#x2F;a&gt; of modularity even for single-party software, such as improved maintainability and testability, these are often overlooked by development teams focused on short-term business gains. Therefore, CGP shines best when developers build reusable components for &lt;em&gt;other&lt;&#x2F;em&gt; developers, creating a separation between those who value modularity and those who simply consume it.&lt;&#x2F;p&gt;
&lt;p&gt;A potential use case for CGP is building modular web frameworks with reusable components for cross-cutting concerns like authentication, caching, and logging. However, similar to the HTML DSL, the web framework space is crowded and competitive, and I want to avoid associating CGP or my career too closely with web development. This will likely be a lower priority until after CGP establishes itself in areas like DSL development.&lt;&#x2F;p&gt;
&lt;p&gt;CGP could also be well-suited for specialized domains like database design, game development, or machine learning. However, my limited expertise in these areas and the demands of developing CGP in my free time make it challenging to build sufficiently advanced solutions for these problem domains.&lt;&#x2F;p&gt;
&lt;p&gt;Ultimately, it&#x27;s unrealistic for one &lt;em&gt;individual&lt;&#x2F;em&gt; to address every problem that CGP could solve. This is where &lt;em&gt;you&lt;&#x2F;em&gt; and the &lt;em&gt;early adopter community&lt;&#x2F;em&gt; can contribute.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;contribution-and-support&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#contribution-and-support&quot; aria-label=&quot;Anchor link for: contribution-and-support&quot;&gt;Contribution and Support&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;As mentioned, I see my role as &lt;em&gt;enabling&lt;&#x2F;em&gt; developers who value modularity to &lt;em&gt;produce&lt;&#x2F;em&gt; reusable components for other developers (or machines) to &lt;em&gt;consume&lt;&#x2F;em&gt; without needing to value CGP or modularity. This way, &lt;em&gt;everyone&lt;&#x2F;em&gt; benefits from CGP, regardless of their views on software development.&lt;&#x2F;p&gt;
&lt;p&gt;While I&#x27;d love to build every potential solution offered by CGP myself, I lack the capacity, expertise, and motivation, especially given my need to earn a living through other means. My goal is to provide enough examples to demonstrate CGP&#x27;s potential and foster a community of developers around it.&lt;&#x2F;p&gt;
&lt;p&gt;If you&#x27;re convinced of CGP&#x27;s potential and want to help, here are some ways to get involved:&lt;&#x2F;p&gt;
&lt;h3 id=&quot;join-the-community&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#join-the-community&quot; aria-label=&quot;Anchor link for: join-the-community&quot;&gt;Join the Community&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;We now have a &lt;a href=&quot;https:&#x2F;&#x2F;discord.gg&#x2F;Hgk3rCw6pQ&quot;&gt;community Discord&lt;&#x2F;a&gt; for CGP! It&#x27;s likely to be small initially, so feel free to start discussions about CGP without worrying about noise. Since many CGP concepts are new and undocumented, please ask any questions you have in the Discord, no matter how basic they seem.&lt;&#x2F;p&gt;
&lt;p&gt;Besides the Discord, we also have a &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;orgs&#x2F;contextgeneric&#x2F;discussions&quot;&gt;GitHub Discussions&lt;&#x2F;a&gt; forum and a &lt;a href=&quot;https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;cgp&#x2F;&quot;&gt;Reddit&lt;&#x2F;a&gt; community for more formalized public discussions.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;build-your-own-dsl-and-libraries&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#build-your-own-dsl-and-libraries&quot; aria-label=&quot;Anchor link for: build-your-own-dsl-and-libraries&quot;&gt;Build Your Own DSL and Libraries&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;Feel free to use the project ideas I outlined earlier, or develop your own and start a CGP project. Given the limited available resources, please ask questions in the Discord if you encounter any difficulties understanding the concepts.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;sponsor-me&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#sponsor-me&quot; aria-label=&quot;Anchor link for: sponsor-me&quot;&gt;Sponsor Me&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;If you appreciate my work and want to see CGP gain wider adoption, the best way to support it is to &lt;em&gt;sponsor&lt;&#x2F;em&gt; me, regardless of the amount. I have sponsorship pages on &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;sponsors&#x2F;soareschen&#x2F;&quot;&gt;Github Sponsor&lt;&#x2F;a&gt;, &lt;a href=&quot;https:&#x2F;&#x2F;www.patreon.com&#x2F;c&#x2F;maybevoid&#x2F;about&quot;&gt;Patreon&lt;&#x2F;a&gt;, and &lt;a href=&quot;https:&#x2F;&#x2F;ko-fi.com&#x2F;maybevoid&quot;&gt;Ko-Fi&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;As with most open-source projects&lt;&#x2F;em&gt;, I don&#x27;t expect sponsorship to be enough to allow me to quit my job and work full-time on CGP, or even &lt;em&gt;with&lt;&#x2F;em&gt; CGP. &lt;em&gt;However&lt;&#x2F;em&gt;, any financial support will significantly boost my confidence in the &lt;em&gt;value&lt;&#x2F;em&gt; of my work and encourage me to continue dedicating hundreds of hours of my free time to it instead of other pursuits.&lt;&#x2F;p&gt;
&lt;p&gt;I do hope to eventually spend a year or two working full-time on CGP using my &lt;em&gt;personal savings&lt;&#x2F;em&gt;, even if sponsorships don&#x27;t cover my living expenses. &lt;em&gt;However&lt;&#x2F;em&gt;, exponential growth is important, and if I could secure around a quarter of my living expenses through monthly sponsorship, it would reduce some risk and suggest a higher chance of CGP becoming self-sustaining later on.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;learn-more-1&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#learn-more-1&quot; aria-label=&quot;Anchor link for: learn-more-1&quot;&gt;Learn More&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;Finally, thank you to everyone who reached the end of this blog post. Please visit the &lt;a href=&quot;&#x2F;&quot;&gt;project homepage&lt;&#x2F;a&gt; to learn more about CGP, and let&#x27;s start writing context-generic code!&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>CGP v0.4.1 Release</title>
        <published>2025-06-14T00:00:00+00:00</published>
        <updated>2025-06-14T00:00:00+00:00</updated>
        
        <author>
          <name>
            Soares Chen
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://www.contextgeneric.dev/blog/v0-4-1-release/"/>
        <id>https://www.contextgeneric.dev/blog/v0-4-1-release/</id>
        
        <content type="html" xml:base="https://www.contextgeneric.dev/blog/v0-4-1-release/">&lt;h1 id=&quot;overview&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#overview&quot; aria-label=&quot;Anchor link for: overview&quot;&gt;Overview&lt;&#x2F;a&gt;&lt;&#x2F;h1&gt;
&lt;p&gt;We are excited to announce the release of CGP v0.4.1! This release brings several new features, quality-of-life improvements for macro usages, and a new crate &lt;code&gt;cgp-handler&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Here are some of the highlights:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;New &lt;code&gt;cgp-handler&lt;&#x2F;code&gt; crate&lt;&#x2F;strong&gt;: Provides abstract interfaces for defining components with common method signatures.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;cgp_preset!&lt;&#x2F;code&gt; macro improvement&lt;&#x2F;strong&gt;: Now supports wrapping of &lt;code&gt;Preset::Provider&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;#[cgp_component]&lt;&#x2F;code&gt; macro improvement&lt;&#x2F;strong&gt;: Now supports automated derivation of &lt;code&gt;UseDelegate&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Improved Documentation&lt;&#x2F;strong&gt;: Added inline Rust documentation for common CGP constructs.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Below we will go through some of the most significant changes in this release.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;new-cgp-handler-crate&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#new-cgp-handler-crate&quot; aria-label=&quot;Anchor link for: new-cgp-handler-crate&quot;&gt;New &lt;code&gt;cgp-handler&lt;&#x2F;code&gt; Crate&lt;&#x2F;a&gt;&lt;&#x2F;h1&gt;
&lt;p&gt;This release introduces a new &lt;code&gt;cgp-handler&lt;&#x2F;code&gt; crate, which offers abstract interfaces for defining components with common method signatures. This helps in creating reusable and composable handlers for various tasks.&lt;&#x2F;p&gt;
&lt;p&gt;As a semi-stable and non-essential crate, the &lt;code&gt;cgp-handler&lt;&#x2F;code&gt; crate is re-exported by &lt;code&gt;cgp-extra&lt;&#x2F;code&gt;, and is available from &lt;code&gt;cgp::extra::handler&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;The introduction of &lt;code&gt;cgp-handler&lt;&#x2F;code&gt; is mainly to support the development of &lt;a href=&quot;&#x2F;blog&#x2F;hypershell-release&quot;&gt;Hypershell&lt;&#x2F;a&gt;, which makes heavy use of the &lt;code&gt;Handler&lt;&#x2F;code&gt; component to design and implement its DSL providers.&lt;&#x2F;p&gt;
&lt;p&gt;The crate introduces three main components: &lt;code&gt;Handler&lt;&#x2F;code&gt;, &lt;code&gt;Computer&lt;&#x2F;code&gt;, and &lt;code&gt;Producer&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;handler&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#handler&quot; aria-label=&quot;Anchor link for: handler&quot;&gt;&lt;code&gt;Handler&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;The &lt;code&gt;Handler&lt;&#x2F;code&gt; component provides the most commonly used interface for performing asynchronous operations that may fail:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_component(Handler)]
&lt;&#x2F;span&gt;&lt;span&gt;#[async_trait]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;CanHandle&amp;lt;Code: Send, Input: Send&amp;gt;: HasAsyncErrorType {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Output&lt;&#x2F;span&gt;&lt;span&gt;: Send;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    async &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;handle(
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self,
&lt;&#x2F;span&gt;&lt;span&gt;        _tag: PhantomData&amp;lt;Code&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        input: Input,
&lt;&#x2F;span&gt;&lt;span&gt;    ) -&amp;gt; Result&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;Output, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;Error&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;computer&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#computer&quot; aria-label=&quot;Anchor link for: computer&quot;&gt;&lt;code&gt;Computer&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;The &lt;code&gt;Computer&lt;&#x2F;code&gt; component mirrors a pure function that takes some input, performs some computation, and produces an output.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_component(Computer)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;CanCompute&amp;lt;Code, Input&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Output&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;compute(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self, _tag: PhantomData&amp;lt;Code&amp;gt;, input: Input) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;Output;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;producer&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#producer&quot; aria-label=&quot;Anchor link for: producer&quot;&gt;&lt;code&gt;Producer&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;The &lt;code&gt;Producer&lt;&#x2F;code&gt; component mirrors a global singleton function to produce an output value. It is useful to emulate global values that cannot be constructed through the &lt;code&gt;const&lt;&#x2F;code&gt; context in Rust, such as &lt;code&gt;String&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_component(Producer)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;CanProduce&amp;lt;Code&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Output&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;produce(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self, _tag: PhantomData&amp;lt;Code&amp;gt;) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;Output;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;code-parameter&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#code-parameter&quot; aria-label=&quot;Anchor link for: code-parameter&quot;&gt;&lt;code&gt;Code&lt;&#x2F;code&gt; Parameter&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;All the traits in &lt;code&gt;cgp-handler&lt;&#x2F;code&gt; contain a phantom &lt;code&gt;Code&lt;&#x2F;code&gt; parameter that can be used for building type-level DSLs such as &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;contextgeneric&#x2F;hypershell&quot;&gt;Hypershell&lt;&#x2F;a&gt;. They can also be used as type-level identifiers for dispatching, such as in API handlers.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;cgp-preset-macro-improvements&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#cgp-preset-macro-improvements&quot; aria-label=&quot;Anchor link for: cgp-preset-macro-improvements&quot;&gt;&lt;code&gt;cgp_preset!&lt;&#x2F;code&gt; Macro Improvements&lt;&#x2F;a&gt;&lt;&#x2F;h1&gt;
&lt;p&gt;This release also brings minor improvements to our &lt;code&gt;cgp_preset!&lt;&#x2F;code&gt; macro, supporting the definition of CGP presets for more diverse use cases.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;support-for-wrapping-preset-provider-in-cgp-preset&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#support-for-wrapping-preset-provider-in-cgp-preset&quot; aria-label=&quot;Anchor link for: support-for-wrapping-preset-provider-in-cgp-preset&quot;&gt;Support for Wrapping &lt;code&gt;Preset::Provider&lt;&#x2F;code&gt; in &lt;code&gt;cgp_preset!&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;The &lt;code&gt;cgp_preset!&lt;&#x2F;code&gt; macro now allows users to specify a &lt;code&gt;#[wrap_provider]&lt;&#x2F;code&gt; attribute to wrap the &lt;code&gt;Preset::Provider&lt;&#x2F;code&gt; type. This is particularly useful when using CGP presets to define extensible mappings for generic dispatch through the &lt;code&gt;UseDelegate&lt;&#x2F;code&gt; pattern.&lt;&#x2F;p&gt;
&lt;p&gt;Wrapping the provider makes it easier to extend non-provider mappings across multiple levels of preset inheritance. The wrapped &lt;code&gt;Preset::Provider&lt;&#x2F;code&gt; type will implement the expected provider trait, making it a valid delegation target.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;example&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#example&quot; aria-label=&quot;Anchor link for: example&quot;&gt;Example&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;Given the following preset definition:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;cgp_preset! {
&lt;&#x2F;span&gt;&lt;span&gt;    #[wrap_provider(UseDelegate)]
&lt;&#x2F;span&gt;&lt;span&gt;    MyHandlerPreset {
&lt;&#x2F;span&gt;&lt;span&gt;        String: HandleString,
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u64&lt;&#x2F;span&gt;&lt;span&gt;: HandleU64,
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The macro generates the following implementation:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub mod &lt;&#x2F;span&gt;&lt;span&gt;MyHandlerPreset {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Provider &lt;&#x2F;span&gt;&lt;span&gt;= UseDelegate&amp;lt;Components&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    delegate_components! {
&lt;&#x2F;span&gt;&lt;span&gt;        new Components {
&lt;&#x2F;span&gt;&lt;span&gt;            String: HandleString,
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u64&lt;&#x2F;span&gt;&lt;span&gt;: HandleU64,
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;automated-usedelegate-derivation-in-cgp-component&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#automated-usedelegate-derivation-in-cgp-component&quot; aria-label=&quot;Anchor link for: automated-usedelegate-derivation-in-cgp-component&quot;&gt;Automated &lt;code&gt;UseDelegate&lt;&#x2F;code&gt; Derivation in &lt;code&gt;#[cgp_component]&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;The &lt;code&gt;#[cgp_component]&lt;&#x2F;code&gt; family of macros now includes a &lt;code&gt;derive_delegate&lt;&#x2F;code&gt; field, which allows for the automated implementation of &lt;code&gt;UseDelegate&lt;&#x2F;code&gt; for CGP components. This reduces boilerplate code that was previously required to be implemented manually.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;example-1&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#example-1&quot; aria-label=&quot;Anchor link for: example-1&quot;&gt;Example&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;The updated &lt;code&gt;ErrorRaiser&lt;&#x2F;code&gt; component can now be defined as:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_component {
&lt;&#x2F;span&gt;&lt;span&gt;    provider: ErrorRaiser,
&lt;&#x2F;span&gt;&lt;span&gt;    derive_delegate: UseDelegate&amp;lt;SourceError&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;CanRaiseError&amp;lt;SourceError&amp;gt;: HasErrorType {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;raise_error(error: SourceError) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;Error;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This will automatically derive the &lt;code&gt;UseDelegate&lt;&#x2F;code&gt; implementation:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_provider(ErrorRaiserComponent)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;Context, SourceError, Components, Delegate&amp;gt; ErrorRaiser&amp;lt;Context, SourceError&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    for UseDelegate&amp;lt;Components&amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;    Context: HasErrorType,
&lt;&#x2F;span&gt;&lt;span&gt;    Components: DelegateComponent&amp;lt;SourceError, Delegate = Delegate&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    Delegate: ErrorRaiser&amp;lt;Context, SourceError&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;raise_error(e: SourceError) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Context::&lt;&#x2F;span&gt;&lt;span&gt;Error {
&lt;&#x2F;span&gt;&lt;span&gt;        Delegate::raise_error(e)
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h1 id=&quot;other-improvements&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#other-improvements&quot; aria-label=&quot;Anchor link for: other-improvements&quot;&gt;Other Improvements&lt;&#x2F;a&gt;&lt;&#x2F;h1&gt;
&lt;p&gt;This release also includes several other minor improvements and fixes:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Improved Documentation&lt;&#x2F;strong&gt;: We have added inline Rust documentation for many common CGP constructs, making it easier for developers to understand and use them. This is part of our ongoing effort to improve the developer experience.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Static &lt;code&gt;Char&lt;&#x2F;code&gt; Formatting&lt;&#x2F;strong&gt;: The &lt;code&gt;Char&lt;&#x2F;code&gt; type can now be formatted statically without requiring &lt;code&gt;self&lt;&#x2F;code&gt;, which allows type-level strings to be formatted without constructing any value.&lt;&#x2F;li&gt;
&lt;li&gt;Use &lt;code&gt;__Self__&lt;&#x2F;code&gt; instead of &lt;code&gt;T&lt;&#x2F;code&gt; when deriving &lt;code&gt;Preset::IsPreset&lt;&#x2F;code&gt; to avoid identifier conflicts when users use &lt;code&gt;T&lt;&#x2F;code&gt; in their generic parameters.&lt;&#x2F;li&gt;
&lt;li&gt;Included trait bound identifiers in &lt;code&gt;Preset::components&lt;&#x2F;code&gt; re-export.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;We hope you enjoy the new features and improvements in this release. As always, we welcome feedback and contributions from the community. Check out the project on &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;contextgeneric&#x2F;cgp&#x2F;&quot;&gt;GitHub&lt;&#x2F;a&gt; and the full &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;contextgeneric&#x2F;cgp&#x2F;blob&#x2F;main&#x2F;CHANGELOG.md&quot;&gt;changelog&lt;&#x2F;a&gt; for more details.&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>CGP v0.4.0 is Here: Unlocking Easier Debugging, Extensible Presets, and More!</title>
        <published>2025-05-09T00:00:00+00:00</published>
        <updated>2025-05-09T00:00:00+00:00</updated>
        
        <author>
          <name>
            Soares Chen
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://www.contextgeneric.dev/blog/v0-4-0-release/"/>
        <id>https://www.contextgeneric.dev/blog/v0-4-0-release/</id>
        
        <content type="html" xml:base="https://www.contextgeneric.dev/blog/v0-4-0-release/">&lt;h2 id=&quot;summary&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#summary&quot; aria-label=&quot;Anchor link for: summary&quot;&gt;Summary&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;It&#x27;s been a while since the last update, but the wait is over! I&#x27;m thrilled to announce the release of &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;contextgeneric&#x2F;cgp&#x2F;releases&#x2F;tag&#x2F;v0.4.0&quot;&gt;&lt;code&gt;v0.4.0&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; of the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;cgp&#x2F;0.4.0&#x2F;cgp&#x2F;&quot;&gt;&lt;code&gt;cgp&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; crate. This version is packed with tons of new features and delivers a dramatically smoother developer experience!&lt;&#x2F;p&gt;
&lt;p&gt;This post highlights the major updates developed over the past few months, alongside some personal news.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;game-changing-improvement-debugging-is-finally-easy&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#game-changing-improvement-debugging-is-finally-easy&quot; aria-label=&quot;Anchor link for: game-changing-improvement-debugging-is-finally-easy&quot;&gt;Game-Changing Improvement: Debugging is Finally Easy!&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Have you ever been frustrated by cryptic CGP errors related to unsatisfied dependencies? &lt;a href=&quot;&#x2F;blog&#x2F;early-preview-announcement&#x2F;#improve-error-diagnostics&quot;&gt;Previously&lt;&#x2F;a&gt;, this was a major barrier to &lt;code&gt;cgp&lt;&#x2F;code&gt;&#x27;s wider adoption, as debugging &lt;code&gt;cgp&lt;&#x2F;code&gt; programs was virtually impossible due to Rust hiding the information necessary to fixed the error.&lt;&#x2F;p&gt;
&lt;p&gt;Crucially, this update changes everything! The most significant improvement in v0.4.0 is that it&#x27;s now significantly easier to debug &lt;code&gt;cgp&lt;&#x2F;code&gt; errors that arise from unsatisfied dependencies. We&#x27;ve developed new techniques to overcome this challenge and make Rust show all errors that were previously hidden.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;isproviderfor-trait&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#isproviderfor-trait&quot; aria-label=&quot;Anchor link for: isproviderfor-trait&quot;&gt;&lt;code&gt;IsProviderFor&lt;&#x2F;code&gt; Trait&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;In short, the technique works by introducing a new &lt;code&gt;IsProviderFor&lt;&#x2F;code&gt; trait in &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;contextgeneric&#x2F;cgp&#x2F;pull&#x2F;63&quot;&gt;#63&lt;&#x2F;a&gt;, defined as follows:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;IsProviderFor&amp;lt;Component, Context, Params = ()&amp;gt; {}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;IsProviderFor&lt;&#x2F;code&gt; trait itself isn&#x27;t inherently complex, but it&#x27;s designed to be implemented by providers with additional constraints hidden within the trait implementation. The trait then acts as a &quot;trait-erased&quot; trait to carry around the constraints that the provider used to implement the original provider trait.&lt;&#x2F;p&gt;
&lt;p&gt;Users of CGP don&#x27;t need to understand the details of how &lt;code&gt;IsProviderFor&lt;&#x2F;code&gt; works, only that it&#x27;s used behind the scenes by &lt;code&gt;cgp&lt;&#x2F;code&gt; to show better error messages.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;canusecomponent-trait&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#canusecomponent-trait&quot; aria-label=&quot;Anchor link for: canusecomponent-trait&quot;&gt;&lt;code&gt;CanUseComponent&lt;&#x2F;code&gt; Trait&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;Along with &lt;code&gt;IsProviderFor&lt;&#x2F;code&gt;, a new &lt;code&gt;CanUseComponent&lt;&#x2F;code&gt; blanket trait is introduced as a shorthand to check that a context&#x27;s provider has implemented the &lt;code&gt;IsProviderFor&lt;&#x2F;code&gt; trait. It&#x27;s defined as follows:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;CanUseComponent&amp;lt;Component, Params = ()&amp;gt; {}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;Context, Component, Params&amp;gt; CanUseComponent&amp;lt;Component, Params&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;Context
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;    Context: HasCgpProvider,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Context::&lt;&#x2F;span&gt;&lt;span&gt;CgpProvider: IsProviderFor&amp;lt;Component, Context, Params&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Rather than being implemented by provider types, &lt;code&gt;CanUseComponent&lt;&#x2F;code&gt; is instead automatically implemented by a context type. This makes it more ergonomic to reason about the implementation of a CGP component on a context.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;cgp-provider-macro&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#cgp-provider-macro&quot; aria-label=&quot;Anchor link for: cgp-provider-macro&quot;&gt;&lt;code&gt;#[cgp_provider]&lt;&#x2F;code&gt; Macro&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;The main change required for the new debugging to work is that users must now annotate CGP provider implementations using the &lt;code&gt;#[cgp_provider]&lt;&#x2F;code&gt; or &lt;code&gt;#[cgp_new_provider]&lt;&#x2F;code&gt; macros. For example:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_new_provider]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;Context&amp;gt; Greeter&amp;lt;Context&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;GreetHello
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;    Context: HasName,
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;greet(context: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;Context) {
&lt;&#x2F;span&gt;&lt;span&gt;        println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Hello, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;!&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, context.name());
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The macro then generates the following &lt;code&gt;IsProviderFor&lt;&#x2F;code&gt; implementation, which includes the &lt;code&gt;Context: HasName&lt;&#x2F;code&gt; constraint within it:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;Context&amp;gt; IsProviderFor&amp;lt;GreeterComponent, Context, ()&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    for GreetHello
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;    Context: HasName
&lt;&#x2F;span&gt;&lt;span&gt;{ }
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The main difference between &lt;code&gt;#[cgp_provider]&lt;&#x2F;code&gt; and &lt;code&gt;#[cgp_new_provider]&lt;&#x2F;code&gt; is that &lt;code&gt;#[cgp_new_provider]&lt;&#x2F;code&gt; also generates the provider struct definition (e.g., &lt;code&gt;struct GreetHello;&lt;&#x2F;code&gt;), allowing even less code to be written by hand.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;update-to-delegate-components&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#update-to-delegate-components&quot; aria-label=&quot;Anchor link for: update-to-delegate-components&quot;&gt;Update to &lt;code&gt;delegate_components!&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;In addition to generating &lt;code&gt;DelegateComponent&lt;&#x2F;code&gt; implementations, &lt;code&gt;delegate_components!&lt;&#x2F;code&gt; now also generates &lt;code&gt;IsProviderFor&lt;&#x2F;code&gt; implementations, so that &lt;code&gt;IsProviderFor&lt;&#x2F;code&gt; can remain working across component delegations.&lt;&#x2F;p&gt;
&lt;p&gt;As an example, the following:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;delegate_components! {
&lt;&#x2F;span&gt;&lt;span&gt;    PersonComponents {
&lt;&#x2F;span&gt;&lt;span&gt;        GreeterComponent: GreetHello,
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;generates the following trait implementations:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;DelegateComponent&amp;lt;GreeterComponent&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;PersonComponents {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Delegate &lt;&#x2F;span&gt;&lt;span&gt;= GreetHello;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;Context, Params&amp;gt; IsProviderFor&amp;lt;GreeterComponent, Context, Params&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    for PersonComponents
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;    GreetHello: IsProviderFor&amp;lt;GreeterComponent, Context, Params&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;check-components-macro&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#check-components-macro&quot; aria-label=&quot;Anchor link for: check-components-macro&quot;&gt;&lt;code&gt;check_components!&lt;&#x2F;code&gt; Macro&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;Along with the &lt;code&gt;IsProviderFor&lt;&#x2F;code&gt; trait, &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;contextgeneric&#x2F;cgp&#x2F;pull&#x2F;78&quot;&gt;#78&lt;&#x2F;a&gt; also introduces the &lt;code&gt;check_components!&lt;&#x2F;code&gt; macro to allow users to write compile-time tests to check for the correctness of component wiring for a CGP context. For example:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;check_components! {
&lt;&#x2F;span&gt;&lt;span&gt;    CanUsePerson &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt; Person {
&lt;&#x2F;span&gt;&lt;span&gt;        GreeterComponent,
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The code above generates a &lt;em&gt;check trait&lt;&#x2F;em&gt; called &lt;code&gt;CanUsePerson&lt;&#x2F;code&gt;, which verifies whether the &lt;code&gt;Person&lt;&#x2F;code&gt; context implements the consumer trait for &lt;code&gt;GreeterComponent&lt;&#x2F;code&gt; (i.e., &lt;code&gt;CanGreet&lt;&#x2F;code&gt;):&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;trait &lt;&#x2F;span&gt;&lt;span&gt;CanUsePerson&amp;lt;Component, Params&amp;gt;: CanUseComponent&amp;lt;Component, Params&amp;gt; {}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;CanUsePerson&amp;lt;GreeterComponent, ()&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;Person {}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;delegate-and-check-components-macro&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#delegate-and-check-components-macro&quot; aria-label=&quot;Anchor link for: delegate-and-check-components-macro&quot;&gt;&lt;code&gt;delegate_and_check_components!&lt;&#x2F;code&gt; Macro&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;PR &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;contextgeneric&#x2F;cgp&#x2F;pull&#x2F;84&quot;&gt;#84&lt;&#x2F;a&gt; introduces a new &lt;code&gt;delegate_and_check_components!&lt;&#x2F;code&gt; macro, which combines both &lt;code&gt;delegate_components!&lt;&#x2F;code&gt; and &lt;code&gt;check_components!&lt;&#x2F;code&gt;, allowing both delegation and checks within a single macro call. This is useful for the majority of simple cases, providing immediate feedback on whether the wiring works as intended.&lt;&#x2F;p&gt;
&lt;p&gt;As an example, given the following code:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;delegate_and_check_components! {
&lt;&#x2F;span&gt;&lt;span&gt;    CanUsePerson &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt; Person;
&lt;&#x2F;span&gt;&lt;span&gt;    PersonComponents {
&lt;&#x2F;span&gt;&lt;span&gt;        GreeterComponent: GreetHello,
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;is equivalent to writing the two separate macro calls:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;delegate_components! {
&lt;&#x2F;span&gt;&lt;span&gt;    PersonComponents {
&lt;&#x2F;span&gt;&lt;span&gt;        GreeterComponent: GreetHello,
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;check_components! {
&lt;&#x2F;span&gt;&lt;span&gt;    CanUsePerson &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt; Person {
&lt;&#x2F;span&gt;&lt;span&gt;        GreeterComponent,
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;It&#x27;s worth noting that in more advanced cases, it may still be necessary to call &lt;code&gt;delegate_components!&lt;&#x2F;code&gt; and &lt;code&gt;check_components&lt;&#x2F;code&gt; separately. This applies to cases where the CGP traits contain additional generic parameters, or when the new &lt;em&gt;preset&lt;&#x2F;em&gt; feature (discussed later) is used.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;updated-chapter&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#updated-chapter&quot; aria-label=&quot;Anchor link for: updated-chapter&quot;&gt;Updated Chapter&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;For further details on these debugging breakthroughs, the CGP book has been updated with a &lt;a href=&quot;https:&#x2F;&#x2F;patterns.contextgeneric.dev&#x2F;debugging-support.html&quot;&gt;new chapter&lt;&#x2F;a&gt; that explains this improved debugging support in detail.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;rework-cgp-type-macro&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#rework-cgp-type-macro&quot; aria-label=&quot;Anchor link for: rework-cgp-type-macro&quot;&gt;Rework &lt;code&gt;#[cgp_type]&lt;&#x2F;code&gt; Macro&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;The &lt;code&gt;cgp_type!&lt;&#x2F;code&gt; macro has been reworked in &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;contextgeneric&#x2F;cgp&#x2F;pull&#x2F;68&quot;&gt;#68&lt;&#x2F;a&gt; to become an attribute macro. Previously, in v0.3.0, an abstract type was defined as:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;cgp_type!( Name );
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;From v0.4.0 onward, the macro becomes an attribute macro that follows the same style as &lt;code&gt;#[cgp_component]&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_type]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;HasNameType {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Name&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Although it is more verbose, the new syntax unlocks the ability to define more advanced abstract types with the same macro, such as adding generic parameters or supertraits on the type trait.&lt;&#x2F;p&gt;
&lt;p&gt;Aside from that, &lt;code&gt;#[cgp_type]&lt;&#x2F;code&gt; also generates default names that follow a new naming convention. When left empty, the provider trait is now named &lt;code&gt;&quot;{Type}TypeProvider&quot;&lt;&#x2F;code&gt; instead of &lt;code&gt;&quot;Provide{Type}Type&quot;&lt;&#x2F;code&gt;, and the component is named &lt;code&gt;&quot;{Type}TypeProviderComponent&quot;&lt;&#x2F;code&gt; instead of &lt;code&gt;&quot;{Type}TypeComponent&quot;&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;So the example above is a shorthand for writing:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_type {
&lt;&#x2F;span&gt;&lt;span&gt;    name: NameTypeProviderComponent,
&lt;&#x2F;span&gt;&lt;span&gt;    provider: NameTypeProvider,
&lt;&#x2F;span&gt;&lt;span&gt;}]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;HasNameType {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Name&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;cgp-context-macro&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#cgp-context-macro&quot; aria-label=&quot;Anchor link for: cgp-context-macro&quot;&gt;&lt;code&gt;#[cgp_context]&lt;&#x2F;code&gt; Macro&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;A new &lt;code&gt;#[cgp_context]&lt;&#x2F;code&gt; macro has been introduced in &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;contextgeneric&#x2F;cgp&#x2F;pull&#x2F;66&quot;&gt;#66&lt;&#x2F;a&gt;, and can be applied to context types to simplify the wiring of providers with a context. For example, given the following:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_context]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;Person {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;name: String
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The macro automatically generates the context provider struct and the &lt;code&gt;HasCgpProvider&lt;&#x2F;code&gt; implementation, which previously had to be hand-implemented manually:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;PersonComponents;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;HasCgpProvider &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;Person {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;CgpProvider &lt;&#x2F;span&gt;&lt;span&gt;= PersonComponents;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;HasCgpProvider&lt;&#x2F;code&gt; trait was previously called &lt;code&gt;HasComponents&lt;&#x2F;code&gt; in v0.3.0 and has been renamed in &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;contextgeneric&#x2F;cgp&#x2F;pull&#x2F;97&quot;&gt;#97&lt;&#x2F;a&gt; to better reflect its purpose.&lt;&#x2F;p&gt;
&lt;p&gt;Although the boilerplate reduction is minimal, the &lt;code&gt;#[cgp_context]&lt;&#x2F;code&gt; macro significantly reduces the aesthetic and psychological barrier to defining CGP contexts, making them almost as trivial as defining plain structs.&lt;&#x2F;p&gt;
&lt;p&gt;Additionally, &lt;code&gt;#[cgp_context]&lt;&#x2F;code&gt; also brings support for &lt;em&gt;inheritance&lt;&#x2F;em&gt; of a collection of providers in the form of &lt;em&gt;presets&lt;&#x2F;em&gt;, which we will cover in a moment.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;improved-getter-macros&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#improved-getter-macros&quot; aria-label=&quot;Anchor link for: improved-getter-macros&quot;&gt;Improved Getter Macros&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;The getter macros &lt;code&gt;#[cgp_getter]&lt;&#x2F;code&gt; and &lt;code&gt;#[cgp_auto_getter]&lt;&#x2F;code&gt; have been enhanced with several improvements, making them more usable in broader use cases and boosting developer convenience.&lt;&#x2F;p&gt;
&lt;p&gt;First, with &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;contextgeneric&#x2F;cgp&#x2F;pull&#x2F;81&quot;&gt;#81&lt;&#x2F;a&gt; and &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;contextgeneric&#x2F;cgp&#x2F;pull&#x2F;87&quot;&gt;#87&lt;&#x2F;a&gt;, the macros are now smarter in handling several common special cases, such as the use of &lt;code&gt;&amp;amp;str&lt;&#x2F;code&gt; and &lt;code&gt;Option&amp;lt;&amp;amp;T&amp;gt;&lt;&#x2F;code&gt;. Below are some examples of the new method signatures that are now supported:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; Can be used with `String` field
&lt;&#x2F;span&gt;&lt;span&gt;#[cgp_auto_getter]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;HasName {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;name(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;str&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; Can be used with `Option&amp;lt;Self::Name&amp;gt;` field
&lt;&#x2F;span&gt;&lt;span&gt;#[cgp_auto_getter]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;HasName: HasNameType {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;name(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self) -&amp;gt; Option&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;Self::&lt;&#x2F;span&gt;&lt;span&gt;Name&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; Can be used with `Vec&amp;lt;u8&amp;gt;` field
&lt;&#x2F;span&gt;&lt;span&gt;#[cgp_auto_getter]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;HasBytes {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;bytes(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u8&lt;&#x2F;span&gt;&lt;span&gt;];
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Additionally, with &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;contextgeneric&#x2F;cgp&#x2F;pull&#x2F;64&quot;&gt;#64&lt;&#x2F;a&gt; and &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;contextgeneric&#x2F;cgp&#x2F;pull&#x2F;76&quot;&gt;#76&lt;&#x2F;a&gt;, the getter macros also support generic parameters and accept a second optional &lt;code&gt;PhantomData&lt;&#x2F;code&gt; argument to help with type inference. For example:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_auto_getter]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;HasName&amp;lt;App&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;    App: HasNameType,
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;name(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self, _tag: PhantomData&amp;lt;App&amp;gt;) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;App::&lt;&#x2F;span&gt;&lt;span&gt;Name;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;contextgeneric&#x2F;cgp&#x2F;pull&#x2F;94&quot;&gt;#94&lt;&#x2F;a&gt;, we&#x27;ve also added support for using &lt;em&gt;getter combinators&lt;&#x2F;em&gt; to implement more complex getters to access fields that are nested within other structs in a context. For example, the following code allows the getter for &lt;code&gt;listen_port&lt;&#x2F;code&gt; to be implemented via &lt;code&gt;context.config.network.listen_port&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_getter]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;HasListenPort {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;listen_port(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;u16&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[cgp_context(MyContextComponents)]
&lt;&#x2F;span&gt;&lt;span&gt;#[derive(HasField)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;MyContext {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;config: Config,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[derive(HasField)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;Config {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;network: NetworkConfig,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[derive(HasField)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;NetworkConfig {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;listen_port: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u16&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;delegate_components! {
&lt;&#x2F;span&gt;&lt;span&gt;    MyContextComponents {
&lt;&#x2F;span&gt;&lt;span&gt;        ListenPortGetterComponent:
&lt;&#x2F;span&gt;&lt;span&gt;            WithProvider&amp;lt;ChainGetters&amp;lt;Product&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span&gt;[
&lt;&#x2F;span&gt;&lt;span&gt;                UseField&amp;lt;Symbol&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;(&amp;quot;config&amp;quot;)&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;                UseField&amp;lt;Symbol&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;network&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;)&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;                UseField&amp;lt;Symbol&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;listen_port&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;)&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;            ]&amp;gt;&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;improved-cgp-component-macro&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#improved-cgp-component-macro&quot; aria-label=&quot;Anchor link for: improved-cgp-component-macro&quot;&gt;Improved &lt;code&gt;#[cgp_component]&lt;&#x2F;code&gt; Macro&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;We&#x27;ve improved the UX for &lt;code&gt;#[cgp_component]&lt;&#x2F;code&gt; to allow the provider name to be specified directly when there are no other parameters passed. For example, we can now write:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_component(Greeter)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;CanGreet
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;greet(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self);
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;instead of the original form:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_component {
&lt;&#x2F;span&gt;&lt;span&gt;    provider: Greeter,
&lt;&#x2F;span&gt;&lt;span&gt;}]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;CanGreet
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;greet(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self);
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;which in turn is shortened from the fully-expanded form:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_component {
&lt;&#x2F;span&gt;&lt;span&gt;    name: GreeterComponent,
&lt;&#x2F;span&gt;&lt;span&gt;    provider: Greeter,
&lt;&#x2F;span&gt;&lt;span&gt;    context: Context,
&lt;&#x2F;span&gt;&lt;span&gt;}]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;CanGreet
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;greet(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self);
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Other than that, &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;contextgeneric&#x2F;cgp&#x2F;pull&#x2F;95&quot;&gt;#95&lt;&#x2F;a&gt; also brings support for using &lt;code&gt;const&lt;&#x2F;code&gt; items inside CGP traits. With that, we can for example define traits such as:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_component(ConstantGetter)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;HasConstant {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;const &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;CONSTANT&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u64&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;initial-support-for-datatype-generic-programming&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#initial-support-for-datatype-generic-programming&quot; aria-label=&quot;Anchor link for: initial-support-for-datatype-generic-programming&quot;&gt;Initial Support for Datatype-Generic Programming&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;PR &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;contextgeneric&#x2F;cgp&#x2F;pull&#x2F;84&quot;&gt;#84&lt;&#x2F;a&gt; brings initial support for &lt;a href=&quot;https:&#x2F;&#x2F;wiki.haskell.org&#x2F;Generics&quot;&gt;datatype-generic programming&lt;&#x2F;a&gt; to Rust and CGP. A new &lt;code&gt;#[derive(HasFields)]&lt;&#x2F;code&gt; macro has been introduced, together with the relevant traits &lt;code&gt;HasFields&lt;&#x2F;code&gt;, &lt;code&gt;HasFieldsRef&lt;&#x2F;code&gt;, &lt;code&gt;FromFields&lt;&#x2F;code&gt;, &lt;code&gt;ToFields&lt;&#x2F;code&gt;, and &lt;code&gt;ToFieldsRef&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;The introduced constructs make it possible for context-generic providers to access &lt;em&gt;all&lt;&#x2F;em&gt; fields in a context struct or enum without requiring access to the concrete types. This enables context-generic implementations for use cases such as encodings without requiring the concrete context to derive anything other than &lt;code&gt;#[derive(HasFields)]&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;For example, given the following code:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[derive(HasFields)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;Person {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;name: string,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;age: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u8&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The derive macro would generate the following &lt;code&gt;HasField&lt;&#x2F;code&gt; implementation:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;HasFields &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;Person {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Fields &lt;&#x2F;span&gt;&lt;span&gt;=
&lt;&#x2F;span&gt;&lt;span&gt;        Product&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span&gt;[
&lt;&#x2F;span&gt;&lt;span&gt;            Field&amp;lt;Symbol&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;name&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;), String&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;            Field&amp;lt;Symbol&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;age&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;), &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u64&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        ];
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The constructs introduced are currently incomplete, and future development is still needed to bring in the full capabilities for datatype-generic programming.&lt;&#x2F;p&gt;
&lt;p&gt;Additionally, &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;contextgeneric&#x2F;cgp&#x2F;pull&#x2F;85&quot;&gt;#85&lt;&#x2F;a&gt; introduces the use of Greek alphabets to shorten the type representation of field types. For example, given the macro:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;Product&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span&gt;[
&lt;&#x2F;span&gt;&lt;span&gt;    Field&amp;lt;Symbol&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;name&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;), String&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    Field&amp;lt;Symbol&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;age&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;), &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u8&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The original expansion would be shown as follows in the IDE and error messages:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;Cons&amp;lt;Field&amp;lt;Char&amp;lt;&amp;#39;n&amp;#39;, Char&amp;lt;&amp;#39;a&amp;#39;, Char&amp;lt;&amp;#39;m&amp;#39;, Char&amp;lt;&amp;#39;e&amp;#39;, Nil&amp;gt;&amp;gt;&amp;gt;&amp;gt;, String&amp;gt;, Cons&amp;lt;Field&amp;lt;Char&amp;lt;&amp;#39;a&amp;#39;, Char&amp;lt;&amp;#39;g&amp;#39;, Char&amp;lt;&amp;#39;e&amp;#39;, Nil&amp;gt;&amp;gt;&amp;gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u8&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;, Nil&amp;gt;&amp;gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;But with the new version, it would be shown in a shorter form as:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;π&amp;lt;ω&amp;lt;ι&amp;lt;&amp;#39;n&amp;#39;, ι&amp;lt;&amp;#39;a&amp;#39;, ι&amp;lt;&amp;#39;m&amp;#39;, ι&amp;lt;&amp;#39;e&amp;#39;, ε&amp;gt;&amp;gt;&amp;gt;&amp;gt;, String&amp;gt;, π&amp;lt;ω&amp;lt;ι&amp;lt;&amp;#39;a&amp;#39;, ι&amp;lt;&amp;#39;g&amp;#39;, ι&amp;lt;&amp;#39;e&amp;#39;, ε&amp;gt;&amp;gt;&amp;gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u8&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;, ε&amp;gt;&amp;gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Although this may look very confusing at first, hopefully it will become more readable once readers understand how each Greek alphabet is mapped to its full name, offering a more compact representation in IDEs and error messages.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;presets-and-inheritance-a-new-way-to-extend-component-wirings&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#presets-and-inheritance-a-new-way-to-extend-component-wirings&quot; aria-label=&quot;Anchor link for: presets-and-inheritance-a-new-way-to-extend-component-wirings&quot;&gt;Presets and Inheritance: A New Way to Extend Component Wirings&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Another major feature introduced is a completely overhauled implementation of &lt;em&gt;presets&lt;&#x2F;em&gt;, over a number of major PRs. (&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;contextgeneric&#x2F;cgp&#x2F;pull&#x2F;70&quot;&gt;#70&lt;&#x2F;a&gt;, &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;contextgeneric&#x2F;cgp&#x2F;pull&#x2F;71&quot;&gt;#71&lt;&#x2F;a&gt;, &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;contextgeneric&#x2F;cgp&#x2F;pull&#x2F;72&quot;&gt;#72&lt;&#x2F;a&gt;, &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;contextgeneric&#x2F;cgp&#x2F;pull&#x2F;91&quot;&gt;#91&lt;&#x2F;a&gt;)&lt;&#x2F;p&gt;
&lt;p&gt;A proper full introduction to presets will require its own dedicated chapters in the CGP book. But until that&#x27;s written, I&#x27;ll provide a very high-level walk-through of CGP presets here.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;component-delegation-as-type-level-lookup-table&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#component-delegation-as-type-level-lookup-table&quot; aria-label=&quot;Anchor link for: component-delegation-as-type-level-lookup-table&quot;&gt;Component Delegation as Type-Level Lookup Table&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;Conceptually, we can think of the use of &lt;code&gt;delegate_components!&lt;&#x2F;code&gt; being defining a key-value dictionary at the &lt;em&gt;type-level&lt;&#x2F;em&gt;, with the trait &lt;code&gt;DelegateComponent&lt;&#x2F;code&gt; serving as a type-level lookup function. In CGP, when we apply component wirings through &lt;code&gt;delegate_components!&lt;&#x2F;code&gt;, we are effectively building a type-level lookup table with the component name as the key, and the delegated provider as the value.&lt;&#x2F;p&gt;
&lt;p&gt;With that in mind, it becomes natural to think about whether it is possible to &quot;merge&quot; two of such tables to form a new table. For example, given one crate containing:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;delegate_components! {
&lt;&#x2F;span&gt;&lt;span&gt;    ComponentsA {
&lt;&#x2F;span&gt;&lt;span&gt;        KeyA: ValueA,
&lt;&#x2F;span&gt;&lt;span&gt;        KeyB: ValueB,
&lt;&#x2F;span&gt;&lt;span&gt;        KeyC: ValueC1,
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;and another crate containing:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;delegate_components! {
&lt;&#x2F;span&gt;&lt;span&gt;    ComponentsB {
&lt;&#x2F;span&gt;&lt;span&gt;        KeyC: ValueC2,
&lt;&#x2F;span&gt;&lt;span&gt;        KeyD: ValueD,
&lt;&#x2F;span&gt;&lt;span&gt;        KeyE: ValueE,
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;How do we enable the merging of &lt;code&gt;ComponentsA&lt;&#x2F;code&gt; and &lt;code&gt;ComponentsB&lt;&#x2F;code&gt; while also handling conflicting entries? In OOP, this merging operation is commonly known as &lt;em&gt;inheritance&lt;&#x2F;em&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Unfortunately, the coherence restriction of Rust prevents us from implementing such a merging operation using generics and blanket implementations directly. Instead, we&#x27;ve developed macro-based approaches to emulate such merging at the &lt;em&gt;syntactic&lt;&#x2F;em&gt; level. The result is the &lt;em&gt;preset&lt;&#x2F;em&gt; system developed in this update, offering a powerful way to manage and compose component wirings.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;preset-macros&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#preset-macros&quot; aria-label=&quot;Anchor link for: preset-macros&quot;&gt;Preset Macros&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;CGP presets are made of extensible collection of key&#x2F;value mappings, that can be inherited to form new mappings.
Instead of defining regular structs and build mappings with &lt;code&gt;delegate_components!&lt;&#x2F;code&gt;, presets are constructed as &lt;em&gt;modules&lt;&#x2F;em&gt; using the &lt;code&gt;cgp_preset!&lt;&#x2F;code&gt; macro together with the &lt;code&gt;#[re_export_imports]&lt;&#x2F;code&gt;. For example, the same mappings earlier would be rewritten as:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp::re_export_imports]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mod &lt;&#x2F;span&gt;&lt;span&gt;preset {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;crate_a::{KeyA, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...&lt;&#x2F;span&gt;&lt;span&gt;};
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;crate_b::{ValueA, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...&lt;&#x2F;span&gt;&lt;span&gt;};
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    cgp_preset! {
&lt;&#x2F;span&gt;&lt;span&gt;        PresetA {
&lt;&#x2F;span&gt;&lt;span&gt;            KeyA: ValueA,
&lt;&#x2F;span&gt;&lt;span&gt;            KeyB: ValueB,
&lt;&#x2F;span&gt;&lt;span&gt;            KeyC: ValueC1,
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;#[cgp::re_export_imports]&lt;&#x2F;code&gt; macro is used over a surrogate &lt;code&gt;mod preset&lt;&#x2F;code&gt;, which wraps around the inner module to re-export the imports, so that they can be reused during the merging. This is required, because the merging works through macros, which don&#x27;t have access to the actual type information. Aside from that, the macro re-exports all exports from the inner module, so that we can write regular code as if the &lt;code&gt;mod preset&lt;&#x2F;code&gt; modifier never existed.&lt;&#x2F;p&gt;
&lt;p&gt;The macro &lt;code&gt;cgp_preset!&lt;&#x2F;code&gt; works similar to &lt;code&gt;delegate_components!&lt;&#x2F;code&gt;, but it defines a new &lt;em&gt;inner module&lt;&#x2F;em&gt; that contains the mapping struct, together with macros and re-exports to support the merging operation.&lt;&#x2F;p&gt;
&lt;p&gt;Similarly, the second preset would be re-written as:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp::re_export_imports]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mod &lt;&#x2F;span&gt;&lt;span&gt;preset {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;crate_c::{KeyC, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...&lt;&#x2F;span&gt;&lt;span&gt;};
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;crate_d::{ValueD, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...&lt;&#x2F;span&gt;&lt;span&gt;};
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    cgp_preset! {
&lt;&#x2F;span&gt;&lt;span&gt;        PresetB {
&lt;&#x2F;span&gt;&lt;span&gt;            KeyC: ValueC2,
&lt;&#x2F;span&gt;&lt;span&gt;            KeyD: ValueD,
&lt;&#x2F;span&gt;&lt;span&gt;            KeyE: ValueE,
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;To merge the two presets, we can define a new &lt;code&gt;PresetC&lt;&#x2F;code&gt; that &lt;em&gt;inherits&lt;&#x2F;em&gt; from both &lt;code&gt;PresetA&lt;&#x2F;code&gt; and &lt;code&gt;PresetB&lt;&#x2F;code&gt;, like follows:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp::re_export_imports]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mod &lt;&#x2F;span&gt;&lt;span&gt;preset {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;preset_a::PresetA;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;preset_b::PresetB;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;crate_f::{KeyF, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...&lt;&#x2F;span&gt;&lt;span&gt;};
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    cgp_preset! {
&lt;&#x2F;span&gt;&lt;span&gt;        PresetC: PresetA + PresetB {
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;override&lt;&#x2F;span&gt;&lt;span&gt; KeyC: ValueC2,
&lt;&#x2F;span&gt;&lt;span&gt;            KeyF: ValueF,
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;As we can see, CGP supports &lt;em&gt;multiple inheritance&lt;&#x2F;em&gt; for presets by using macros to &quot;copy&quot; over the entries from the parent preset. To resolve conflicts or override entries from the parent presets, the &lt;code&gt;override&lt;&#x2F;code&gt; keyword can be used to exclude a given mapping from being copied over and instead use the local definition. And since the underlying implementation still uses &lt;code&gt;DelegateComponent&lt;&#x2F;code&gt; to implement the lookup, any non-overridden conflicts would simply result in a trait error due to overlapping instances, thus preventing the diamond inheritance dillema.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;single-inheritance-with-context-provider&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#single-inheritance-with-context-provider&quot; aria-label=&quot;Anchor link for: single-inheritance-with-context-provider&quot;&gt;Single Inheritance with Context Provider&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;CGP also supports single inheritance of presets for use with with CGP contexts. For example, the final &lt;code&gt;PresetC&lt;&#x2F;code&gt; can be used in a context by writing:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_context(MyContextComponents: PresetC)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;MyContext {
&lt;&#x2F;span&gt;&lt;span&gt;    ...
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The first optional argument to &lt;code&gt;#[cgp_context]&lt;&#x2F;code&gt; is the name of the new provider struct that is used to implement the wirings for the context. It is then followed by an optional &lt;code&gt;: ParentPreset&lt;&#x2F;code&gt; argument, which would inherit all entries from the parent preset.&lt;&#x2F;p&gt;
&lt;p&gt;Behind the scenes, the single inheritance works through special traits defined in the preset module. As a result, it works with fewer quirks than the macro-based implementation of nested and multiple inheritance between presets. The reason two separate techniques are used is that the trait-based approach can only work with at most one level of inheritance – having a single parent with no further trait-based grandparents.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;comparison-with-oop-inheritance&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#comparison-with-oop-inheritance&quot; aria-label=&quot;Anchor link for: comparison-with-oop-inheritance&quot;&gt;Comparison with OOP Inheritance&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;The preset inheritance works very similarly to how inheritance is typically understood in OOP. However, there are several key differences that distinguish CGP presets from OOP inheritance in Rust.&lt;&#x2F;p&gt;
&lt;p&gt;First, presets only work as type-level lookup tables, with no ability to directly implement &quot;methods&quot; on the preset itself. Hence, it works more like prototypal inheritance in languages such as JavaScript. Furthermore, the lookup table only exists at the type level, meaning it doesn&#x27;t exist at runtime and thus introduces no runtime overhead.&lt;&#x2F;p&gt;
&lt;p&gt;More importantly, CGP and Rust do not support the notion of subtyping. This means that two contexts that &quot;inherit&quot; from the same preset are treated as completely distinct types, and there&#x27;s no mechanism to &quot;upcast&quot; the values to a common preset &quot;parent&quot; type (which doesn&#x27;t exist). This means that in contrast to OOP, CGP preset inheritance only exists on the &quot;provider&quot;-side for implementation re-use, but not on the &quot;consumer&quot;-side for polymorphic consumption.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;async-trait-update&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#async-trait-update&quot; aria-label=&quot;Anchor link for: async-trait-update&quot;&gt;&lt;code&gt;Async&lt;&#x2F;code&gt; Trait Update&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;The &lt;code&gt;Async&lt;&#x2F;code&gt; trait was defined to be a trait alias to &lt;code&gt;Send + Sync + &#x27;static&lt;&#x2F;code&gt;, to make it esier for users to define abstract types that can be used within async functions that return &lt;code&gt;impl Future + Send&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;However, practical experience has shown that the &lt;code&gt;&#x27;static&lt;&#x2F;code&gt; bound isn&#x27;t really needed in most cases, and was thus removed in &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;contextgeneric&#x2F;cgp&#x2F;pull&#x2F;89&quot;&gt;#89&lt;&#x2F;a&gt; from the default recommended trait bound. The removal of &lt;code&gt;&#x27;static&lt;&#x2F;code&gt; will make it easier to instantiate abstract types with concrete types that do not contain &lt;code&gt;&#x27;static&lt;&#x2F;code&gt; lifetimes.&lt;&#x2F;p&gt;
&lt;p&gt;On the other hand, the default inclusion of &lt;code&gt;Send + Sync&lt;&#x2F;code&gt; is almost a necessary evil given the current state of async Rust. However, this may soon change when Return Type Notation (RTN) gets stabilized in Rust in the near future in &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;pull&#x2F;138424&quot;&gt;rust#138424&lt;&#x2F;a&gt;. Once that is stabilized, the &lt;code&gt;Async&lt;&#x2F;code&gt; trait itself can entirely be deprecated or removed.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;blanket-trait-macro&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#blanket-trait-macro&quot; aria-label=&quot;Anchor link for: blanket-trait-macro&quot;&gt;&lt;code&gt;#[blanket_trait]&lt;&#x2F;code&gt; Macro&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;contextgeneric&#x2F;cgp&#x2F;pull&#x2F;79&quot;&gt;#79&lt;&#x2F;a&gt; and &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;contextgeneric&#x2F;cgp&#x2F;pull&#x2F;82&quot;&gt;#82&lt;&#x2F;a&gt; introduces a new &lt;code&gt;#[blanket_trait]&lt;&#x2F;code&gt; macro, which can be used to define trait aliases that contain empty body and trivial blanket implementations. Developers can use the &lt;code&gt;#[blanket_trait]&lt;&#x2F;code&gt; macro to define trait aliases, as well as abstract type aliases for more advanced cases.&lt;&#x2F;p&gt;
&lt;p&gt;For example, given the following:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[trait_alias]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;HasAsyncErrorType: Async + HasErrorType&amp;lt;Error: Async&amp;gt; {}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;automatically generates the following blanket implementation:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;Context&amp;gt; HasAsyncErrorType &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;Context
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;    Context: Async + HasErrorType&amp;lt;Error: Async&amp;gt; {}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;personal-updates&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#personal-updates&quot; aria-label=&quot;Anchor link for: personal-updates&quot;&gt;Personal Updates&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Aside from all the feature updates, I also have some personal updates related to the development of CGP.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;persentation-at-leipzig-rust-meetup&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#persentation-at-leipzig-rust-meetup&quot; aria-label=&quot;Anchor link for: persentation-at-leipzig-rust-meetup&quot;&gt;Persentation at Leipzig Rust Meetup&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;I gave a presentation of CGP at the &lt;a href=&quot;https:&#x2F;&#x2F;www.meetup.com&#x2F;rust-modern-systems-programming-in-leipzig&#x2F;events&#x2F;303729528&#x2F;&quot;&gt;Leipzig Rust meetup&lt;&#x2F;a&gt; in February. Although there were no video recording, you can check out the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;contextgeneric&#x2F;cgp-presentations&#x2F;blob&#x2F;main&#x2F;2025&#x2F;cgp-leipzig-2025-02-18.pdf&quot;&gt;presentation slides&lt;&#x2F;a&gt; if you are interested.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;bank-transfer-example&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#bank-transfer-example&quot; aria-label=&quot;Anchor link for: bank-transfer-example&quot;&gt;Bank Transfer Example&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;Along with the meetup presentation, an example &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;contextgeneric&#x2F;cgp-examples&#x2F;tree&#x2F;main&#x2F;transfer&quot;&gt;bank transfer&lt;&#x2F;a&gt; application has been drafted to demonstrate the use of CGP in practical applications. The example code is not yet sufficiently documented, but hopefully it can serve as a sneak preview for readers who would like to see more complex examples of CGP programs.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;more-active-development-ahead&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#more-active-development-ahead&quot; aria-label=&quot;Anchor link for: more-active-development-ahead&quot;&gt;More Active Development Ahead&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;It has been 4 months since our last update. It&#x27;s been challenging to manage a side project while juggling a full-time job and childcare without support from grandparents. On the bright side, I have managed to get a short 3-month sabbatical from May to July before starting a new job.&lt;&#x2F;p&gt;
&lt;p&gt;This means you can expect to see much more active development from me during the next 3 months as I push CGP towards wider adoption. If you have suggestions on what should be developed during this time, or how I can make the project more sustainable, please let me know in the comments! Your feedback is invaluable.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;attending-rustweek&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#attending-rustweek&quot; aria-label=&quot;Anchor link for: attending-rustweek&quot;&gt;Attending RustWeek&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;I will be attending &lt;a href=&quot;https:&#x2F;&#x2F;rustweek.org&#x2F;&quot;&gt;RustWeek&lt;&#x2F;a&gt; in person next week (May 13-17 2025). Although I did not manage to get a presentation slot, I would love to meet up with Rust developers and discuss how CGP can be used to help solve real world problem in their Rust applications.&lt;&#x2F;p&gt;
&lt;p&gt;If there&#x27;s interest, I&#x27; woul&#x27;d also like to organize &lt;a href=&quot;https:&#x2F;&#x2F;rustweek.org&#x2F;events&#x2F;hackathon&#x2F;&quot;&gt;Hackathon&lt;&#x2F;a&gt; sessions during the last day to have coding sessions for CGP. Otherwise, I might look around and try to apply CGP on one of the Hackathon projects. If you are interested to attend or suggest any activities, do &lt;a href=&quot;https:&#x2F;&#x2F;docs.google.com&#x2F;spreadsheets&#x2F;d&#x2F;1hT_nYY0yjTCBH3exl6BhW-Se3T_0ASPXXENxs-je19I&#x2F;edit&quot;&gt;sign up here&lt;&#x2F;a&gt; or ping me on &lt;a href=&quot;https:&#x2F;&#x2F;bsky.app&#x2F;profile&#x2F;maybevoid.com&quot;&gt;BlueSky&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Thank you for reading, and stay tuned for more updates on CGP!&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>CGP Updates: v0.3.0 Release and New Chapters</title>
        <published>2025-01-09T00:00:00+00:00</published>
        <updated>2025-01-09T00:00:00+00:00</updated>
        
        <author>
          <name>
            Soares Chen
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://www.contextgeneric.dev/blog/v0-3-0-release/"/>
        <id>https://www.contextgeneric.dev/blog/v0-3-0-release/</id>
        
        <content type="html" xml:base="https://www.contextgeneric.dev/blog/v0-3-0-release/">&lt;h1 id=&quot;summary&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#summary&quot; aria-label=&quot;Anchor link for: summary&quot;&gt;Summary&lt;&#x2F;a&gt;&lt;&#x2F;h1&gt;
&lt;p&gt;I&#x27;m excited to announce the release of &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;contextgeneric&#x2F;cgp&#x2F;releases&#x2F;tag&#x2F;v0.3.0&quot;&gt;v0.3.0&lt;&#x2F;a&gt; of the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;cgp&#x2F;0.3.0&#x2F;cgp&#x2F;&quot;&gt;&lt;code&gt;cgp&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; crate, along with several &lt;a href=&quot;https:&#x2F;&#x2F;patterns.contextgeneric.dev&#x2F;error-handling.html&quot;&gt;new&lt;&#x2F;a&gt; &lt;a href=&quot;https:&#x2F;&#x2F;patterns.contextgeneric.dev&#x2F;field-accessors.html&quot;&gt;chapters&lt;&#x2F;a&gt; of the &lt;a href=&quot;https:&#x2F;&#x2F;patterns.contextgeneric.dev&#x2F;&quot;&gt;CGP Patterns&lt;&#x2F;a&gt; book! This post highlights some of the key features and updates included in this release.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;new-book-chapters&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#new-book-chapters&quot; aria-label=&quot;Anchor link for: new-book-chapters&quot;&gt;New Book Chapters&lt;&#x2F;a&gt;&lt;&#x2F;h1&gt;
&lt;p&gt;We’ve added a few new chapters to the &lt;a href=&quot;https:&#x2F;&#x2F;patterns.contextgeneric.dev&#x2F;&quot;&gt;CGP Patterns&lt;&#x2F;a&gt; book. Below is a brief summary of the newly published content.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;associated-types&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#associated-types&quot; aria-label=&quot;Anchor link for: associated-types&quot;&gt;Associated Types&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;In the &lt;a href=&quot;&#x2F;blog&#x2F;early-preview-announcement&#x2F;&quot;&gt;launch announcement&lt;&#x2F;a&gt; for CGP, some readers remarked that CGP seemed to be primarily a dependency injection framework in Rust. While this observation captured part of its functionality, a key feature not yet covered was CGP&#x27;s ability to use &lt;em&gt;abstract types&lt;&#x2F;em&gt; in conjunction with the dependency injection of &lt;em&gt;types&lt;&#x2F;em&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;In the &lt;a href=&quot;https:&#x2F;&#x2F;patterns.contextgeneric.dev&#x2F;associated-types.html&quot;&gt;new chapter&lt;&#x2F;a&gt; of the book, we explore this powerful feature with a motivating example: implementing a context-generic authentication token validator that is not only generic over the &lt;code&gt;Context&lt;&#x2F;code&gt; but also over abstract &lt;code&gt;Time&lt;&#x2F;code&gt; and &lt;code&gt;AuthToken&lt;&#x2F;code&gt; types. The chapter also demonstrates how to use the &lt;code&gt;cgp_type!&lt;&#x2F;code&gt; macro to streamline the declaration of abstract type traits and how to employ &lt;code&gt;UseType&lt;&#x2F;code&gt; in component wiring to instantiate abstract types.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;error-handling&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#error-handling&quot; aria-label=&quot;Anchor link for: error-handling&quot;&gt;Error Handling&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;CGP introduces a novel approach to error handling that differs significantly from the conventional patterns used in Rust today. In the &lt;a href=&quot;https:&#x2F;&#x2F;patterns.contextgeneric.dev&#x2F;error-handling.html&quot;&gt;new chapter&lt;&#x2F;a&gt; of the book, we begin by leveraging an abstract &lt;code&gt;Error&lt;&#x2F;code&gt; type from &lt;code&gt;HasErrorType&lt;&#x2F;code&gt; to define error-returning method signatures. The chapter then delves into how &lt;code&gt;CanRaiseError&lt;&#x2F;code&gt; and &lt;code&gt;CanWrapError&lt;&#x2F;code&gt; can be used to produce abstract errors within context-generic provider implementations. Further, the chapter discusses how to define context-generic error raisers and leverage the &lt;code&gt;UseDelegate&lt;&#x2F;code&gt; pattern for static dispatching of error handling to various providers.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;field-accessors&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#field-accessors&quot; aria-label=&quot;Anchor link for: field-accessors&quot;&gt;Field Accessors&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;CGP provides a robust mechanism for dependency injection using &lt;a href=&quot;https:&#x2F;&#x2F;patterns.contextgeneric.dev&#x2F;impl-side-dependencies.html&quot;&gt;impl-side dependencies&lt;&#x2F;a&gt;. However, since these dependencies are expressed through traits and constraints, we need to define &lt;em&gt;accessor traits&lt;&#x2F;em&gt; to retrieve field values from a generic context.&lt;&#x2F;p&gt;
&lt;p&gt;In the &lt;a href=&quot;https:&#x2F;&#x2F;patterns.contextgeneric.dev&#x2F;field-accessors.html&quot;&gt;new chapter&lt;&#x2F;a&gt;, we explore different approaches for defining, using, and implementing accessor traits in CGP. This chapter explains how the &lt;code&gt;#[derive(HasField)]&lt;&#x2F;code&gt; macro operates and dives into the internal workings of &lt;code&gt;HasField&lt;&#x2F;code&gt; and &lt;code&gt;Symbol!&lt;&#x2F;code&gt;. It also introduces the&lt;code&gt; #[cgp_auto_getter]&lt;&#x2F;code&gt; and &lt;code&gt;#[cgp_getter]&lt;&#x2F;code&gt; macros, which automatically generate accessor provider implementations that work with &lt;code&gt;HasField&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;cgp-v0-3-0-release&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#cgp-v0-3-0-release&quot; aria-label=&quot;Anchor link for: cgp-v0-3-0-release&quot;&gt;&lt;code&gt;cgp&lt;&#x2F;code&gt; v0.3.0 Release&lt;&#x2F;a&gt;&lt;&#x2F;h1&gt;
&lt;p&gt;The &lt;code&gt;cgp&lt;&#x2F;code&gt; crate has been upgraded from &lt;code&gt;v0.2.0&lt;&#x2F;code&gt; to &lt;code&gt;v0.3.0&lt;&#x2F;code&gt;, introducing new features that significantly enhance usability and include minor breaking changes. You can view the full &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;contextgeneric&#x2F;cgp&#x2F;releases&#x2F;tag&#x2F;v0.3.0&quot;&gt;release notes here&lt;&#x2F;a&gt;. Additionally, the &lt;a href=&quot;&#x2F;#hello-world-example&quot;&gt;Hello World example&lt;&#x2F;a&gt; on the project homepage has been updated to showcase a simplified implementation using the latest CGP constructs.&lt;&#x2F;p&gt;
&lt;p&gt;Below is a summary of key updates in this release.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;cgp-type-macro&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#cgp-type-macro&quot; aria-label=&quot;Anchor link for: cgp-type-macro&quot;&gt;&lt;code&gt;cgp_type!&lt;&#x2F;code&gt; Macro&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;The new &lt;code&gt;cgp_type!&lt;&#x2F;code&gt; macro streamlines the process of declaring abstract type traits, enabling you to define them in a single line of code. For instance, the &lt;code&gt;HasErrorType&lt;&#x2F;code&gt; trait in &lt;code&gt;cgp&lt;&#x2F;code&gt; is now defined as:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;cgp_type!( Error: Debug );
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;cgp_type!&lt;&#x2F;code&gt; macro expands this short declaration into the following:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_component {
&lt;&#x2F;span&gt;&lt;span&gt;    name: ErrorTypeComponent,
&lt;&#x2F;span&gt;&lt;span&gt;    provider: ProvideErrorType,
&lt;&#x2F;span&gt;&lt;span&gt;}]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;HasErrorType {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Error&lt;&#x2F;span&gt;&lt;span&gt;: Debug;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;Context, Error&amp;gt; ProvideErrorType&amp;lt;Context&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;UseType&amp;lt;Error&amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;    Error: Debug,
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Error &lt;&#x2F;span&gt;&lt;span&gt;= Error;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;For a detailed explanation of cgp_type! and its usage, check out the new &lt;a href=&quot;https:&#x2F;&#x2F;patterns.contextgeneric.dev&#x2F;associated-types.html#defining-abstract-type-traits-with-cgp_type&quot;&gt;Associated Types&lt;&#x2F;a&gt; chapter in the CGP Patterns book.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;cgp-auto-getter-macro&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#cgp-auto-getter-macro&quot; aria-label=&quot;Anchor link for: cgp-auto-getter-macro&quot;&gt;&lt;code&gt;#[cgp_auto_getter]&lt;&#x2F;code&gt; Macro&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;The &lt;code&gt;#[cgp_auto_getter]&lt;&#x2F;code&gt; macro simplifies the process of defining accessor traits with blanket implementations based on &lt;code&gt;HasField&lt;&#x2F;code&gt;. When a trait is marked with &lt;code&gt;#[cgp_auto_getter]&lt;&#x2F;code&gt;, any context deriving &lt;code&gt;HasField&lt;&#x2F;code&gt; that has the required fields and types will automatically implement the specified trait without additional boilerplate.&lt;&#x2F;p&gt;
&lt;p&gt;Here’s an example illustrating how it works:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;cgp::prelude::*;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[cgp_auto_getter]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;HasName {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;name(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;String;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[derive(HasField)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;Person {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;name: String,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;main() {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; person = Person {
&lt;&#x2F;span&gt;&lt;span&gt;        name: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Alice&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;.into(),
&lt;&#x2F;span&gt;&lt;span&gt;    };
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Hello, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, person.name());
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In this example, the &lt;code&gt;Person&lt;&#x2F;code&gt; struct derives the &lt;code&gt;HasField&lt;&#x2F;code&gt; trait, which automatically implements the &lt;code&gt;HasName&lt;&#x2F;code&gt; trait without any additional code. This means that an accessor trait like &lt;code&gt;HasName&lt;&#x2F;code&gt; can be defined in separate crates or modules, and it will still be automatically implemented for all structs that derive &lt;code&gt;HasField&lt;&#x2F;code&gt; with the necessary fields.&lt;&#x2F;p&gt;
&lt;p&gt;For more details on &lt;code&gt;#[cgp_auto_getter]&lt;&#x2F;code&gt;, refer to the &lt;a href=&quot;https:&#x2F;&#x2F;patterns.contextgeneric.dev&#x2F;generic-accessor-providers.html#the-cgp_auto_getter-macro&quot;&gt;Generic Accessor Providers&lt;&#x2F;a&gt; chapter in the CGP Patterns book.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;cgp-getter-macro&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#cgp-getter-macro&quot; aria-label=&quot;Anchor link for: cgp-getter-macro&quot;&gt;&lt;code&gt;#[cgp_getter]&lt;&#x2F;code&gt; Macro&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;The &lt;code&gt;#[cgp_getter]&lt;&#x2F;code&gt; macro, like &lt;code&gt;#[cgp_auto_getter]&lt;&#x2F;code&gt;, generates blanket implementations that make use of &lt;code&gt;HasField&lt;&#x2F;code&gt;. However, &lt;code&gt;#[cgp_getter]&lt;&#x2F;code&gt; extends functionality by also creating full CGP constructs for the trait, similar to &lt;code&gt;#[cgp_component]&lt;&#x2F;code&gt;. This requires explicit wiring in the context using &lt;code&gt;delegate_components!&lt;&#x2F;code&gt;. Additionally, &lt;code&gt;#[cgp_getter]&lt;&#x2F;code&gt; derives a blanket implementation for the &lt;code&gt;UseFields&lt;&#x2F;code&gt; provider, so that it can be used inside the component wiring as follows:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;cgp::prelude::*;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[cgp_getter {
&lt;&#x2F;span&gt;&lt;span&gt;    provider: NameGetter,
&lt;&#x2F;span&gt;&lt;span&gt;}]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;HasName {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;name(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;String;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[derive(HasField)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;Person {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;name: String,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;PersonComponents;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;HasComponents &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;Person {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Components &lt;&#x2F;span&gt;&lt;span&gt;= PersonComponents;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;delegate_components! {
&lt;&#x2F;span&gt;&lt;span&gt;    PersonComponents {
&lt;&#x2F;span&gt;&lt;span&gt;        NameGetterComponent: UseFields,
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;main() {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; person = Person {
&lt;&#x2F;span&gt;&lt;span&gt;        name: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Alice&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;.into(),
&lt;&#x2F;span&gt;&lt;span&gt;    };
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Hello, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, person.name());
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;For additional information on &lt;code&gt;#[cgp_getter]&lt;&#x2F;code&gt;, refer to the &lt;a href=&quot;https:&#x2F;&#x2F;patterns.contextgeneric.dev&#x2F;generic-accessor-providers.html#the-cgp_getter-macro&quot;&gt;Generic Accessor Providers&lt;&#x2F;a&gt; chapter of the CGP Patterns book.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;canwraperror-trait&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#canwraperror-trait&quot; aria-label=&quot;Anchor link for: canwraperror-trait&quot;&gt;&lt;code&gt;CanWrapError&lt;&#x2F;code&gt; Trait&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;The &lt;code&gt;CanWrapError&lt;&#x2F;code&gt; trait has been introduced to streamline the process of wrapping existing errors. Its definition is as follows:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cgp_component {
&lt;&#x2F;span&gt;&lt;span&gt;    provider: ErrorWrapper,
&lt;&#x2F;span&gt;&lt;span&gt;}]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;CanWrapError&amp;lt;Detail&amp;gt;: HasErrorType {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;wrap_error(error: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;Error, detail: Detail) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;Error;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Previously, error wrapping relied on using &lt;code&gt;CanRaiseError&lt;&#x2F;code&gt; with a tuple, such as &lt;code&gt;CanRaiseError&amp;lt;(Self::Error, Detail)&amp;gt;&lt;&#x2F;code&gt;. However, this approach was cumbersome and less intuitive. The &lt;code&gt;CanWrapError&lt;&#x2F;code&gt; trait addresses this issue by providing a cleaner and more straightforward way to raise wrapped errors.&lt;&#x2F;p&gt;
&lt;p&gt;For more details about the usage of &lt;code&gt;CanWrapError&lt;&#x2F;code&gt;, refer to the &lt;a href=&quot;https:&#x2F;&#x2F;patterns.contextgeneric.dev&#x2F;error-wrapping.html&quot;&gt;Error Wrapping&lt;&#x2F;a&gt; chapter in the CGP Patterns book.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;cgp-error-anyhow-crate&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#cgp-error-anyhow-crate&quot; aria-label=&quot;Anchor link for: cgp-error-anyhow-crate&quot;&gt;&lt;code&gt;cgp-error-anyhow&lt;&#x2F;code&gt; Crate&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;We have published a new &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;cgp-error-anyhow&#x2F;0.3.0&#x2F;cgp_error_anyhow&#x2F;index.html&quot;&gt;&lt;code&gt;cgp-error-anyhow&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; crate, which provides context-generic error raisers for &lt;code&gt;anyhow::Error&lt;&#x2F;code&gt;. This addition complements the previously published &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;cgp-error-eyre&#x2F;0.3.0&#x2F;cgp_error_eyre&#x2F;index.html&quot;&gt;&lt;code&gt;cgp-error-eyre&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; and &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;cgp-error-std&#x2F;0.3.0&#x2F;cgp_error_std&#x2F;index.html&quot;&gt;&lt;code&gt;cgp-error-std&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; crates, which support CGP error handling with &lt;code&gt;eyre::Error&lt;&#x2F;code&gt; and &lt;code&gt;Box&amp;lt;dyn core::error::Error + Send + Sync + &#x27;static&amp;gt;&lt;&#x2F;code&gt;. Given the popularity of &lt;code&gt;anyhow::Error&lt;&#x2F;code&gt;, this crate extends support for its usage.&lt;&#x2F;p&gt;
&lt;p&gt;Details on using &lt;code&gt;cgp-error-anyhow&lt;&#x2F;code&gt; for error handling can be found in the &lt;a href=&quot;https:&#x2F;&#x2F;patterns.contextgeneric.dev&#x2F;error-handling.html#the-cgp-error-anyhow-crate&quot;&gt;Error Handling&lt;&#x2F;a&gt; chapter of the CGP Patterns book.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;cgp-runtime-crate&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#cgp-runtime-crate&quot; aria-label=&quot;Anchor link for: cgp-runtime-crate&quot;&gt;&lt;code&gt;cgp-runtime&lt;&#x2F;code&gt; Crate&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;The new &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;cgp-runtime&#x2F;0.3.0&#x2F;cgp_runtime&#x2F;index.html&quot;&gt;&lt;code&gt;cgp-runtime&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; crate introduces standardized interfaces for runtimes, paving the way for future discussions on asynchronous programming in the CGP Patterns book.&lt;&#x2F;p&gt;
&lt;p&gt;The constructs provided by &lt;code&gt;cgp-runtime&lt;&#x2F;code&gt;, which are re-exported by &lt;code&gt;cgp&lt;&#x2F;code&gt;, include:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;cgp_type!( Runtime );
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[cgp_getter {
&lt;&#x2F;span&gt;&lt;span&gt;    provider: RuntimeGetter,
&lt;&#x2F;span&gt;&lt;span&gt;}]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;HasRuntime: HasRuntimeType {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;runtime(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;Self::&lt;&#x2F;span&gt;&lt;span&gt;Runtime;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Stay tuned for updates to the CGP Patterns book for more information on using pluggable async runtimes with CGP.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;future-work&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#future-work&quot; aria-label=&quot;Anchor link for: future-work&quot;&gt;Future Work&lt;&#x2F;a&gt;&lt;&#x2F;h1&gt;
&lt;p&gt;There are several additional features and improvements I had hoped to include in this update. However, with my New Year vacation coming to an end, I need to wrap up the current progress. Below are some of the tasks deferred to future updates.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;documenting-the-cgp-crate&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#documenting-the-cgp-crate&quot; aria-label=&quot;Anchor link for: documenting-the-cgp-crate&quot;&gt;Documenting the &lt;code&gt;cgp&lt;&#x2F;code&gt; Crate&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;While the CGP Patterns book offers extensive conceptual coverage, the &lt;code&gt;cgp&lt;&#x2F;code&gt; crate currently lacks comprehensive Rustdoc documentation. Many constructs remain undocumented, and users must rely on the CGP Patterns book or this website for detailed guidance.&lt;&#x2F;p&gt;
&lt;p&gt;In future updates, I plan to add concise Rustdoc comments to these constructs and include links to relevant chapters in the CGP Patterns book. This will help bridge the gap and provide in-crate documentation to enhance usability. For now, all detailed information about CGP is accessible only through the book and website.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;tutorials-with-more-complex-use-cases&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#tutorials-with-more-complex-use-cases&quot; aria-label=&quot;Anchor link for: tutorials-with-more-complex-use-cases&quot;&gt;Tutorials with More Complex Use Cases&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;During the &lt;a href=&quot;&#x2F;blog&#x2F;early-preview-announcement&#x2F;&quot;&gt;launch announcement&lt;&#x2F;a&gt;, many readers noted the lack of practical examples demonstrating how CGP can address more complex, real-world problems. While I had planned to create such tutorials, much of my time was spent completing relevant chapters and updating the &lt;code&gt;cgp&lt;&#x2F;code&gt; crate. I ask for your patience as I work on delivering concise, compelling examples to better illustrate CGP&#x27;s utility.&lt;&#x2F;p&gt;
&lt;p&gt;In the meantime, the simplified examples in the recently added &lt;a href=&quot;https:&#x2F;&#x2F;patterns.contextgeneric.dev&#x2F;associated-types.html&quot;&gt;Associated Types&lt;&#x2F;a&gt;, &lt;a href=&quot;https:&#x2F;&#x2F;patterns.contextgeneric.dev&#x2F;error-handling.html&quot;&gt;Error Handling&lt;&#x2F;a&gt;, and &lt;a href=&quot;https:&#x2F;&#x2F;patterns.contextgeneric.dev&#x2F;field-accessors.html&quot;&gt;Field Accessors&lt;&#x2F;a&gt; chapters provide a glimpse into CGP&#x27;s practical applications. These include examples like validating whether an authentication token has expired and making HTTP API calls to fetch messages. While not exhaustive, these examples go beyond the basic &quot;Hello World&quot; tutorial on the homepage and offer a clearer picture of how CGP can be applied to your projects.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;acknowledgement&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#acknowledgement&quot; aria-label=&quot;Anchor link for: acknowledgement&quot;&gt;Acknowledgement&lt;&#x2F;a&gt;&lt;&#x2F;h1&gt;
&lt;p&gt;A big thank you to &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;marvin-hansen&quot;&gt;@marvin-hansen&lt;&#x2F;a&gt; for his enthusiastic involvement in discussions, testing CGP with real-world projects, and providing invaluable feedback! The implementation of the &lt;code&gt;#[cgp_getter]&lt;&#x2F;code&gt; and &lt;code&gt;#[cgp_auto_getter]&lt;&#x2F;code&gt; macros was primarily motivated by his input, highlighting that the direct use of &lt;code&gt;HasField&lt;&#x2F;code&gt; could be too complex for beginners. Thanks to his suggestions, CGP now offers a more seamless and intuitive experience for declaring and using field accessor traits.&lt;&#x2F;p&gt;
&lt;p&gt;Thanks also to everyone who contributed feedback to the launch announcement on &lt;a href=&quot;https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;rust&#x2F;comments&#x2F;1hkzaiu&#x2F;announcing_contextgeneric_programming_a_new&#x2F;&quot;&gt;Reddit&lt;&#x2F;a&gt; and &lt;a href=&quot;https:&#x2F;&#x2F;lobste.rs&#x2F;s&#x2F;a5wfid&#x2F;context_generic_programming&quot;&gt;Lobsters&lt;&#x2F;a&gt;! Your insights have been incredibly helpful in shaping the direction of CGP and prioritizing upcoming work. There’s still a long journey ahead before CGP reaches v1.0 and is ready for widespread use, and I appreciate your continued support as we work toward that goal!&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>Announcing Context-Generic Programming (Early Preview)</title>
        <published>2024-12-19T00:00:00+00:00</published>
        <updated>2024-12-19T00:00:00+00:00</updated>
        
        <author>
          <name>
            Soares Chen
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://www.contextgeneric.dev/blog/early-preview-announcement/"/>
        <id>https://www.contextgeneric.dev/blog/early-preview-announcement/</id>
        
        <content type="html" xml:base="https://www.contextgeneric.dev/blog/early-preview-announcement/">&lt;h1 id=&quot;the-beginning-of-a-new-paradigm&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-beginning-of-a-new-paradigm&quot; aria-label=&quot;Anchor link for: the-beginning-of-a-new-paradigm&quot;&gt;The Beginning of a New Paradigm&lt;&#x2F;a&gt;&lt;&#x2F;h1&gt;
&lt;p&gt;Welcome everyone! This blog post marks the launch of the &lt;em&gt;context-generic programming&lt;&#x2F;em&gt; (CGP) project,
to introduce a new modular programming paradigm for Rust.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;a-quick-overview-of-context-generic-programming&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#a-quick-overview-of-context-generic-programming&quot; aria-label=&quot;Anchor link for: a-quick-overview-of-context-generic-programming&quot;&gt;A Quick Overview of Context-Generic Programming&lt;&#x2F;a&gt;&lt;&#x2F;h1&gt;
&lt;p&gt;As its name implied, CGP makes it possible to write &lt;em&gt;context-generic&lt;&#x2F;em&gt; programs that can work
with any context type in Rust, i.e. the type that we typically refer to as &lt;code&gt;Self&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Compared to regular generic programming, CGP supercharges how we can write generic programs,
by lifting many restrictions imposed by Rust and its trait system. CGP alleviates the needs
to explicitly specify all generic parameters by position, and allows them to be referenced
similar to named parameters. CGP also makes it possible to specify overlapping and orphaned
trait instances, by introducing &lt;em&gt;provider traits&lt;&#x2F;em&gt; replace any reference to &lt;code&gt;Self&lt;&#x2F;code&gt; with
an explicit &lt;code&gt;Context&lt;&#x2F;code&gt; generic type.&lt;&#x2F;p&gt;
&lt;p&gt;Compared to object-oriented programming (OOP), CGP makes it possible to write Rust programs
following popular OOP patterns, such as inheritance and mixins, but in better ways that
fit Rust&#x27;s type system. With CGP, one can write highly expressive programs that may look similar
to dynamic-typed programs, while ensuring that the programs remain type-safe at compile time,
without any sacrifice to runtime performance.&lt;&#x2F;p&gt;
&lt;p&gt;As a new programming paradigm, CGP significantly changes how Rust programs can be written.
Because of this, CGP programs may look very different from regular Rust programs, and appear
intimidating to even experienced Rust programmers. CGP introduces new programming concepts
in the form of Rust macros, which makes it not as elegant as it could have been if we were
to introduce them as native language constructs in Rust, or with a whole new programming language.
Hence, we can think of the current form of CGP as an &lt;em&gt;experimentation&lt;&#x2F;em&gt; for introducing new
language concepts into Rust, or for programming languages in the future.&lt;&#x2F;p&gt;
&lt;p&gt;It would take too much space of this blog post to give a full picture of how CGP works.
That would require dedication of an entire website, and several books to cover the entirety of CGP.
If you are new here, you should check out the &lt;a href=&quot;&#x2F;&quot;&gt;CGP homepage&lt;&#x2F;a&gt; for a proper introduction of CGP.
Instead of rehearsing the full introduction, this blog post will cover some background about the
project, the current status, and what to expect from here on.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;how-it-all-started&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#how-it-all-started&quot; aria-label=&quot;Anchor link for: how-it-all-started&quot;&gt;How It All Started&lt;&#x2F;a&gt;&lt;&#x2F;h1&gt;
&lt;p&gt;My name is &lt;a href=&quot;https:&#x2F;&#x2F;maybevoid.com&#x2F;soareschen&quot;&gt;Soares Chen&lt;&#x2F;a&gt;, a.k.a. &lt;a href=&quot;https:&#x2F;&#x2F;maybevoid.com&quot;&gt;MaybeVoid&lt;&#x2F;a&gt;,
and I am the creator of CGP. Even though this project is still new to the public, it has been ongoing
for a while. The work for CGP first started at around July 2022, when I was working on the
&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;informalsystems&#x2F;hermes&quot;&gt;Hermes IBC Relayer&lt;&#x2F;a&gt; at &lt;a href=&quot;https:&#x2F;&#x2F;informal.systems&#x2F;&quot;&gt;Informal Systems&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;I started developing the techniques used in CGP to help writing large-scale generic applications in Rust.
At that time, the generic code in our code base all share a large monolithic trait called
&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;informalsystems&#x2F;hermes&#x2F;blob&#x2F;master&#x2F;crates&#x2F;relayer&#x2F;src&#x2F;chain&#x2F;handle.rs#L398&quot;&gt;&lt;code&gt;ChainHandle&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;,
which contains dozens of methods that are hard to implement and also difficult to evolve. I then started
experimenting on using Rust traits with blanket implementations as a form of &lt;em&gt;dependency injection&lt;&#x2F;em&gt; to
hide the constraints used on the implementation side. This way, a generic code can require the minimal
subset of dependencies that it needs, and can be reused by implementations that provide only the given subset
of dependencies.&lt;&#x2F;p&gt;
&lt;p&gt;As time goes on, I developed more and more design patterns to help further modularize the code,
which collectively form the basis for CGP. The work I done on Hermes also slowly gets decoupled
from the main code base, eventually becoming its own project called
&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;informalsystems&#x2F;hermes-sdk&quot;&gt;Hermes SDK&lt;&#x2F;a&gt;. If you compare both codebases,
you may notice that the way context-generic programs are written in Hermes SDK is almost completely
different than the original Hermes, even though both implement the same functionality.
Compared to the original version, we are able to extend and customize Hermes SDK much more easily
to support projects with different very requirements, including host environments, APIs, encodings,
cryptographic primitives, protocols, concurrency strategy, and many more.&lt;&#x2F;p&gt;
&lt;p&gt;But even before my work at Informal Systems, I have spent over 20 years of my programming journey
experimenting on various design patterns to enable modular programming. My previous projects include
the implementation of a &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;quiverjs&#x2F;quiverjs&quot;&gt;dynamic-typed component system in JavaScript&lt;&#x2F;a&gt;,
and an extensible
&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;maybevoid&#x2F;casimir&quot;&gt;algebraic effects library in Haskell using implicit parameters&lt;&#x2F;a&gt;.
Compared to my previous attempts, I am hopeful that Rust serves as a sweetspot to be a host
programming language for modular design patterns, thanks to its advanced type systems as well as
its rapidly expanding ecosystem.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;current-status&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#current-status&quot; aria-label=&quot;Anchor link for: current-status&quot;&gt;Current Status&lt;&#x2F;a&gt;&lt;&#x2F;h1&gt;
&lt;p&gt;This blog post serves as an early preview announcement, and kickstarts many efforts that are
still needed before we can be ready for a full release.
Previously, I have demonstrated the technical feasibility of various CGP programming techniques in
Hermes SDK.
In this new phase, I will start adding documentation and learning resources to help spread the
knowledge of CGP.&lt;&#x2F;p&gt;
&lt;p&gt;For starter, I have created the &lt;a href=&quot;https:&#x2F;&#x2F;contextgeneric.dev&quot;&gt;project website&lt;&#x2F;a&gt;
and finished the first section of my &lt;a href=&quot;https:&#x2F;&#x2F;patterns.contextgeneric.dev&quot;&gt;first book on CGP&lt;&#x2F;a&gt;.
However, there are still a lot more work needed before I can make CGP accessible enough
to the mainstream programming community. Nevertheless, I would like to make use of this
early announcement to start building an early adopter community to help me continue
growing CGP.&lt;&#x2F;p&gt;
&lt;p&gt;Depending on my time availability, it may take a year or more before I am ready for an official release
of CGP. But in the meanwhile, I will start posting regular updates on my development process,
which may be of interest for some of you reading this blog post.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;plans-for-2025&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#plans-for-2025&quot; aria-label=&quot;Anchor link for: plans-for-2025&quot;&gt;Plans for 2025&lt;&#x2F;a&gt;&lt;&#x2F;h1&gt;
&lt;p&gt;In the upcoming new year 2025, I have many plans laid out to prepare for an official release of
CGP. This section is less about making promises, but more about making you aware of how much work
is still needed before you should consider using CGP seriously.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;finish-the-cgp-book&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#finish-the-cgp-book&quot; aria-label=&quot;Anchor link for: finish-the-cgp-book&quot;&gt;Finish the CGP Book&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;The most important goal I have for CGP is to finish writing my first book,
&lt;a href=&quot;https:&#x2F;&#x2F;patterns.contextgeneric.dev&quot;&gt;Context-Generic Programming Patterns&lt;&#x2F;a&gt;.
This book will serve as the minimal knowledge transfer for anyone to fully understand CGP.
My hope is that the book will help reduce the bus factor of CGP, so that even if I became
unavailable to continue working on CGP, someone could still use the book as a basis
to continue the work.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;improve-error-diagnostics&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#improve-error-diagnostics&quot; aria-label=&quot;Anchor link for: improve-error-diagnostics&quot;&gt;Improve Error Diagnostics&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;A critical blocker that makes it challenging for me to teach about CGP is the poor error
reporting returned from the Rust compiler, when there is any error arise from unsatisfied constraints.
CGP makes heavy use of blanket implementations to facilitate the wiring of components and provide
dependency injections. But due to its unconventional use of Rust&#x27;s trait systems, the error case
is not handled well by the current Rust compiler. This is a major issue, because without proper
error reporting, it is very tedious to figure out what went wrong inside the code that use CGP.&lt;&#x2F;p&gt;
&lt;p&gt;To improve the error message from Rust, I have taken the initiative to file issue
&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;issues&#x2F;134346&quot;&gt;#134346&lt;&#x2F;a&gt;, and attempted a preliminary fix
&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;pull&#x2F;134348&quot;&gt;#134348&lt;&#x2F;a&gt; that is made of ~30 lines of code.
Currently, the fix somewhat works, by at least showing sufficient information to allow
debugging to continue. However, it is not yet general enough to not affect general Rust
programs that do not use CGP.&lt;&#x2F;p&gt;
&lt;p&gt;I plan to eventually dive deeper into Rust&#x27;s error reporting code, and write a better patch
that can report CGP-related errors in better ways. But until I have the patch ready and merged,
any serious use of CGP would require the use of a fork of Rust compiler that applies my temporary patch.&lt;&#x2F;p&gt;
&lt;p&gt;The progress on improving the error messages is tracked on CGP&#x27;s GitHub issue
&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;contextgeneric&#x2F;cgp&#x2F;issues&#x2F;44&quot;&gt;#44&lt;&#x2F;a&gt;, and more information on how to use
the forked compiler is documented in the
&lt;a href=&quot;https:&#x2F;&#x2F;patterns.contextgeneric.dev&#x2F;debugging-techniques.html#improving-the-compiler-error-message&quot;&gt;CGP book&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;document-the-cgp-crate&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#document-the-cgp-crate&quot; aria-label=&quot;Anchor link for: document-the-cgp-crate&quot;&gt;Document the &lt;code&gt;cgp&lt;&#x2F;code&gt; Crate&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;I have done quite a bit of writing about CGP on the project website and the book. But if you
look at the Cargo documentation for the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;cgp&#x2F;&quot;&gt;&lt;code&gt;cgp&lt;&#x2F;code&gt; crate&lt;&#x2F;a&gt;, you would see
almost no documentation about any CGP core construct provided by the crate.&lt;&#x2F;p&gt;
&lt;p&gt;A main reason I haven&#x27;t focused on documenting the &lt;code&gt;cgp&lt;&#x2F;code&gt; crate is that I wanted to avoid
explaining the full CGP concepts inside the crate documentation. Instead, I plan to finish
the CGP book first, and then provide links inside the &lt;code&gt;cgp&lt;&#x2F;code&gt; crate for readers to learn
about relevant concepts.&lt;&#x2F;p&gt;
&lt;p&gt;That said, I do plan to provide at least minimal documentation inside the &lt;code&gt;cgp&lt;&#x2F;code&gt; crate,
to help onboarding programmers to projects that use the &lt;code&gt;cgp&lt;&#x2F;code&gt; crate.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;public-speaking&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#public-speaking&quot; aria-label=&quot;Anchor link for: public-speaking&quot;&gt;Public Speaking&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;An effective way to spread the awareness of CGP is for me to speak about it at Rust conferences.
I plan to apply to speak at major Rust conferences located in Europe, and hopefully I will get
accepted into at least some of them. If you know of a conference that I should speak at, do let
me know about it.&lt;&#x2F;p&gt;
&lt;p&gt;As an alternative, I also consider talking about CGP by sharing video recording on YouTube, or
by organizing online meetups. However, this would subject to my time availability and interest
from the community, as producing tech videos is not exactly my area of expertise.
But in case if you are interested in such content, do let me know what you would like to see produced.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;improve-the-cgp-macros&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#improve-the-cgp-macros&quot; aria-label=&quot;Anchor link for: improve-the-cgp-macros&quot;&gt;Improve the CGP Macros&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;The proc macros provided by the &lt;code&gt;cgp&lt;&#x2F;code&gt; crate were written in haste as quick proof of concepts
to simplify the syntax for writing CGP programs. As a result, they are not that high in quality,
and do not provide good UX when there are errors in using the macros. In most cases,
the macro would just panic, and do not provide much clue to users on what went wrong.&lt;&#x2F;p&gt;
&lt;p&gt;The CGP macros are also not comprehensive enough to support all possible ways users may define
CGP components. For instance, the use of const generics or associated constants may result in
macro panics. Other than that, there are known bugs when merging generic parameters coming from
multiple sources.&lt;&#x2F;p&gt;
&lt;p&gt;When I have the time, I plan to learn more about how to properly implement the proc macros,
and implement them correctly with proper test coverage. This is important to provide good
user experience, as developers will use the macros all the time when programming in CGP.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;developer-tooling&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#developer-tooling&quot; aria-label=&quot;Anchor link for: developer-tooling&quot;&gt;Developer Tooling&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;For CGP to gain mainstream adoption, it is not sufficient to just make CGP powerful enough
to solve difficult programming problems. In addition to that, we also need to make CGP
&lt;em&gt;easy&lt;&#x2F;em&gt; enough for even beginner programmers to easily pick up. And to move toward that
goal, we can slowly make CGP easier by building better &lt;em&gt;tools&lt;&#x2F;em&gt; to assist programming in CGP.&lt;&#x2F;p&gt;
&lt;p&gt;Although CGP makes heavy use of Rust&#x27;s trait system to power its component system, the
heavy machinery are &lt;em&gt;not&lt;&#x2F;em&gt; strictly necessary for its &lt;em&gt;users&lt;&#x2F;em&gt; who use CGP to build modular applications.
If we were to implement CGP as native language constructs, we could in principle not require
beginner programmers to understand anything about traits when they start to learn about CGP.
But even if CGP is not native Rust constructs, there are probably ways for us to build tools
that provide first class support for CGP.&lt;&#x2F;p&gt;
&lt;p&gt;One way we can provide such support is to build analyzers that give special treatment to CGP
traits such as &lt;code&gt;DelegateComponent&lt;&#x2F;code&gt;. Our tools can then perform analysis on the component
dependencies directly, and provide help in performing any necessary wiring.&lt;&#x2F;p&gt;
&lt;p&gt;Ideally, I would like to implement IDE features similar to Rust Analyzer, so that most of
the cognitive burden of wiring CGP components can be automated by the IDE. But it may take
much longer than one year for me to implement such features. In the meanwhile, I will probably
explore on simpler options, such as building simple CLI tools for CGP.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;implement-advanced-cgp-features&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#implement-advanced-cgp-features&quot; aria-label=&quot;Anchor link for: implement-advanced-cgp-features&quot;&gt;Implement Advanced CGP features&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Aside from improving CGP macros, there are a few more advanced core constructs that I need to
implement in the &lt;code&gt;cgp&lt;&#x2F;code&gt; crate to enable CGP to solve more use cases.
In particular, I plan to introduce constructs for context-generic construction of struct fields
(product types), and context-generic matching of enum variants (sum types).
These constructs are commonly needed in complex applications, and currently they are commonly
solved using OOP patterns such as factories and visitors.
CGP offers better alternatives than the existing OOP design patterns, but I have yet able to
find the time to implement and document them.&lt;&#x2F;p&gt;
&lt;p&gt;In case if you have interest in topics such as row polymorphism, datatype-generic programming,
and category theory, you might be interested to follow my progress on how I make use of these
advanced concepts in CGP.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;more-documentation&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#more-documentation&quot; aria-label=&quot;Anchor link for: more-documentation&quot;&gt;More Documentation&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;It would be a big milestone if I am able to finish the first CGP book and document the &lt;code&gt;cgp&lt;&#x2F;code&gt;
crate by the end of 2025. But I also hope to write more documentation in other forms, to
explain CGP in different ways to different audiences.&lt;&#x2F;p&gt;
&lt;p&gt;It would be helpful if I can write some tutorial series for teaching CGP to beginners, or
for programmers coming from imperative programming background. But it may be challenging to
write such tutorials, without first improving the toolings and error handling for CGP.
Alternatively, I may focus on writing use-case oriented series to explain how to use CGP
to solve real world problems, such as building web applications, training AI models,
or programming microcontrollers.&lt;&#x2F;p&gt;
&lt;p&gt;On one hand, I would like to avoid giving the impression that CGP is specifically
designed to solve a specific application domain. On the other hand, it is a bit tough
to demonstrate on my own how CGP can be used for all kinds of problem domains, while
I myself is clearly not an expert in all of them.&lt;&#x2F;p&gt;
&lt;p&gt;Perhaps the best way for me to approach this is for the community to guide me on
what kind of content I should produce for CGP. If you have a specific programming
problem that you think CGP may help solving, I would love to hear more about it.
This can help inform me what kind of topics is popular, and allows me to better
prepared to produce content for those topics.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;how-you-can-help&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#how-you-can-help&quot; aria-label=&quot;Anchor link for: how-you-can-help&quot;&gt;How You Can Help&lt;&#x2F;a&gt;&lt;&#x2F;h1&gt;
&lt;p&gt;If you have read till the end of this blog post, thank you for taking your time!
If you are interested in CGP, the project homepage &lt;a href=&quot;&#x2F;#contribution&quot;&gt;lists many ways&lt;&#x2F;a&gt;
you can help me continue my development on CGP.
I look forward to see you again in the future updates for CGP!&lt;&#x2F;p&gt;
&lt;p&gt;Following are some links to the discussions on this blog post:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;rust&#x2F;comments&#x2F;1hkzaiu&#x2F;announcing_contextgeneric_programming_a_new&#x2F;&quot;&gt;Reddit&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;lobste.rs&#x2F;s&#x2F;a5wfid&#x2F;context_generic_programming&quot;&gt;Lobsters&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=42498176&quot;&gt;Hacker News&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
</content>
        
    </entry>
</feed>
