---
slug: 'v0.6.2-release'
authors: [soares]
tags: [release]
---

# Supercharge Rust functions with implicit arguments using CGP v0.6.2

CGP v0.6.2 has been released, and it comes with powerful new features for us to use **implicit arguments** within plain function syntax through an `#[implicit]` attribute. In this blog post, we will walk through a simple tutorial on how to upgrade your plain Rust functions to use implicit arguments to pass around parameters through a generic context.

<!-- truncate -->

## Example use case: rectangle area calculation

To make the walkthrough approacheable to Rust programmers of all programming levels, we will use a simple use case of calculating the area of different shape types. For example, if we want to calculate the area of a rectangle, we might write a `rectangle_area` function as follows:

```rust
pub fn rectangle_area(width: f64, height: f64) -> f64 {
    width * height
}
```

The `rectangle_area` function accepts two explicit arguments `width` and `height`, which is not too tedious to pass around with. The implementation body is also intentionally trivial, so that this tutorial can remain comprehensible. But in real world applications, a plain Rust function may need to work with many more parameters to implement complex functionalities, and their function body may be significantly more complex.

Furthermore, we may want to implement other functions that call the `rectangle_area` function, and perform additional calculation based on the returned value. For example, suppose that we want to calculate the area of a rectangle value that contains an additional *scale factor*, we may want to write a `scaled_rectangle_area` function such as follows:

```rust
pub fn scaled_rectangle_area(
    width: f64,
    height: f64,
    scale_factor: f64,
) -> f64 {
    rectangle_area(width, height) * scale_factor * scale_factor
}
```

As we can see, the `scaled_rectangle_area` function mainly works with the `scale_factor` argument, but it needs to also accept `width` and `height` and explicitly pass the arguments to `rectangle_area`. (we will pretend that the implementation of `rectangle_area` is complex, so that it is not feasible to inline the implementation here)

This simple example use case demonstrates the problems that arise when dependencies need to be threaded through plain functions by the callers. Even with this simple example, the need for three parameters start to become slightly tedious. And things would become much worse for real world applications.

## Concrete context methods

Since passing function arguments explicitly can quickly get out of hand, in Rust we typically define *context types* that group dependencies into a single struct entity to manage the parameters more efficiently.

For example, we might define a `Rectangle` context and re-implement `rectangle_area` and `scaled_rectangle_area` as *methods* on the context:

```rust
pub struct Rectangle {
    pub width: f64,
    pub height: f64,
    pub scale_factor: f64,
}

impl Rectangle {
    pub fn rectangle_area(&self) -> f64 {
        self.width * self.height
    }

    pub fn scaled_rectangle_area(&self) -> f64 {
        self.rectangle_area() * self.scale_factor * self.scale_factor
    }
}
```

With a unified context, the method signatures of `rectangle_area` and `scaled_rectangle_area` become significantly cleaner. They both only need to accept a `&self` parameter. `scaled_rectangle` area also no longer need to know which fields are accessed by `rectangle_area`. All it needs to call `self.rectangle_area()`, and then apply the `scale_factor` field to the result.

The use of a common `Rectangle` context struct can result in cleaner method signatures, but it also introduces *tight coupling* between the individual methods and the context. As the application grows, the context type may become increasingly complex, and simple functions like `rectangle_area` would become increasingly coupled with unrelated dependencies.

For example, perhaps the application may need to assign *colors* to individual rectangles, or track their positions in a 2D space. So the `Rectangle` type may grow to become something like:

```rust
pub struct ComplexRectangle {
    pub width: f64,
    pub height: f64,
    pub scale_factor: f64,
    pub color: Color,
    pub pos_x: f64,
    pub pos_y: f64,
}
```

As the context grows, it becomes significantly more tedious to call a method like `rectangle_area`, even if we don't care about using other methods. We would still need to first construct a `ComplexRectangle` with most of the fields having default value, before we can call `rectangle_area`.

Furthermore, a concrete context definition also limits how it can be extended. Suppose that a third party application now wants to use the provided methods like `scaled_rectangle_area`, but also wants to store the rectangles in a *3D space*, it would be tough ask the upstream project to introduce a new `pos_z` field, which can potentially break many existing code. In the worst case, the last resort for extending the context is to fork the entire project to make the changes.

Ideally, what we really want is to have some ways to pass around the fields in a context *implicitly* to functions like `rectangle_area` and `scaled_rectangle_area`. As long as a context type contains the required fields, e.g. `width` and `height`, we should be able to call `rectangle_area` on it without needing to implement it for the specific context.

## Introducing `#[cgp_fn]` and `#[implicit]` arguments

CGP v0.6.2 introduces a new `#[cgp_fn]` macro, which we can apply to plain Rust functions and turn them into *context-generic* methods that accept *implicit arguments*. With that, we can rewrite the example `rectangle_area` function as follows:

```rust
#[cgp_fn]
pub fn rectangle_area(
    &self,
    #[implicit] width: f64,
    #[implicit] height: f64,
) -> f64 {
    width * height
}
```

Compared to before, our `rectangle_area` function contains a few extra constructs:

- `#[cgp_fn]` is used to augment the plain function.
- `&self` is given to access a reference to a *generic context* value.
- `#[implicit]` is applied to both `width` and `height`, indicating that the arguments will be automatically extracted from `&self`.

Aside from these extra annotations, the way we define `rectangle_area` remains largely the same as how we would define it previously as a plain Rust function.

With the CGP function defined, let's define a minimal `PlainRectangle` context type and test calling `rectangle_area` on it:

```rust
#[derive(HasField)]
pub struct PlainRectangle {
    pub width: f64,
    pub height: f64,
}
```

To enable context-generic capabilities on a context, we first need to apply `#[derive(HasField)]` on `PlainRectangle` to generate generic field access implementations. After that, we can just call `rectangle_area` on it:

```rust
let rectangle = PlainRectangle {
    width: 2.0,
    height: 3.0,
};

let area = rectangle.rectangle_area();
assert_eq!(area, 6.0);
```

And that's it! CGP implements all the heavyweight machinery behind the scene using Rust's trait system. But you don't have to understand any of that to start using `#[cgp_fn]`.

## Importing other CGP functions with `#[uses]`

Now that we have defined `rectangle_area` as a context-generic function, let's take a look at how to also define `scaled_rectangle_area` and call `rectangle_area` from it:

```rust
#[cgp_fn]
#[uses(RectangleArea)]
pub fn scaled_rectangle_area(
    &self,
    #[implicit] scale_factor: f64,
) -> f64 {
    self.rectangle_area() * scale_factor * scale_factor
}
```

Compared to `rectangle_area`, the implementation of `scaled_rectangle_area` contains an additional `#[uses(RectangleArea)]` attribute, which is used for us to "import" the capability to call `self.rectangle_area()`. The import identifier is in CamelCase, because `#[cgp_fn]` converts a function like `rectangle_area` into a *trait* called `RectangleArea`.

In the argument, we can also see that we only need to specify an implicit `scale_factor` argument. In general, there is no need for us to know which capabilities are required by an imported construct like `RectangleArea`. That is, we can just define `scaled_rectangle_area` without knowing the internal details of `rectangle_area`.

With `scaled_rectangle_area` defined, we can now define a *second* `RectangleWithScaleFactor` context that contains both the rectangle fields and the `scale_factor` field:

```rust
#[derive(HasField)]
pub struct RectangleWithScaleFactor {
    pub scale_factor: f64,
    pub width: f64,
    pub height: f64,
}
```

Similar to `PlainRectangle`, we only need to apply `#[derive(HasField)]` on it, and now we can call both `rectangle_area` and `scaled_rectangle_area` on it:

```rust
let rectangle = RectangleWithScaleFactor {
    scale_factor: 2.0,
    width: 3.0,
    height: 4.0,
};

let area = rectangle.rectangle_area();
assert_eq!(area, 12.0);

let scaled_area = rectangle.scaled_rectangle_area();
assert_eq!(scaled_area, 48.0);
```

It is also worth noting that there is no need for us to modify `PlainRectangle` to add a `scale_factor` on it. Instead, both `PlainRectangle` and `RectangleWithScaleFactor` can co-exist in separate locations, and all CGP constructs with satisfied requirements will work transparently on all contexts.

That is, we can still call `rectangle_area` on both `PlainRectangle` and `RectangleWithScaleFactor`. But we can call `scaled_rectangle_area` only on `RectangleWithScaleFactor`, since `PlainRectangle` lacks a `scale_factor` field.

## How it works

Now that we have gotten a taste of the power unlocked by `#[cgp_fn]`, let's take a sneak peak of how it works under the hood. Behind the scene, a CGP function like `rectangle_area` is roughly desugared to the following plain Rust code:

```rust
pub trait RectangleArea {
    fn rectangle_area(&self) -> f64;
}

pub trait RectangleFields {
    fn width(&self) -> f64;

    fn height(&self) -> f64;
}

impl<Context> RectangleArea for Context
where
    Self: RectangleFields,
{
    fn rectangle_area(&self) -> f64 {
        let width = self.width();
        let height = self.height();

        width * height
    }
}
```

As we can see from the desugared code, there are actually very little magic happening within the `#[cgp_fn]` macro. Instead, the macro mainly acts as a *syntactic sugar* to turn the function into the plain Rust constructs we see above.

First, a `RectangleArea` trait is defined with the CamelCase name derived from the function name. The trait contains similar function signature as `rectangle_area`, except that the implicit arguments are removed from the interface.

Secondly, a *getter trait* that resembles the `RectangleFields` above is used to access the `width` and `height` fields of a generic context.

Finally, a [**blanket implementation**](https://blog.implrust.com/posts/2025/09/blanket-implementation-in-rust/) of `RectangleArea` is defined to work with any `Context` type that contains both the `width` and `height` fields. This means that there is no need for any context type to implement `RectangleArea` manually.

Inside the function body, the macro desugars the implicit arguments into local `let` bindings that calls the getter methods and bind the field values to local variables. After that, the remaining function body follows the original function definition.

To make `RectangleArea` automatically implemented for a context like `PlainRectangle`, the `#[derive(HasField)]` macro generates getter trait implementations that are equivalent to follows:

```rust
impl RectangleFields for PlainRectangle {
    fn width(&self) -> f64 {
        self.width
    }

    fn height(&self) -> f64 {
        self.height
    }
}
```

With the getter traits implemented, the requirements for the blanket implementation of `RectangleArea` is satisfied. And thus we can now call call `rectangle_area()` on a `PlainRectangle` value.

### Zero Cost Abstraction

The plain Rust expansion demonstrates a few key properties of CGP. Firstly, CGP makes heavy use of the existing machinery provided by Rust's trait system to implement context-generic abstractions. It is also worth understanding that CGP macros like `#[cgp_fn]` and `#[derive(HasField)]` mainly act as **syntactic sugar** that perform simple desugaring of CGP code into plain Rust constructs like we shown above.

This means that there is **no hidden logic at both compile time and runtime** used by CGP to resolve dependencies like `width` and `height`. The main complexity of CGP lies in how it introduces new language syntax and leverages Rust's trait system to enable new language features. But you don't need to understand new machinery beyond the trait system to understand how CGP works.

Furthermore, implicit arguments like `#[implicit] width: f64` are automatically desugared by CGP to use getter traits similar to `RectangleFields`. And contexts like `PlainRectangle` implement `RectangleFields` by simply returning the field value. This means that implicit argument access are **zero cost** and are as cheap as direct field access from a concrete context.

The important takeaway from this is that CGP follows the same **zero cost abstraction** philosophy of Rust, and enables us to write highly modular Rust programs without any runtime overhead.

### Generalized Getter Fields

When we walk through the desugared Rust code, you might wonder: since `RectangleArea` requires the context to implement `RectangleFields`, does this means that a context type like `PlainRectangle` must know about it beforehand and explicitly implement `RectangleFields` before we can use `RectangleArea` on it?

The answer is yes for the simplified desugared code that we have shown earlier. But CGP actually employs a more generalized trait called `HasField` that can work generally for all possible structs. This means that there is **no need** to specifically generate a `RectangleFields` trait to be used by `RectangleArea`, or implemented by `PlainRectangle`.

The full explanation of how `HasField` works is beyond the scope of this tutorial. But the general idea is that an instance of `HasField` is implemented for every field inside a struct that uses `#[derive(HasField)]`. This is then used by implementations like `RectangleArea` to access a specific field by its field name.

In practice, this means that both `RectangleArea` and `PlainRectangle` can be defined in totally different crate without knowing each other. They can then be imported inside a third crate, and `RectangleArea` would still be automatically implemented for `PlainRectangle`.

### Comparison to Scala implicit parameters

### Desugaring `scaled_rectangle_area`

Similar to `rectangle_area`, the desugaring of `scaled_rectangle_area` follows the same process:

```rust
pub trait ScaledRectangleArea {
    fn scaled_rectangle_area(&self) -> f64;
}

pub trait ScaleFactorField {
    fn scale_factor(&self) -> f64;
}

impl<Context> ScaledRectangleArea for Context
where
    Self: RectangleArea + ScaleFactorField,
{
    fn scaled_rectangle_area(&self) -> f64 {
        let scale_factor = self.scale_factor();

        self.rectangle_area() * scale_factor * scale_factor
    }
}
```

Compared to `rectangle_area`, the desugared code for `scaled_rectangle_area` contains an additional trait bound `Self: RectangleArea`, which is generated from the `#[uses(RectangleArea)]` attribute. This also shows that importing a CGP construct is equivalent to applying it as a trait bound on `Self`.

It is also worth noting that trait bounds like `RectangleField` only appear in the `impl` block but not on the trait definition. This implies that they are *impl-side dependencies* that hide the dependencies behind a trait impl without revealing it in the trait interface.

Aside from that, `ScaledRectangleArea` also depends on field access traits that are equivalent to `ScaleFactorField` to retrieve the `scale_factor` field from the context. In actual, it also uses `HasField` to retrieve the `scale_factor` field value, and there is no extra getter trait generated.