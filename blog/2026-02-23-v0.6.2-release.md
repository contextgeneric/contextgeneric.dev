---
slug: 'v0.6.2-release'
authors: [soares]
tags: [release]
---

# Supercharge Rust functions with implicit arguments using CGP v0.6.2

CGP v0.6.2 has been released, and it comes with powerful new features for us to use **implicit arguments** within plain function syntax through an `#[implicit]` attribute. In this blog post, we will walk through a simple tutorial on how to upgrade your plain Rust functions to use implicit arguments to pass around parameters through a generic context.

<!-- truncate -->

## Example use case: rectangle area calculation

To make the walkthrough approacheable to Rust programmers of all programming levels, we will use a simple use case of calculating the area of different shape types. For example, if we want to calculate the area of a rectangle, we might write a `rectangle_area` function as follows:

```rust
pub fn rectangle_area(width: f64, height: f64) -> f64 {
    width * height
}
```

The `rectangle_area` function accepts two explicit arguments `width` and `height`, which is not too tedious to pass around with. The implementation body is also intentionally trivial, so that this tutorial can remain comprehensible. But in real world applications, a plain Rust function may need to work with many more parameters to implement complex functionalities, and their function body may be significantly more complex.

Furthermore, we may want to implement other functions that call the `rectangle_area` function, and perform additional calculation based on the returned value. For example, suppose that we want to calculate the area of a rectangle value that contains an additional *scale factor*, we may want to write a `scaled_rectangle_area` function such as follows:

```rust
pub fn scaled_rectangle_area(
    width: f64,
    height: f64,
    scale_factor: f64,
) -> f64 {
    rectangle_area(width, height) * scale_factor * scale_factor
}
```

As we can see, the `scaled_rectangle_area` function mainly works with the `scale_factor` argument, but it needs to also accept `width` and `height` and explicitly pass the arguments to `rectangle_area`. (we will pretend that the implementation of `rectangle_area` is complex, so that it is not feasible to inline the implementation here)

This simple example use case demonstrates the problems that arise when dependencies need to be threaded through plain functions by the callers. Even with this simple example, the need for three parameters start to become slightly tedious. And things would become much worse for real world applications.

## Concrete context methods

Since passing function arguments explicitly can quickly get out of hand, in Rust we typically define *context types* that group dependencies into a single struct entity to manage the parameters more efficiently.

For example, we might define a `Rectangle` context and re-implement `rectangle_area` and `scaled_rectangle_area` as *methods* on the context:

```rust
pub struct Rectangle {
    pub width: f64,
    pub height: f64,
    pub scale_factor: f64,
}

impl Rectangle {
    pub fn rectangle_area(&self) -> f64 {
        self.width * self.height
    }

    pub fn scaled_rectangle_area(&self) -> f64 {
        self.rectangle_area() * self.scale_factor * self.scale_factor
    }
}
```

With a unified context, the method signatures of `rectangle_area` and `scaled_rectangle_area` become significantly cleaner. They both only need to accept a `&self` parameter. `scaled_rectangle` area also no longer need to know which fields are accessed by `rectangle_area`. All it needs to call `self.rectangle_area()`, and then apply the `scale_factor` field to the result.

The use of a common `Rectangle` context struct can result in cleaner method signatures, but it also introduces *tight coupling* between the individual methods and the context. As the application grows, the context type may become increasingly complex, and simple functions like `rectangle_area` would become increasingly coupled with unrelated dependencies.

For example, perhaps the application may need to assign *colors* to individual rectangles, or track their positions in a 2D space. So the `Rectangle` type may grow to become something like:

```rust
pub struct ComplexRectangle {
    pub width: f64,
    pub height: f64,
    pub scale_factor: f64,
    pub color: Color,
    pub pos_x: f64,
    pub pos_y: f64,
}
```

As the context grows, it becomes significantly more tedious to call a method like `rectangle_area`, even if we don't care about using other methods. We would still need to first construct a `ComplexRectangle` with most of the fields having default value, before we can call `rectangle_area`.

Furthermore, a concrete context definition also limits how it can be extended. Suppose that a third party application now wants to use the provided methods like `scaled_rectangle_area`, but also wants to store the rectangles in a *3D space*, it would be tough ask the upstream project to introduce a new `pos_z` field, which can potentially break many existing code. In the worst case, the last resort for extending the context is to fork the entire project to make the changes.

Ideally, what we really want is to have some ways to pass around the fields in a context *implicitly* to functions like `rectangle_area` and `scaled_rectangle_area`. As long as a context type contains the required fields, e.g. `width` and `height`, we should be able to call `rectangle_area` on it without needing to implement it for the specific context.

## Introducing `#[cgp_fn]` and `#[implicit]` arguments

CGP v0.6.2 introduces a new `#[cgp_fn]` macro, which we can apply to plain Rust functions and turn them into *context-generic* methods that accept *implicit arguments*. With that, we can rewrite the example `rectangle_area` function as follows:

```rust
#[cgp_fn]
pub fn rectangle_area(
    &self,
    #[implicit] width: f64,
    #[implicit] height: f64,
) -> f64 {
    width * height
}
```

Compared to before, our `rectangle_area` function contains a few extra constructs:

- `#[cgp_fn]` is used to augment the plain function.
- `&self` is given to access a reference to a *generic context* value.
- `#[implicit]` is applied to both `width` and `height`, indicating that the arguments will be automatically extracted from `&self`.

Aside from these extra annotations, the way we define `rectangle_area` remains largely the same as how we would define it previously as a plain Rust function.

With the CGP function defined, let's define a minimal `PlainRectangle` context type and test calling `rectangle_area` on it:

```rust
#[derive(HasField)]
pub struct PlainRectangle {
    pub width: f64,
    pub height: f64,
}
```

To enable context-generic capabilities on a context, we first need to apply `#[derive(HasField)]` on `PlainRectangle` to generate generic field access implementations. After that, we can just call `rectangle_area` on it:

```rust
let rectangle = PlainRectangle {
    width: 2.0,
    height: 3.0,
};

let area = rectangle.rectangle_area();
assert_eq!(area, 6.0);
```

And that's it! CGP implements all the heavyweight machinery behind the scene using Rust's trait system. But you don't have to understand any of that to start using `#[cgp_fn]`.

## Importing other CGP functions with `#[uses]`

Now that we have defined `rectangle_area` as a context-generic function, let's take a look at how to also define `scaled_rectangle_area` and call `rectangle_area` from it:

```rust
#[cgp_fn]
#[uses(RectangleArea)]
pub fn scaled_rectangle_area(
    &self,
    #[implicit] scale_factor: f64,
) -> f64 {
    self.rectangle_area() * scale_factor * scale_factor
}
```

Compared to `rectangle_area`, the implementation of `scaled_rectangle_area` contains an additional `#[uses(RectangleArea)]` attribute, which is used for us to "import" the capability to call `self.rectangle_area()`. The import identifier is in CamelCase, because `#[cgp_fn]` converts a function like `rectangle_area` into a *trait* called `RectangleArea`.

In the argument, we can also see that we only need to specify an implicit `scale_factor` argument. In general, there is no need for us to know which capabilities are required by an imported construct like `RectangleArea`. That is, we can just define `scaled_rectangle_area` without knowing the internal details of `rectangle_area`.

With `scaled_rectangle_area` defined, we can now define a *second* `ScaledRectangle` context that contains both the rectangle fields and the `scale_factor` field:

```rust
#[derive(HasField)]
pub struct ScaledRectangle {
    pub scale_factor: f64,
    pub width: f64,
    pub height: f64,
}
```

Similar to `PlainRectangle`, we only need to apply `#[derive(HasField)]` on it, and now we can call both `rectangle_area` and `scaled_rectangle_area` on it:

```rust
let rectangle = ScaledRectangle {
    scale_factor: 2.0,
    width: 3.0,
    height: 4.0,
};

let area = rectangle.rectangle_area();
assert_eq!(area, 12.0);

let scaled_area = rectangle.scaled_rectangle_area();
assert_eq!(scaled_area, 48.0);
```

It is also worth noting that there is no need for us to modify `PlainRectangle` to add a `scale_factor` on it. Instead, both `PlainRectangle` and `ScaledRectangle` can **co-exist** in separate locations, and all CGP constructs with satisfied requirements will work transparently on all contexts.

This means that we can still call `rectangle_area` on both `PlainRectangle` and `ScaledRectangle`. But we can call `scaled_rectangle_area` only on `ScaledRectangle`, since `PlainRectangle` lacks a `scale_factor` field.

## How it works

Now that we have gotten a taste of the power unlocked by `#[cgp_fn]`, let's take a sneak peak of how it works under the hood. Behind the scene, a CGP function like `rectangle_area` is roughly desugared to the following plain Rust code:

```rust
pub trait RectangleArea {
    fn rectangle_area(&self) -> f64;
}

pub trait RectangleFields {
    fn width(&self) -> &f64;

    fn height(&self) -> &f64;
}

impl<Context> RectangleArea for Context
where
    Self: RectangleFields,
{
    fn rectangle_area(&self) -> f64 {
        let width = self.width().clone();
        let height = self.height().clone();

        width * height
    }
}
```

As we can see from the desugared code, there are actually very little magic happening within the `#[cgp_fn]` macro. Instead, the macro mainly acts as **syntactic sugar** to turn the function into the plain Rust constructs we see above.

First, a `RectangleArea` trait is defined with the CamelCase name derived from the function name. The trait contains similar function signature as `rectangle_area`, except that the implicit arguments are removed from the interface.

Secondly, a *getter trait* that resembles the `RectangleFields` above is used to access the `width` and `height` fields of a generic context.

Finally, a [**blanket implementation**](https://blog.implrust.com/posts/2025/09/blanket-implementation-in-rust/) of `RectangleArea` is defined to work with any `Context` type that contains both the `width` and `height` fields. This means that there is no need for any context type to implement `RectangleArea` manually.

Inside the function body, the macro desugars the implicit arguments into local `let` bindings that calls the getter methods and bind the field values to local variables. After that, the remaining function body follows the original function definition.

:::note

### Borrowed vs owned implicit arguments

The `width()` and and `height()` methods on `RectangleFields` return a borrowed `&f64`. This is because all field access are by default done through borrowing the field value from `&self`. However, when the implicit argument is an *owned value*, CGP will automatically call `.clone()` on the field value and require that the `Clone` bound of the type is satisfied.

We can rewrite the `rectangle_area` to accept the implicit `width` and `height` arguments as *borrowed* references, such as:

```rust
#[cgp_fn]
pub fn rectangle_area(
    &self,
    #[implicit] width: &f64,
    #[implicit] height: &f64,
) -> f64 {
    (*width) * (*height)
}
```

This way, the field access of the implicit arguments will be **zero copy** and not involve any cloning of values. It is just that in this case, we still need to dereference the `&f64` values to perform multiplication on them. And since `f64` can be cloned cheaply, we just opt for implicitly cloning the arguments to become owned values.

:::

To make `RectangleArea` automatically implemented for a context like `PlainRectangle`, the `#[derive(HasField)]` macro generates getter trait implementations that are equivalent to follows:

```rust
impl RectangleFields for PlainRectangle {
    fn width(&self) -> &f64 {
        &self.width
    }

    fn height(&self) -> &f64 {
        &self.height
    }
}
```

With the getter traits implemented, the requirements for the blanket implementation of `RectangleArea` is satisfied. And thus we can now call call `rectangle_area()` on a `PlainRectangle` value.

### Zero cost field access

The plain Rust expansion demonstrates a few key properties of CGP. Firstly, CGP makes heavy use of the existing machinery provided by Rust's trait system to implement context-generic abstractions. It is also worth understanding that CGP macros like `#[cgp_fn]` and `#[derive(HasField)]` mainly act as **syntactic sugar** that perform simple desugaring of CGP code into plain Rust constructs like we shown above.

This means that there is **no hidden logic at both compile time and runtime** used by CGP to resolve dependencies like `width` and `height`. The main complexity of CGP lies in how it introduces new language syntax and leverages Rust's trait system to enable new language features. But you don't need to understand new machinery beyond the trait system to understand how CGP works.

Furthermore, implicit arguments like `#[implicit] width: f64` are automatically desugared by CGP to use getter traits similar to `RectangleFields`. And contexts like `PlainRectangle` implement `RectangleFields` by simply returning the field value. This means that implicit argument access are **zero cost** and are as cheap as direct field access from a concrete context.

The important takeaway from this is that CGP follows the same **zero cost abstraction** philosophy of Rust, and enables us to write highly modular Rust programs without any runtime overhead.

### Auto getter fields

When we walk through the desugared Rust code, you might wonder: since `RectangleArea` requires the context to implement `RectangleFields`, does this means that a context type like `PlainRectangle` must know about it beforehand and explicitly implement `RectangleFields` before we can use `RectangleArea` on it?

The answer is yes for the simplified desugared code that we have shown earlier. But CGP actually employs a more generalized trait called `HasField` that can work generally for all possible structs. This means that there is **no need** to specifically generate a `RectangleFields` trait to be used by `RectangleArea`, or implemented by `PlainRectangle`.

The full explanation of how `HasField` works is beyond the scope of this tutorial. But the general idea is that an instance of `HasField` is implemented for every field inside a struct that uses `#[derive(HasField)]`. This is then used by implementations like `RectangleArea` to access a specific field by its field name.

In practice, this means that both `RectangleArea` and `PlainRectangle` can be defined in totally different crate without knowing each other. They can then be imported inside a third crate, and `RectangleArea` would still be automatically implemented for `PlainRectangle`.

### Comparison to Scala implicit parameters

### Desugaring `scaled_rectangle_area`

Similar to `rectangle_area`, the desugaring of `scaled_rectangle_area` follows the same process:

```rust
pub trait ScaledRectangleArea {
    fn scaled_rectangle_area(&self) -> f64;
}

pub trait ScaleFactorField {
    fn scale_factor(&self) -> &f64;
}

impl<Context> ScaledRectangleArea for Context
where
    Self: RectangleArea + ScaleFactorField,
{
    fn scaled_rectangle_area(&self) -> f64 {
        let scale_factor = self.scale_factor().clone();

        self.rectangle_area() * scale_factor * scale_factor
    }
}
```

Compared to `rectangle_area`, the desugared code for `scaled_rectangle_area` contains an additional trait bound `Self: RectangleArea`, which is generated from the `#[uses(RectangleArea)]` attribute. This also shows that importing a CGP construct is equivalent to applying it as a trait bound on `Self`.

It is also worth noting that trait bounds like `RectangleField` only appear in the `impl` block but not on the trait definition. This implies that they are *impl-side dependencies* that hide the dependencies behind a trait impl without revealing it in the trait interface.

Aside from that, `ScaledRectangleArea` also depends on field access traits that are equivalent to `ScaleFactorField` to retrieve the `scale_factor` field from the context. In actual, it also uses `HasField` to retrieve the `scale_factor` field value, and there is no extra getter trait generated.

## Using CGP functions with Rust traits

Now that we have understood how to write context-generic functions with `#[cgp_fn]`, let's look at some more advanced use cases.

Suppose that in addition to `rectangle_area`, we also want to define a context-generic `circle_area` function using `#[cgp_fn]`. We can easily write it as follows:

```rust
use core::f64::consts::PI;

#[cgp_fn]
pub fn circle_area(&self, #[implicit] radius: f64) -> f64 {
    PI * radius * radius
}
```

But suppose that we also want to implement a *scaled* version of `circle_area`, we now have to implement another `scaled_circle_area` function as follows:

```rust
#[cgp_fn]
#[uses(CircleArea)]
pub fn scaled_circle_area(&self, #[implicit] scale_factor: f64) -> f64 {
    self.circle_area() * scale_factor * scale_factor
}
```

We can see that both `scaled_circle_area` and `scaled_rectangle_area` share the same structure. The only difference is that `scaled_circle_area` depends on `CircleArea`, but `scaled_rectangle_area` depends on `RectangleArea`.

This repetition of scaled area computation can become tedious if there are many more shapes that we want to support in our application. Ideally, we would like to be able to define an area calculation trait as the common interface to calculate the area of all shapes, such as the following `CanCalculateArea` trait:

```rust
pub trait CanCalculateArea {
    fn area(&self) -> f64;
}
```

Now we can try to implement the `CanCalculateArea` trait on our contexts. For example, suppose that we have the following contexts defined:

```rust
#[derive(HasField)]
pub struct PlainRectangle {
    pub width: f64,
    pub height: f64,
}

#[derive(HasField)]
pub struct ScaledRectangle {
    pub width: f64,
    pub height: f64,
    pub scale_factor: f64,
}

#[derive(HasField)]
pub struct ScaledRectangleIn2dSpace {
    pub width: f64,
    pub height: f64,
    pub scale_factor: f64,
    pub pos_x: f64,
    pub pos_y: f64,
}

#[derive(HasField)]
pub struct PlainCircle {
    pub radius: f64,
}

#[derive(HasField)]
pub struct ScaledCircle {
    pub radius: f64,
    pub scale_factor: f64,
}
```

We can implement `CanCalculateArea` for each context as follows:

```rust
impl CanCalculateArea for PlainRectangle {
    fn area(&self) -> f64 {
        self.rectangle_area()
    }
}

impl CanCalculateArea for ScaledRectangle {
    fn area(&self) -> f64 {
        self.rectangle_area()
    }
}

impl CanCalculateArea for ScaledRectangleIn2dSpace {
    fn area(&self) -> f64 {
        self.rectangle_area()
    }
}

impl CanCalculateArea for PlainCircle {
    fn area(&self) -> f64 {
        self.circle_area()
    }
}

impl CanCalculateArea for ScaledCircle {
    fn area(&self) -> f64 {
        self.circle_area()
    }
}
```

There are quite a lot of boilerplate implementation that we need to make! If we keep multiple rectangle contexts in our application, like `PlainRectangle`, `ScaledRectangle`, and `ScaledRectangleIn2dSpace`, then we need to implement `CanCalculateArea` for all of them. But fortunately, the existing CGP functions like `rectangle_area` and `circle_area` help us simplify the the implementation body of `CanCalculateArea`, as we only need to forward the call.

Next, let's look at how we can define a unified `scaled_area` CGP function:

```rust
#[cgp_fn]
#[uses(CanCalculateArea)]
pub fn scaled_area(&self, #[implicit] scale_factor: f64) -> f64 {
    self.area() * scale_factor * scale_factor
}
```

Now we can call `scaled_area` on any context that contains a `scale_factor` field, *and* also implements `CanCalculateArea`. That is, we no longer need separate scaled area calculation functions for rectangles and circles!

## Overlapping implementations with CGP components

The earlier implementation of `CanCalculateArea` by our shape contexts introduce quite a bit of boilerplate. It would be nice if we can automatically implement the traits for our contexts, if the context contains the required fields.

For example, a naive attempt might be to write something like the following blanket implementations:

```rust
impl<Context> CanCalculateArea for Context
where
    Self: RectangleArea,
{
    fn area(&self) -> f64 {
        self.rectangle_area()
    }
}

impl<Context> CanCalculateArea for Context
where
    Self: CircleArea,
{
    fn area(&self) -> f64 {
        self.circle_area()
    }
}
```

But if we try that, we would get an error on the second implementation of `CanCalculateArea` with the following error:

```
conflicting implementations of trait `CanCalculateArea`
```

In short, we have run into the infamous [**coherence problem**](https://github.com/Ixrec/rust-orphan-rules) in Rust, which forbids us to write multiple trait implementations that may *overlap* with each other.

The reason for this restriction is pretty simple to understand. For example, suppose that we define a context that contains the fields `width`, `height`, but *also* `radius`, which implementation should we expect the Rust compiler to choose?

```rust
#[derive(HasField)]
pub struct IsThisRectangleOrCircle {
    pub width: f64,
    pub height: f64,
    pub radius: f64,
}
```

Although there are solid reasons why Rust disallows overlapping and orphan implementations, in practice it has fundamentally shaped the mindset of Rust developers to avoid a whole universe of design patterns just to work around the coherence restrictions.

CGP provides ways to partially workaround the coherence restrictions, and enables overlapping implementations through **named** implementation. The ways to do so is straightforward. First, we apply the `#[cgp_component]` macro to our `CanCalculateArea` trait:

```rust
#[cgp_component(AreaCalculator)]
pub trait CanCalculateArea {
    fn area(&self) -> f64;
}
```

The `#[cgp_component]` macro generates an additional trait called `AreaCalculator`, which we call a **provider trait**. The original `CanCalculateArea` trait is now called a **consumer trait** to allow us to distinguish the two traits.

Using the `AreaCalculator` provider trait, we can now define implementations that resemble blanket implementations using the `#[cgp_impl]` macro:

```rust
#[cgp_impl(new RectangleAreaCalculator)]
impl<Context> AreaCalculator for Context
where
    Self: RectangleArea,
{
    fn area(&self) -> f64 {
        self.rectangle_area()
    }
}

#[cgp_impl(new CircleAreaCalculator)]
impl<Context> AreaCalculator for Context
where
    Self: CircleArea,
{
    fn area(&self) -> f64 {
        self.circle_area()
    }
}
```

Compared to the vanilla Rust implementation, we change the trait name to use the provider trait `AreaCalculator` instead of the consumer trait `CanCalculateArea`. Additionally, we use the `#[cgp_impl]` macro to give the implementation a **name**, `RectangleAreaCalculator`. The `new` keyword in front denotes that we are defining a new provider of that name for the first time.

CGP providers like `RectangleAreaCalculator` are essentially **named implementation** of provider traits like `AreaCalculator`. Unlike regular Rust traits, each provider can freely implement the trait **without any coherence restriction**.

Additionally, the `#[cgp_impl]` macro also provides additional syntactic sugar, so we can simplify our implementation to follows:

```rust
#[cgp_impl(new RectangleAreaCalculator)]
#[uses(RectangleArea)]
impl AreaCalculator {
    fn area(&self) -> f64 {
        self.rectangle_area()
    }
}

#[cgp_impl(new CircleAreaCalculator)]
#[uses(CircleArea)]
impl AreaCalculator {
    fn area(&self) -> f64 {
        self.circle_area()
    }
}
```

When we write blanket implementations that are generic over the context type, we can omit the generic parameter and just refer to the generic context as `Self`.

`#[cgp_impl]` also support the same short hand as `#[cgp_fn]`, so we can use `#[uses]` to import the CGP functions `RectangleArea` and `CircleArea` to be used in our implementations.

In fact, with `#[cgp_impl]`, we can skip defining the CGP functions altogether, and inline the function bodies directly:


```rust
#[cgp_impl(new RectangleAreaCalculator)]
impl AreaCalculator {
    fn area(&self, #[implicit] width: f64, #[implicit] height: f64) -> f64 {
        width * height
    }
}

#[cgp_impl(new CircleAreaCalculator)]
impl AreaCalculator {
    fn area(&self, #[implicit] radius: f64) -> f64 {
        PI * radius * radius
    }
}
```

Similar to `#[cgp_fn]`, we can use implicit arguments through the `#[implicit]` attribute. `#[cgp_impl]` would automatically fetch the fields from the context the same way as `#[cgp_fn]`.

### Configurable static dispatch with `delegate_components!`

Although we have defined the providers `RectangleArea` and `CircleArea`, they are not automatically applied to our shape contexts. Because the coherence restrictions are still enforced by Rust, we still need to do some manual steps to implement the consumer trait on our shape contexts.

It is worth noting that even though we have annotated the `CanCalculateArea` trait with `#[cgp_component]`, the original trait is still there, and we can still use it like any regular Rust trait. So one way is to implement the trait manually to forward the implementation to the providers we want to use, like:


```rust
impl CanCalculateArea for PlainRectangle {
    fn area(&self) -> f64 {
        RectangleAreaCalculator::area(self)
    }
}

impl CanCalculateArea for ScaledRectangle {
    fn area(&self) -> f64 {
        RectangleAreaCalculator::area(self)
    }
}

impl CanCalculateArea for ScaledRectangleIn2dSpace {
    fn area(&self) -> f64 {
        RectangleAreaCalculator::area(self)
    }
}

impl CanCalculateArea for PlainCircle {
    fn area(&self) -> f64 {
        CircleAreaCalculator::area(self)
    }
}

impl CanCalculateArea for ScaledCircle {
    fn area(&self) -> f64 {
        CircleAreaCalculator::area(self)
    }
}
```

If we compare to before, the boilerplate is still there, and we are only replacing the original calls like `self.rectangle_area()` with the explicit provider calls like `RectangleAreaCalculator::area(self)`.

To shorten this further, we can use the `delegate_components!` macro to define an **implementation table** that maps a CGP component to our chosen providers. So we can rewrite the above code as:

```rust
delegate_components! {
    PlainRectangle {
        AreaCalculatorComponent: RectangleAreaCalculator,
    }
}

delegate_components! {
    ScaledRectangle {
        AreaCalculatorComponent: RectangleAreaCalculator,
    }
}

delegate_components! {
    ScaledRectangleIn2dSpace {
        AreaCalculatorComponent: RectangleAreaCalculator,
    }
}

delegate_components! {
    PlainCircle {
        AreaCalculatorComponent: CircleAreaCalculator,
    }
}

delegate_components! {
    ScaledCircle {
        AreaCalculatorComponent: CircleAreaCalculator,
    }
}
```

What the above code effectively does is to build **lookup tables** at **compile time** for Rust's trait system to know which provider implementation it should use to implement the consumer trait. The example lookup tables contain the following entries:

| Context | Component | Provider|
|--|--|--|
| `PlainRectangle` | `AreaCalculatorComponent` | `RectangleAreaCalculator` |
| `ScaledRectangle` | `AreaCalculatorComponent` | `RectangleAreaCalculator` |
| `ScaledRectangleIn2dSpace` | `AreaCalculatorComponent` | `RectangleAreaCalculator` |
| `PlainCircle` | `AreaCalculatorComponent` | `CircleAreaCalculator` |
| `ScaledCircle` | `AreaCalculatorComponent` | `CircleAreaCalculator` |


The type `AreaCalculatorComponent` is called a **component name**, and it is used as a key in the table to identify the CGP trait `CanCalculateArea` that we have defined earlier. By default, the component name of a CGP trait uses the provider trait name followed by a `Component` suffix.

Behind the scenes, `#[cgp_component]` generates a blanket implementation for the consumer trait, which it will automatically use to perform lookup on the tables we defined. If an entry is found and the requirements are satisfied, Rust would automatically implement the trait for us by forwarding it to the corresponding provider.

Using `delegate_component!`, we no longer need to implement the consumer traits manually on our context. Instead, we just need to specify key value pairs to map trait implementations to the providers that we have chosen for the context.

:::note
If you prefer explicit implementation over using `delegate_components!`, you can always choose to implement the consumer trait explicitly like we did earlier.

Keep in mind that `#[cgp_component]` keeps the original `CanCalculateArea` trait intact. So you can still implement the trait manually like any regular Rust trait.
:::

### No change to `scaled_area`

Now that we have turned `CanCalculateArea` into a CGP component, you might wonder: what do we need to change to use `CanCalculateArea` from `scaled_area`? And the answer is **nothing changes** and `scaled_area` stays the same as before:

```rust
#[cgp_fn]
#[uses(CanCalculateArea)]
pub fn scaled_area(&self, #[implicit] scale_factor: f64) -> f64 {
    self.area() * scale_factor * scale_factor
}
```

### Zero-cost and safe static dispatch

It is worth noting that the automatic implementation of CGP traits through `delegate_components!` are entirely safe and does not incur any runtime overhead. Behind the scene, the code generated by `delegate_components!` are *semantically equivalent* to the manual implementation of `CanCalculateArea` traits that we have shown in the earlier example.

CGP does **not** use any extra machinery like vtables to lookup the implementation at runtime - all the wirings happen only at compile time. Furthermore, the static dispatch is done entirely in **safe Rust**, and there is **no unsafe** operations like pointer casting or type erasure. When there is any missing dependency, you get a compile error immediately, and you will never need to debug any unexpected CGP error at runtime.

Furthermore, the compile-time resolution of the wiring happens *entirely within Rust's trait system*. CGP does **not** run any external compile-time processing or resolution algorithm through its macros. As a result, there is **no noticeable** compile-time performance difference between CGP code and vanilla Rust code that use plain Rust traits.

These properties are what makes CGP stands out compared to other programming frameworks. Essentially, CGP strongly follows Rust's zero-cost abstraction principles. We strive to provide the best-in-class modular programming framework that does not introduce performance overhead at both runtime and compile time. And we strive to enable highly modular code in low-level and safety critical systems, all while guaranteeing safety at compile time.