---
slug: 'v0.6.2-release'
authors: [soares]
tags: [release]
---

# Supercharge Rust functions with implicit arguments using CGP v0.6.2

CGP v0.6.2 has been released, and it comes with powerful new features for us to use **implicit arguments** within plain function syntax through an `#[implicit]` attribute. In this blog post, we will walk through a simple tutorial on how to upgrade your plain Rust functions to use implicit arguments to pass around parameters through a generic context.

<!-- truncate -->

## Example use case: rectangle area calculation

To make the walkthrough approacheable to Rust programmers of all programming levels, we will use a simple use case of calculating the area of different shape types. For example, if we want to calculate the area of a rectangle, we might write a `rectangle_area` function as follows:

```rust
pub fn rectangle_area(width: f64, height: f64) -> f64 {
    width * height
}
```

The `rectangle_area` function accepts two explicit arguments `width` and `height`, which is not too tedious to pass around with. The implementation body is also intentionally trivial, so that this tutorial can remain comprehensible. But in real world applications, a plain Rust function may need to work with many more parameters to implement complex functionalities, and their function body may be significantly more complex.

Furthermore, we may want to implement other functions that call the `rectangle_area` function, and perform additional calculation based on the returned value. For example, suppose that we want to calculate the area of a rectangle value that contains an additional *scale factor*, we may want to write a `scaled_rectangle_area` function such as follows:

```rust
pub fn scaled_rectangle_area(
    width: f64,
    height: f64,
    scale_factor: f64,
) -> f64 {
    rectangle_area(width, height) * scale_factor * scale_factor
}
```

As we can see, the `scaled_rectangle_area` function mainly works with the `scale_factor` argument, but it needs to also accept `width` and `height` and explicitly pass the arguments to `rectangle_area`. (we will pretend that the implementation of `rectangle_area` is complex, so that it is not feasible to inline the implementation here)

This simple example use case demonstrates the problems that arise when dependencies need to be threaded through plain functions by the callers. Even with this simple example, the need for three parameters start to become slightly tedious. And things would become much worse for real world applications.

## Concrete context methods

Since passing function arguments explicitly can quickly get out of hand, in Rust we typically define *context types* that group dependencies into a single struct entity to manage the parameters more efficiently.

For example, we might define a `Rectangle` context and re-implement `rectangle_area` and `scaled_rectangle_area` as *methods* on the context:

```rust
pub struct Rectangle {
    pub width: f64,
    pub height: f64,
    pub scale_factor: f64,
}

impl Rectangle {
    pub fn rectangle_area(&self) -> f64 {
        self.width * self.height
    }

    pub fn scaled_rectangle_area(&self) -> f64 {
        self.rectangle_area() * self.scale_factor * self.scale_factor
    }
}
```

With a unified context, the method signatures of `rectangle_area` and `scaled_rectangle_area` become significantly cleaner. They both only need to accept a `&self` parameter. `scaled_rectangle` area also no longer need to know which fields are accessed by `rectangle_area`. All it needs to call `self.rectangle_area()`, and then apply the `scale_factor` field to the result.

The use of a common `Rectangle` context struct can result in cleaner method signatures, but it also introduces *tight coupling* between the individual methods and the context. As the application grows, the context type may become increasingly complex, and simple functions like `rectangle_area` would become increasingly coupled with unrelated dependencies.

For example, perhaps the application may need to assign *colors* to individual rectangles, or track their positions in a 2D space. So the `Rectangle` type may grow to become something like:

```rust
pub struct ComplexRectangle {
    pub width: f64,
    pub height: f64,
    pub scale_factor: f64,
    pub color: Color,
    pub pos_x: f64,
    pub pos_y: f64,
}
```

As the context grows, it becomes significantly more tedious to call a method like `rectangle_area`, even if we don't care about using other methods. We would still need to first construct a `ComplexRectangle` with most of the fields having default value, before we can call `rectangle_area`.

Furthermore, a concrete context definition also limits how it can be extended. Suppose that a third party application now wants to use the provided methods like `scaled_rectangle_area`, but also wants to store the rectangles in a *3D space*, it would be tough ask the upstream project to introduce a new `pos_z` field, which can potentially break many existing code. In the worst case, the last resort for extending the context is to fork the entire project to make the changes.

Ideally, what we really want is to have some ways to pass around the fields in a context *implicitly* to functions like `rectangle_area` and `scaled_rectangle_area`. As long as a context type contains the required fields, e.g. `width` and `height`, we should be able to call `rectangle_area` on it without needing to implement it for the specific context.

## Introducing `#[cgp_fn]` and `#[implicit]` arguments

CGP v0.6.2 introduces a new `#[cgp_fn]` macro, which we can apply to plain Rust functions and turn them into *context-generic* methods that accept *implicit arguments*. With that, we can rewrite the example `rectangle_area` function as follows:

```rust
#[cgp_fn]
pub fn rectangle_area(
    &self,
    #[implicit] width: f64,
    #[implicit] height: f64,
) -> f64 {
    width * height
}
```

Compared to before, our `rectangle_area` function contains a few extra constructs:

- `#[cgp_fn]` is used to augment the plain function.
- `&self` is given to access a reference to a *generic context* value.
- `#[implicit]` is applied to both `width` and `height`, indicating that the arguments will be automatically extracted from `&self`.

Aside from these extra annotations, the way we define `rectangle_area` remains largely the same as how we would define it previously as a plain Rust function.

With the CGP function defined, let's define a minimal `PlainRectangle` context type and test calling `rectangle_area` on it:

```rust
#[derive(HasField)]
pub struct PlainRectangle {
    pub width: f64,
    pub height: f64,
}
```

To enable context-generic capabilities on a context, we first need to apply `#[derive(HasField)]` on `PlainRectangle` to generate generic field access implementations. After that, we can just call `rectangle_area` on it:

```rust
let rectangle = PlainRectangle {
    width: 2.0,
    height: 3.0,
};

let area = rectangle.rectangle_area();
assert_eq!(area, 6.0);
```

And that's it! CGP implements all the heavyweight machinery behind the scene using Rust's trait system. But you don't have to understand any of that to start using `#[cgp_fn]`.

## Importing other CGP functions with `#[uses]`

Now that we have defined `rectangle_area` as a context-generic function, let's take a look at how to also define `scaled_rectangle_area` and call `rectangle_area` from it:

```rust
#[cgp_fn]
#[uses(RectangleArea)]
pub fn scaled_rectangle_area(
    &self,
    #[implicit] scale_factor: f64,
) -> f64 {
    self.rectangle_area() * scale_factor * scale_factor
}
```

Compared to `rectangle_area`, the implementation of `scaled_rectangle_area` contains an additional `#[uses(RectangleArea)]` attribute, which is used for us to "import" the capability to call `self.rectangle_area()`. The import identifier is in CamelCase, because `#[cgp_fn]` converts a function like `rectangle_area` into a *trait* called `RectangleArea`.

In the argument, we can also see that we only need to specify an implicit `scale_factor` argument. In general, there is no need for us to know which capabilities are required by an imported construct like `RectangleArea`. That is, we can just define `scaled_rectangle_area` without knowing the internal details of `rectangle_area`.

With `scaled_rectangle_area` defined, we can now define a *second* `RectangleWithScaleFactor` context that contains both the rectangle fields and the `scale_factor` field:

```rust
#[derive(HasField)]
pub struct RectangleWithScaleFactor {
    pub scale_factor: f64,
    pub width: f64,
    pub height: f64,
}
```

Similar to `PlainRectangle`, we only need to apply `#[derive(HasField)]` on it, and now we can call both `rectangle_area` and `scaled_rectangle_area` on it:

```rust
let rectangle = RectangleWithScaleFactor {
    scale_factor: 2.0,
    width: 3.0,
    height: 4.0,
};

let area = rectangle.rectangle_area();
assert_eq!(area, 12.0);

let scaled_area = rectangle.scaled_rectangle_area();
assert_eq!(scaled_area, 48.0);
```

It is also worth noting that there is no need for us to modify `PlainRectangle` to add a `scale_factor` on it. Instead, both `PlainRectangle` and `RectangleWithScaleFactor` can co-exist in separate locations, and all CGP constructs with satisfied requirements will work transparently on all contexts.

That is, we can still call `rectangle_area` on both `PlainRectangle` and `RectangleWithScaleFactor`. But we can call `scaled_rectangle_area` only on `RectangleWithScaleFactor`, since `PlainRectangle` lacks a `scale_factor` field.
