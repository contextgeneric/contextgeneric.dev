---
slug: 'v0.7.0-release'
authors: [soares]
tags: [release]
---

# Supercharge Rust functions with implicit arguments using CGP v0.7.0

CGP v0.7.0 has been released, and it comes with powerful new features for us to use **implicit arguments** within plain function syntax through an `#[implicit]` attribute.

<!-- truncate -->

## What is CGP?

If you are new here, Context-Generic Programming (CGP) is a modular programming paradigm for Rust that unlocks powerful design patterns for writing code that is generic over a context (`Self`) type. CGP lets you define functions and implementations that work across many different context types without any manual boilerplate, all through Rust's own trait system and with zero runtime overhead.

:::note

Before diving into the specifics of this release, it is highly recommended that you read the new [**Area Calculation Tutorials**](/docs/tutorials/area-calculation/), which walk through the motivation for CGP and the v0.7.0 features in far greater depth than this post can cover.

:::

## The problem: parameter threading and tight coupling

To understand why v0.7.0 matters, it helps to appreciate the two limitations in conventional Rust that motivated it.

The first is **explicit parameter threading**. When a plain Rust function needs to pass values to another function, every intermediate caller in the chain must accept those values as arguments and forward them explicitly — even if they do not use them directly. As call chains grow, function signatures accumulate parameters that exist purely to satisfy the requirements of their callees.

The second is **tight coupling to a concrete context struct**. Rust developers often address parameter threading by grouping values into a single struct and defining methods on it. This does clean up the call signatures, but it tightly couples an implementation to one specific type. When the struct grows or needs to be extended, everything referencing it is affected, and there is no clean way to have multiple independent contexts share the same method without duplicating code.

CGP's `#[cgp_fn]` macro and `#[implicit]` arguments, introduced in v0.7.0, address both of these problems at once.

## Define CGP functions using the `#[cgp_fn]` Macro

The center piece of v0.7.0 is the `#[cgp_fn]` macro, which lets us write context-generic code in plain function syntax. A function decorated with `#[cgp_fn]` accepts a `&self` parameter that refers to a *generic context*, and may mark any of its arguments with `#[implicit]` to indicate that those values should be automatically extracted from the context rather than passed by the caller.

For example, here is how we define a context-generic function that computes the area of a rectangle:

```rust
#[cgp_fn]
pub fn rectangle_area(
    &self,
    #[implicit] width: f64,
    #[implicit] height: f64,
) -> f64 {
    width * height
}
```

Three annotations do the work here. `#[cgp_fn]` augments the plain function and turns it into a context-generic capability. `&self` provides a reference to whatever context this function is called on. And `#[implicit]` on both `width` and `height` tells CGP to fetch those values automatically from `&self` instead of requiring the caller to supply them.

The function body itself is entirely conventional Rust — there are no new concepts to learn beyond the annotations.

To use this function on a concrete type, we define a minimal context and apply `#[derive(HasField)]` to enable generic field access on it:

```rust
#[derive(HasField)]
pub struct PlainRectangle {
    pub width: f64,
    pub height: f64,
}
```

The `#[derive(HasField)]` macro generates implementations that allow CGP to access the fields of `PlainRectangle` generically by field name. With that in place, we can call `rectangle_area` as a method:

```rust
let rectangle = PlainRectangle {
    width: 2.0,
    height: 3.0,
};

let area = rectangle.rectangle_area();
assert_eq!(area, 6.0);
```

That's it. CGP propagates the fields to the function arguments automatically. You do not need to write any implementation for `PlainRectangle` beyond deriving `HasField`.

### Importing other CGP functions with `#[uses]`

One of the most valuable properties of context-generic functions is their ability to compose with each other. A new `#[uses]` attribute allows a CGP function to import another CGP function as a dependency, so that it can call it on `self` without the caller needing to know anything about the imported function's own requirements.

For example, here is how we define `scaled_rectangle_area`, which calls `rectangle_area` internally:

```rust
#[cgp_fn]
#[uses(RectangleArea)]
pub fn scaled_rectangle_area(
    &self,
    #[implicit] scale_factor: f64,
) -> f64 {
    self.rectangle_area() * scale_factor * scale_factor
}
```

The `#[uses(RectangleArea)]` attribute imports the `RectangleArea` trait — the CamelCase name that `#[cgp_fn]` derives from the function name `rectangle_area`. We only need to declare the `scale_factor` as an implicit argument, since `width` and `height` are already consumed internally by `rectangle_area`.

With `scaled_rectangle_area` defined, we can introduce a second context that adds a `scale_factor` field:

```rust
#[derive(HasField)]
pub struct ScaledRectangle {
    pub scale_factor: f64,
    pub width: f64,
    pub height: f64,
}
```

Like `PlainRectangle`, only `#[derive(HasField)]` is needed. Both contexts can now coexist independently:

```rust
let rectangle = ScaledRectangle {
    scale_factor: 2.0,
    width: 3.0,
    height: 4.0,
};

let area = rectangle.rectangle_area();
assert_eq!(area, 12.0);

let scaled_area = rectangle.scaled_rectangle_area();
assert_eq!(scaled_area, 48.0);
```

Importantly, `PlainRectangle` is never modified. It continues to support `rectangle_area` on its own, and `scaled_rectangle_area` is available only on contexts that also carry a `scale_factor` field. Two independent contexts can share the same function definitions without either one knowing about the other.

### Re-exporting imported CGP functions with `#[extend]`

The `#[uses]` attribute is analogous to Rust's `use` statement to import module constructs. This means that the imported CGP functions are hidden behind the generated `where` bounds using *impl-side dependencies*.

On the other hand, you can use the `#[extend]` attribute to import and **re-export** another CGP function, so that it can be used by anyone that imports your function. This works similar to Rust's `pub use` to re-export module constructs.

For example, we can rewrite `scaled_rectangle_area` to use `#[extend]` instead of `#[uses]`:

```rust
#[cgp_fn]
#[extend(RectangleArea)]
pub fn scaled_rectangle_area(
    &self,
    #[implicit] scale_factor: f64,
) -> f64 {
    self.rectangle_area() * scale_factor * scale_factor
}
```

This means that any construct that imports `ScaledRectangleArea` now also has access to `RectangleArea`. For example:

```rust
#[cgp_fn]
#[uses(ScaledRectangleArea)]
pub fn print_scaled_rectangle_area(&self) {
    println!(
        "The area of the rectangle is {}, and its scaled area is {}",
        self.rectangle_area(),
        self.scaled_rectangle_area(),
    );
}
```

The example `print_scaled_rectangle_area` function only needs to import `ScaledRectangleArea`, but we can call both `rectangle_area` and `scaled_rectangle_area` on it.

## Using `#[implicit]` in `#[cgp_impl]`

CGP v0.7.0 also brings support for using `#[implicit]` arguments inside `#[cgp_impl]`, which is used to write named provider implementations for CGP components. This is especially useful when implementing traits that are defined with `#[cgp_component]`.

For example, here is how we define an `AreaCalculator` component and a named provider for it using implicit arguments:

```rust
#[cgp_component(AreaCalculator)]
pub trait CanCalculateArea {
    fn area(&self) -> f64;
}

#[cgp_impl(new RectangleAreaCalculator)]
impl AreaCalculator {
    fn area(
        &self,
        #[implicit] width: f64,
        #[implicit] height: f64,
    ) -> f64 {
        width * height
    }
}
```

Prior to v0.7.0, achieving the same result required defining a separate getter trait with `#[cgp_auto_getter]`, adding it to the provider's `where` clause, and calling its getter methods explicitly:

```rust
#[cgp_auto_getter]
pub trait HasRectangleFields {
    fn width(&self) -> f64;
    fn height(&self) -> f64;
}

#[cgp_impl(new RectangleAreaCalculator)]
impl AreaCalculator
where
    Self: HasRectangleFields,
{
    fn area(&self) -> f64 {
        self.width() * self.height()
    }
}
```

With `#[implicit]`, that entire layer of boilerplate disappears. The `width` and `height` values are fetched directly from the context, and there is no need to manually maintain a getter trait, a `where` clause, or individual method calls. Behind the scenes, `#[implicit]` in `#[cgp_impl]` is semantically equivalent to `#[cgp_auto_getter]` and is equally zero cost.

## Provider composition with `#[use_provider]`

CGP v0.7.0 also introduces the `#[use_provider]` attribute for ergonomic import of other providers inside higher-order provider implementations. This is particularly useful when building providers that delegate part of their computation to a pluggable inner provider.

For example, suppose we want a general `ScaledAreaCalculator` that wraps any inner `AreaCalculator` provider and applies a scale factor to its result. We can now write this as follows:

```rust
#[cgp_impl(new ScaledAreaCalculator<InnerCalculator>)]
#[use_provider(InnerCalculator: AreaCalculator)]
impl<InnerCalculator> AreaCalculator {
    fn area(&self, #[implicit] scale_factor: f64) -> f64 {
        InnerCalculator::area(self) * scale_factor * scale_factor
    }
}
```

The `#[use_provider]` attribute declares that `InnerCalculator` must implement the `AreaCalculator` provider trait. Before this attribute was available, we had to write the same constraint manually in the `where` clause with an explicit `Self` parameter:

```rust
#[cgp_impl(new ScaledAreaCalculator<InnerCalculator>)]
impl<InnerCalculator> AreaCalculator
where
    InnerCalculator: AreaCalculator<Self>,
{
    fn area(&self, #[implicit] scale_factor: f64) -> f64 {
        InnerCalculator::area(self) * scale_factor * scale_factor
    }
}
```

The main ergonomic improvement is that `#[use_provider]` automatically inserts `Self` as the first generic parameter to the provider trait, so the user can treat provider traits the same way as consumer traits without needing to understand the underlying difference. The provider can then be composed into any context via `delegate_components!`:

```rust
delegate_components! {
    ScaledRectangle {
        AreaCalculatorComponent:
            ScaledAreaCalculator<RectangleAreaCalculator>,
    }
}
```

This shows that CGP providers are just plain Rust types, and higher-order providers like `ScaledAreaCalculator<RectangleAreaCalculator>` are simply generic type instantiations. No new runtime concepts are involved.

## Abstract type import with `#[use_type]`

CGP v0.7.0 also introduces the `#[use_type]` attribute for ergonomic import of abstract associated types. This lets you write context-generic functions that work with abstract types — such as a `Scalar` type that might be `f32`, `f64`, or any other numeric type — without needing to write `Self::` prefixes everywhere.

For example, here is how we define a version of `rectangle_area` that is generic over any scalar type by importing the `Scalar` associated type from a `HasScalarType` trait:

```rust
pub trait HasScalarType {
    type Scalar: Mul<Output = Scalar> + Copy;
}

#[cgp_fn]
#[use_type(HasScalarType::Scalar)]
pub fn rectangle_area(
    &self,
    #[implicit] width: Scalar,
    #[implicit] height: Scalar,
) -> Scalar {
    width * height
}
```

Without `#[use_type]`, the same function would require `Self::Scalar` throughout, which is noisier. Under the hood, `#[use_type(HasScalarType::Scalar)]` desugars to `#[extend(HasScalarType)]` and rewrites all references to the bare `Scalar` identifier back to `Self::Scalar`:

```rust
#[cgp_fn]
#[extend(HasScalarType)]
pub fn rectangle_area(
    &self,
    #[implicit] width: Self::Scalar,
    #[implicit] height: Self::Scalar,
) -> Self::Scalar {
    width * height
}
```

We can now define context types that use different scalar types. For example, here is a `PlainRectangle` that uses `f32` instead of `f64`:

```rust
#[derive(HasField)]
pub struct F32Rectangle {
    pub width: f32,
    pub height: f32,
}

impl HasScalarType for F32Rectangle {
    type Scalar = f32;
}
```

And `rectangle_area()` will work seamlessly with `f32` values:

```rust
let f32_rectangle = F32Rectangle {
    width: 3.0,
    height: 4.0,
};

assert_eq!(f32_rectangle.rectangle_area(), 12.0);
```

The `#[use_type]` attribute is also supported in both `#[cgp_component]` and `#[cgp_impl]`, making it uniformly available across the entire CGP surface:

```rust
#[cgp_component(AreaCalculator)]
#[use_type(HasScalarType::Scalar)]
pub trait CanCalculateArea {
    fn area(&self) -> Scalar;
}

#[cgp_impl(new RectangleArea)]
#[use_type(HasScalarType::Scalar)]
impl AreaCalculator {
    fn area(
        &self,
        #[implicit] width: Scalar,
        #[implicit] height: Scalar,
    ) -> Scalar {
        width * height
    }
}
```

## New Area Calculation Tutorials

To accompany this release, two new [**area calculation tutorials**](/docs/tutorials/area-calculation/) have been published that build up the full CGP feature set from first principles:

The [**Context-Generic Functions**](/docs/tutorials/area-calculation/context-generic-functions) tutorial starts from plain Rust and introduces `#[cgp_fn]`, `#[implicit]`, and `#[uses]`. It walks through the full desugaring of `rectangle_area` into Rust traits and blanket implementations, explains the `HasField`-based zero-cost field access model, and compares CGP's implicit arguments to Scala's implicit parameters for readers coming from other ecosystems.

The [**Static Dispatch**](/docs/tutorials/area-calculation/static-dispatch) tutorial introduces a second shape — the circle — to motivate a unified `CanCalculateArea` interface. It demonstrates Rust's coherence restrictions as a concrete problem, then resolves them using `#[cgp_component]` and named providers defined with `#[cgp_impl]`. Finally, it covers `delegate_components!` for configurable static dispatch and `#[use_provider]` for composing higher-order providers.

Both tutorials are designed to be read sequentially and assume no prior knowledge of CGP beyond basic Rust familiarity.

## Breaking Changes

The v0.7.0 release also includes a couple of minor breaking changes. The changes should not affect most of the CGP code, so there is mostly no need for migration.

### Removal of `#[cgp_context]`

The `#[cgp_context]` macro has been removed, following its deprecation in [v0.6.0](/blog/v0-6-0-release). It is now considered idiomatic to define context types directly without any additional CGP macro applied to it.

Affected code can follow the migration guide in v0.6.0 to use the context type for delegation, instead of through a `{Context}Components` delegation table.

### Change of consumer trait blanket implementation

The blanket implementation of consumer traits generated by `#[cgp_component]` has been simplified. For example, given:

```rust
#[cgp_component(Greeter)]
pub trait CanGreet {
    fn greet(&self);
}
```

The generated blanket implementation is now:

```rust
impl<Context> CanGreet for Context
where
    Context: Greeter<Context>,
{
    fn greet(&self) {
        Context::greet(self)
    }
}
```

That is, a `Context` type implements the consumer trait if it also implements the provider trait with itself being the context type.

Prior to this, the blanket implementation involves an additional table lookup similar to the provider trait:

```rust
impl<Context> CanGreet for Context
where
    Context: DelegateComponent<GreeterComponent>,
    Context::Delegate: Greeter<Context>,
{
    fn greet(&self) {
        Context::Delegate::greet(self)
    }
}
```

But since the provider trait's blanket implementation follows the same pattern and already perform lookup on `DelegateComponent`, this means that the consumer trait don't really need to also perform the lookup.

This change also gives the nice property that we can implement a consumer trait for a context by implement the provider trait with the context being its own provider. This may be useful in niche cases where we want to use a context both as as a context and as its own provider.

A consequence of this change is that when both the consumer trait and provider trait are in scope, there may be ambiguity when calling static methods on the context. This is because a context that implements a consumer trait through `delegate_components!` is also its own provider. So without an explicit `self` receiver, Rust wouldn't be able to know which trait implementation to use.

### Syntax improvements for `check_components` and `delegate_and_check_components!`

With the removal of `#[cgp_context]`, it is now idiomatic to always build the delegate lookup table directly on the context type. This also allows the `check_components!` and `delegate_and_check_components!` macros to provide simplified syntax for checking CGP component implementations.

#### Implicit check trait name

The check trait name can now be skipped, such as:

```rust
delegate_and_check_components! {
    ScaledRectangle {
        AreaCalculatorComponent:
            ScaledAreaCalculator<RectangleAreaCalculator>,
    }
}
```

and

```rust
check_components! {
    ScaledRectangle {
        AreaCalculatorComponent,
    }
}
```

By default, the check macros generate a check trait with the name `__CanUse{Context}`. The check trait name can be overridden with a `#[check_trait]` attribute. Such as:

```rust
delegate_and_check_components! {
    #[check_trait(CanUseScaledRectangle)]
    ScaledRectangle {
        AreaCalculatorComponent:
            ScaledAreaCalculator<RectangleAreaCalculator>,
    }
}

check_components! {
    #[check_trait(CheckScaledRectangle)]
    ScaledRectangle {
        AreaCalculatorComponent,
    }
}
```

The following old syntax are **no longer valid**:

```rust
delegate_and_check_components! {
    CanUseScaledRectangle for ScaledRectangle;
    ScaledRectangle {
        AreaCalculatorComponent:
            ScaledAreaCalculator<RectangleAreaCalculator>,
    }
}

check_components! {
    CheckScaledRectangle for ScaledRectangle {
        AreaCalculatorComponent,
    }
}
```

The main reason for this breaking change is because it is more tricky to support optional check trait names with the `for` keyword in between. On the other hand, it is easier to parse the existence of an attribute like `#[check_trait(CanUseScaledRectangle)]` at the beginning, before the context type is being parsed.

#### Specify check params using `#[check_params]` in `delegate_and_check_components!`

The `delegate_and_check_components!` macro now allows check parameters to be specified for more advanced cases where a CGP component trait contains generic paramters. For example, given:

```rust
#[cgp_component(AreaCalculator)]
pub trait CanCalculateArea<Scalar> {
    fn area(&self) -> Scalar;
}

#[cgp_impl(new RectangleArea)]
impl<Scalar> AreaCalculator<Scalar>
where
    Scalar: Mul<Output = Scalar> + Copy,
{
    fn area(&self, #[implicit] width: Scalar, #[implicit] height: Scalar) -> Scalar {
        width * height
    }
}
```

We can now both delegate and check the implementation of `AreaCalculatorComponent` with specific generic parameters:

```rust
delegate_and_check_components! {
    Rectangle {
        #[check_params(f64)]
        AreaCalculatorComponent:
            RectangleArea,
    }
}
```

This simplifies the need to specify additional checks using `check_components!` to check the wiring of generic CGP traits.

You can also skip the check for a specific component by using `#[skip_check]` to skip the checking for a particular component, such as:

```rust
delegate_and_check_components! {
    Rectangle {
        #[skip_check]
        AreaCalculatorComponent:
            RectangleArea,
    }
}
```

This may be useful if you want to perform more complex checks using a dedicated `check_components!` block.

### Use `Copy` instead of `Clone` for owned getter field values

Rust programmers prefer the explicit use of `.clone()` when passing owned values to function parameters. To better align with this principle, the `#[cgp_auto_getter]` trait now require `Copy` instead of `Clone` when the returned getter values are owned values. For example:

```rust
#[cgp_auto_getter]
pub trait RectangleFields: HasScalarType {
    fn width(&self) -> Self::Scalar;
    fn height(&self) -> Self::Scalar;
}
```

would now require the abstract type `Self::Scalar` to implement `Copy` for the getter trait to work.

This change is also reflected in the use of implicit arguments, where `Copy` is required:

```rust
#[cgp_fn]
#[use_type(HasScalarType::Scalar)]
pub fn rectangle_area(
    &self,
    #[implicit] width: Scalar,
    #[implicit] height: Scalar,
) -> Scalar {
    width * height
}
```

The use of `Copy` prevents potential surprises when expensive values are implicitly cloned into owned implicit arguments.

## Conclusion

CGP v0.7.0 is a significant step toward making context-generic programming in Rust feel natural and lightweight. The `#[implicit]` attribute eliminates a whole category of boilerplate: instead of threading parameters through every layer of the call stack or maintaining hand-written getter traits, you express what your function needs and let CGP wire it automatically. The `#[uses]`, `#[use_provider]`, and `#[use_type]` attributes complete the picture by making it equally ergonomic to import other capabilities, compose providers, and work with abstract types.

Taken together, these features allow you to write highly modular Rust code that scales to complex applications — without learning any machinery beyond Rust's own trait system, and without sacrificing the performance guarantees that Rust programmers depend on.
