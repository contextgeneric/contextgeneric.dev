---
slug: 'v0.7.0-release'
authors: [soares]
tags: [release]
---

# Supercharge Rust functions with implicit arguments using CGP v0.7.0

CGP v0.7.0 has been released, and it comes with powerful new features for us to use **implicit arguments** within plain function syntax through an `#[implicit]` attribute.

<!-- truncate -->

## New tutorials

If you new here, Context-Generic Programming (CGP) is a modular programming paradigm for Rust that unlocks powerful design patterns around writing code that are generic over a context (`Self`) type.

It is highly recommended that you should first read the new [**Area Calculation Tutorials**](/docs/tutorials/area-calculation/), which go into much finer details about the new CGP features than what is covered by this blog post.

## Define CGP functions using the `#[cgp_fn]` Macro

A new `#[cgp_fn]` macro has been introduced to enable us to easily write context-generic code in plain function syntax. Additionally, the macro supports `#[implicit]` attributes to be used in the function signature to automatically extract fields from the context.

For example, following is an example CGP function that calculate the area of a rectangle:

```rust
#[cgp_fn]
pub fn rectangle_area(
    &self,
    #[implicit] width: f64,
    #[implicit] height: f64,
) -> f64 {
    width * height
}
```

The following CGP constructs are used:

- `#[cgp_fn]` is used to augment the plain function.
- `&self` is given to access a reference to a *generic context* value.
- `#[implicit]` is applied to both `width` and `height`, indicating that the arguments will be automatically extracted from `&self`.


We can see how the CGP function works by using it with a minimal `PlainRectangle` context:

```rust
#[derive(HasField)]
pub struct PlainRectangle {
    pub width: f64,
    pub height: f64,
}
```

To enable context-generic capabilities on a context, we first need to apply `#[derive(HasField)]` on `PlainRectangle` to generate generic field access implementations. After that, we can just call `rectangle_area` on it:

```rust
let rectangle = PlainRectangle {
    width: 2.0,
    height: 3.0,
};

let area = rectangle.rectangle_area();
assert_eq!(area, 6.0);
```

And that's it! CGP implements all the heavyweight machinery behind the scene using Rust's trait system. But you don't have to understand any of that to start using `#[cgp_fn]`.

### Importing other CGP functions with `#[uses]`

A new `#[uses]` attribute is also added for ergonomic support of "importing" other CGP functions to be used in a CGP function. For example, let's take a look at how to also define `scaled_rectangle_area` and call `rectangle_area` from it:

```rust
#[cgp_fn]
#[uses(RectangleArea)]
pub fn scaled_rectangle_area(
    &self,
    #[implicit] scale_factor: f64,
) -> f64 {
    self.rectangle_area() * scale_factor * scale_factor
}
```

Compared to `rectangle_area`, the implementation of `scaled_rectangle_area` contains an additional `#[uses(RectangleArea)]` attribute, which is used for us to "import" the capability to call `self.rectangle_area()`. The import identifier is in CamelCase, because `#[cgp_fn]` converts a function like `rectangle_area` into a *trait* called `RectangleArea`.


In the argument, we can also see that we only need to specify an implicit `scale_factor` argument. In general, there is no need for us to know which capabilities are required by an imported construct like `RectangleArea`. That is, we can just define `scaled_rectangle_area` without knowing the internal details of `rectangle_area`.

With `scaled_rectangle_area` defined, we can now define a *second* `ScaledRectangle` context that contains both the rectangle fields and the `scale_factor` field:

```rust
#[derive(HasField)]
pub struct ScaledRectangle {
    pub scale_factor: f64,
    pub width: f64,
    pub height: f64,
}
```

Similar to `PlainRectangle`, we only need to apply `#[derive(HasField)]` on it, and now we can call both `rectangle_area` and `scaled_rectangle_area` on it:

```rust
let rectangle = ScaledRectangle {
    scale_factor: 2.0,
    width: 3.0,
    height: 4.0,
};

let area = rectangle.rectangle_area();
assert_eq!(area, 12.0);

let scaled_area = rectangle.scaled_rectangle_area();
assert_eq!(scaled_area, 48.0);
```

It is also worth noting that there is no need for us to modify `PlainRectangle` to add a `scale_factor` on it. Instead, both `PlainRectangle` and `ScaledRectangle` can **co-exist** in separate locations, and all CGP constructs with satisfied requirements will work transparently on all contexts.

This means that we can still call `rectangle_area` on both `PlainRectangle` and `ScaledRectangle`. But we can call `scaled_rectangle_area` only on `ScaledRectangle`, since `PlainRectangle` lacks a `scale_factor` field.

## Using `#[implicit]` in `#[cgp_impl]`

CGP v0.7.0 also brings support for using `#[implicit]` arguments in `#[cgp_impl]`. For example:

```rust
#[cgp_component(AreaCalculator)]
pub trait CanCalculateArea {
    fn area(&self) -> f64;
}

#[cgp_impl(new RectangleAreaCalculator)]
impl AreaCalculator {
    fn area(
        &self,
        #[implicit] width: f64,
        #[implicit] height: f64,
    ) -> f64 {
        width * height
    }
}
```

Prior to v0.7.0, we would need to use `#[cgp_auto_getter]` to define a separate getter trait to access the rectangle fields:

```rust
#[cgp_auto_getter]
pub trait HasRectangleFields {
    fn width(&self) -> f64;
    fn height(&self) -> f64;
}

#[cgp_impl(new RectangleAreaCalculator)]
impl AreaCalculator
where
    Self: HasRectangleFields,
{
    fn area(&self) -> f64 {
        self.width() * self.height()
    }
}
```

As we can see, with the introduction of `#[implicit]`, the ergonomic for generic field access has become significantly simpler compared to before. Users no longer need to manually define additional getter traits, include them in the `where` clause, and call the getter methods to get the values.

Behind the scenes, the use of `#[implicit]` is semantically equivalent to the use of `#[cgp_auto_getter]`, and they are both zero cost access of fields in the context.

## Provider import with `#[use_provider]`

CGP v0.7.0 also brings new ergonomic support for using `#[use_provider]` to import provider capabilities within higher order providers. For example, we can implement a scaled area calculator higher order provider as follows:

```rust
#[cgp_impl(new ScaledAreaCalculator<InnerCalculator>)]
#[use_provider(InnerCalculator: AreaCalculator)]
impl<InnerCalculator> AreaCalculator {
    fn area(&self, #[implicit] scale_factor: f64) -> f64 {
        InnerCalculator::area(self) * scale_factor * scale_factor
    }
}
```

The `#[use_provider]` attribute accepts a provider type followed by a list of provider traits it need to implement.

Before this, the provider would need to be imported explicitly like:

```rust
#[cgp_impl(new ScaledAreaCalculator<InnerCalculator>)]
impl<InnerCalculator> AreaCalculator
where
    InnerCalculator: AreaCalculator<Self>,
{
    fn area(&self, #[implicit] scale_factor: f64) -> f64 {
        InnerCalculator::area(self) * scale_factor * scale_factor
    }
}
```


The main ergonomic improvement is that `#[use_provider]` automatically inserts `Self` as the first generic parameter to the provider trait, so that the user can treat provider traits the same way as consumer traits without understanding the underlying details.

## Abstract type import with `#[use_type]`

CGP v0.7.0 also introduces ergonomic support for abstract type import using the `#[use_type]` attribute. For example, you can use an abstract `Scalar` type to define a generic `rectangle_area` CGP function that works with `f32`, `f64`, or any other scalar types as follows:

```rust
pub trait HasScalarType {
    type Scalar: Mul<Output = Scalar> + Clone;
}

#[cgp_fn]
#[use_type(HasScalarType::Scalar)]
pub fn rectangle_area(
    &self,
    #[implicit] width: Scalar,
    #[implicit] height: Scalar,
) -> Scalar {
    width * height
}
```

The code would be desugared to:

```rust
#[cgp_fn]
#[extend(HasScalarType)]
pub fn rectangle_area(
    &self,
    #[implicit] width: Self::Scalar,
    #[implicit] height: Self::Scalar,
) -> Self::Scalar {
    width * height
}
```

As we can see, the main advantage provided by `#[use_type]` is that it removes the `Self::` prefix needed for associated types, and allow you to treat the abstract type the same way as a lazily imported type identifier.

With abstract types, we can define rectangle contexts with different scalar types, such as one that uses `f32` instead of `f64`:

```rust
#[derive(HasField)]
pub struct F32Rectangle {
    pub width: f32,
    pub height: f32,
}

impl HasScalarType for F32Rectangle {
    type Scalar = f32;
}
```

And the `rectangle_area()` method would now work with `f32`:

```rust
let f32_rectangle = F32Rectangle {
    width: 3.0,
    height: 4.0,
};

assert_eq!(f32_rectangle.rectangle_area(), 12.0);
```

We can also use `#[use_type]` in both `#[cgp_component]` and `#[cgp_impl]`, such as:

```rust
#[cgp_component(AreaCalculator)]
#[use_type(HasScalarType::Scalar)]
pub trait CanCalculateArea {
    fn area(&self) -> Scalar;
}

#[cgp_impl(new RectangleArea)]
#[use_type(HasScalarType::Scalar)]
impl AreaCalculator
{
    fn area(
        &self,
        #[implicit] width: Scalar,
        #[implicit] height: Scalar,
    ) -> Scalar {
        width * height
    }
}
```