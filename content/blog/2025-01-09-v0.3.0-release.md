+++

title = "CGP Updates: v0.3.0 Release and New Chapters"

+++

# Summary

We have just released [v0.3.0](https://github.com/contextgeneric/cgp/releases/tag/v0.3.0) of the [`cgp`](https://docs.rs/cgp/0.3.0/cgp/) crate, as well as few [new](https://patterns.contextgeneric.dev/error-handling.html) [chapters](https://patterns.contextgeneric.dev/field-accessors.html) of the [CGP Patterns](https://patterns.contextgeneric.dev/) book!
This post will highly some of the key features and changes in this release.

# New Book Chapters

A few new chapters have been published for [CGP Patterns](https://patterns.contextgeneric.dev/). A short summary is included here on the contents that has been added.

## Associated Types

During the [launch announcement](/blog/early-preview-announcement/) for CGP, some readers commented that CGP is just a dependency injection framework in Rust. While that is partially true with the initial introduction, a key feature that was yet covered was the ability to use _abstract types_ together with dependency injection of _types_ in CGP.

In this [new chapter](https://patterns.contextgeneric.dev/associated-types.html) of the book, we walk through a motivating example of using abstract `Time` and `AuthToken` types to implement a context-generic auth token validator, that is not only generic over the `Context`, but also the abstract `Time` and `AuthToken` types. We also go through how to use the `cgp_type!` macro to simplify the declaration of abstract type traits, and how to use `UseType` inside component wiring to instantiate an abstract type.

## Error Handling

CGP offers us a different way of thinking and approaching error handling, which is very different from how error handling is typically done in Rust today. In this [new chapter](https://patterns.contextgeneric.dev/error-handling.html) of the book, we start with using an abstract `Error` type from `HasErrorType` to return erros inside the method signatures. We then go through how to use `CanRaiseError` and `CanWrapError` to produce abstract errors inside context-generic provider implementations. We also discussed how to define context-generic error raisers, and make use of the `UseDelegate` pattern to statically dispatch error handling to different providers.

## Field Accessors

CGP offers a way to make use of dependency injection using impl-side dependencies. However, since dependencies are included in the form of traits and constraints, we need to define _accessor traits_ to retrieve field values from a generic context.

In this [new chapter](https://patterns.contextgeneric.dev/field-accessors.html), we go through various ways of defining, using, and implementing accessor traits in CGP. We will learn about how the `#[derive(HasField)]` macro works, and the internal details of `HasField` and `symbol!`. We then learn about how to use `#[cgp_auto_getter]` and `#[cgp_getter]` macros to automatically generate accessor provider implementations that can work together with `HasField`.

# `cgp` v0.3.0 Release

The `cgp` crate has been upgraded from `v0.2.0` to `v0.3.0`. This release adds a couple of new features that sigificantly improve the usability of CGP, and some minor breaking changes. You can check out the full [release notes here](https://github.com/contextgeneric/cgp/releases/tag/v0.3.0). We have also updated the [Hello World example](/#hello-world-example) at the project homepage to have a simpler Hello World example using the new CGP constructs.

Below summarizes some of the key changes.

## `cgp_type!` Macro

The `cgp_type!` macro makes it easy to declare new abstract type traits with just one line of code. For example, the `HasErrorType` trait is defined in `cgp` as:

```rust
cgp_type!( Error: Debug );
```

`cgp_type!` would then expand the code into something like:

```rust
#[cgp_component {
    name: ErrorTypeComponent,
    provider: ProvideErrorType,
}]
pub trait HasErrorType {
    type Error: Debug;
}

impl<Context, Error> ProvideErrorType<Context> for UseType<Error>
where
    Error: Debug,
{
    type Error = Error;
}
```

More details about `cgp_type!` is available at the new [Associated Types](https://patterns.contextgeneric.dev/associated-types.html#defining-abstract-type-traits-with-cgp_type) chapter of the CGP Patterns book.

## `#[cgp_auto_getter]` Macro

The `#[cgp_auto_getter]` macro makes it easy to define accessor traits with blanket implementations that are implemented using `HasField`. When a trait is defined with `#[cgp_auto_getter]`, when a context uses `#[derive(HasField)]` and have the same fields and types as the corresponding accessor methods, they would automatically implement the given trait via the blanket implementation.

Following is an example use:

```rust
use cgp::prelude::*;

#[cgp_auto_getter]
pub trait HasName {
    fn name(&self) -> &String;
}

#[derive(HasField)]
pub struct Person {
    pub name: String,
}

fn main() {
    let person = Person {
        name: "Alice".into(),
    };

    println!("Hello, {}", person.name());
}
```

As shown in the example, the `Person` struct only derives the `HasField` trait, but it also automatically implements `HasName` without additional code needed. Because of this, an accessor trait like `HasName` can be defined separately in other crates or modules, but it would still be automatically implemented for all structs that derive `HasField` with the required fields present.

More details about `#[cgp_auto_getter]` is available at the [Generic Accessor Providers](https://patterns.contextgeneric.dev/generic-accessor-providers.html#the-cgp_auto_getter-macro) chapter of the CGP Patterns book.

## `#[cgp_getter]` Macro

Similar to `#[cgp_auto_getter]`, the `#[cgp_getter]` macro generates some blanket implementations that make use of `HasField`. But `#[cgp_getter]` also generates full CGP constructs on the trait in the same way as `#[cgp_component]`. This means that a context needs to have explicit wiring to implement the trait using `delegate_components!`. However, `#[cgp_getter]` also derives a blanket implementation for the `UseFields` provider, so the same example above that uses `#[cgp_getter]` would be rewritten as:

```rust
use cgp::prelude::*;

#[cgp_getter {
    provider: NameGetter,
}]
pub trait HasName {
    fn name(&self) -> &String;
}

#[derive(HasField)]
pub struct Person {
    pub name: String,
}

pub struct PersonComponents;

impl HasComponents for Person {
    type Components = PersonComponents;
}

delegate_components! {
    PersonComponents {
        NameGetterComponent: UseFields,
    }
}

fn main() {
    let person = Person {
        name: "Alice".into(),
    };

    println!("Hello, {}", person.name());
}
```

More details about `#[cgp_getter]` is available at the [Generic Accessor Providers](https://patterns.contextgeneric.dev/generic-accessor-providers.html#the-cgp_getter-macro) chapter of the CGP Patterns book.

## `cgp-error-anyhow` Crate

We have published a new [`cgp-error-anyhow`](https://docs.rs/cgp-error-anyhow/0.3.0/cgp_error_anyhow/index.html) crate to offer context-generic error raisers for `anyhow::Error`. Previously, we had already published [`cgp-error-eyre`](https://docs.rs/cgp-error-eyre/0.3.0/cgp_error_eyre/index.html) and [`cgp-error-std`](https://docs.rs/cgp-error-std/0.3.0/cgp_error_std/index.html), to implement CGP error handling using `eyre::Error` and `Box<dyn core::error::Error + Send + Sync + 'static>`. So this is more of an addition to also support `anyhow::Error`, since its use is quite popular at the moment.

More details about using `cgp-error-anyhow` for handling is available at the [Error Handling](https://patterns.contextgeneric.dev/error-handling.html#the-cgp-error-anyhow-crate) chapter of the CGP Patterns book.

## `cgp-runtime` Crate

We have published a new [`cgp-runtime`](https://docs.rs/cgp-runtime/0.3.0/cgp_runtime/index.html) crate to declare standardized interfaces for runtimes. This will be important for covering the topics for asynchronous programming inside the CGP Patterns book in the future.

The constructs from `cgp-runtime` are re-exported by `cgp`, and contains the following components:

```rust
cgp_type!( Runtime );

#[cgp_getter {
    provider: RuntimeGetter,
}]
pub trait HasRuntime: HasRuntimeType {
    fn runtime(&self) -> &Self::Runtime;
}
```

If you are interested to learn about using pluggable async runtimes with CGP, stay tuned for the updates on the CGP Patterns book!

# Future Work

There are many more things that I hoped to have done in this update. However my new year vacation is ending soon, and I have to wrap up the current progress here. Here are some of the things that I have left for future updates.

## Documenting the `cgp` Crate

Although a lot of materials have been written on the CGP Patterns book, the `cgp` crate still have almost non-existance Rustdoc documentation within the crates and constructs. I will slowly add short Rustdoc comments to the CGP constructs that have been covered, and add links to the relevant chapters of the book. But for now, documentation about CGP are only available at the CGP Patterns book and this website.

## Tutorials with More Complex Use Cases

During the [launch announcement](/blog/early-preview-announcement/), many readers have commented about the lack of practical examples to demonstrate the use of CGP to solve more complex real world problems. Although I have planned to write such tutorials, it took too much of my time to finish the relevant chapters and update the `cgp` crate. So I hope you can be patient and wait a little longer for me to present a concise and compelling example to movitate the use of CGP.

In the meanwhile, I hope that the simplified examples provided in the [Associated Types](https://patterns.contextgeneric.dev/associated-types.html), [Error Handling](https://patterns.contextgeneric.dev/error-handling.html), and [Field Accessors](https://patterns.contextgeneric.dev/field-accessors.html) chapters that are added in this update. In these chapters, I provided an example use of CGP for validating whether an authentication token has expired, and an example for making HTTP API call to fetch messages. Hopefully, these examples are slightly more informative than the hello world example at the homepage to give you an idea of how CGP can be useful for your own projects.

# Acknowledgement

Huge thanks to [@marvin-hansen](https://github.com/marvin-hansen) for his enthusiastic participation in discussions, trying out using CGP with real world projects, and providing valuable feedback! The implementation of of the `#[cgp_getter]` and `#[cgp_auto_getter]` macros are primarily motivated by his feedback that the direct use of `HasField` is too complicated to understand for beginners. Thanks to the feedback, CGP now provides almost automagical experience for declaring and using field accessor traits!

Also thanks everyone who provided valuable comments and feedback for the launch announcement on [Reddit](https://www.reddit.com/r/rust/comments/1hkzaiu/announcing_contextgeneric_programming_a_new/) and [Lobsters](https://lobste.rs/s/a5wfid/context_generic_programming)! Your feedback have given me better insights on what are the more important things that I should focus on, and better prioritize my work. There are still a long way to go before CGP can reach v1.0 and ready for use in the wild. I hope you can continue supporting me until that is ready!