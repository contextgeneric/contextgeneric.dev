+++

title = "CGP Updates: v0.4.0 Release with Improved Developer Experience"

description = "I'm excited to announce the release of v0.4.0 of the cgp crate, along significantly improved developer experience!"

authors = ["Soares Chen"]

+++

## Summary

It has been a while since the last update. I'm excited to announce the release of [`v0.4.0`](https://github.com/contextgeneric/cgp/releases/tag/v0.4.0) or the [`cgp`](https://docs.rs/cgp/0.4.0/cgp/), with tons of new features along with significantly improved developer experience!

This post hightlights the major updates that have been developed over the past few months, along with some personal updates.

## Improved Debugging

The most significant improvement in this update is that it is now significantly easier to debug CGP errors that arise from unsatisfied dependencies. [Previously](/blog/early-preview-announcement/#improve-error-diagnostics), this was the most significant challenge for CGP to gain wider adoption, as it was virtually impossible to debug CGP programs due to Rust hiding the necessary information. In this release, we have developed new techniques to overcome this challenge, and make Rust show all errors that were previously hidden.

### `IsProviderFor` Trait

In short, the technique works by introducing a new `IsProviderFor` trait in [#63](https://github.com/contextgeneric/cgp/pull/63), which is defined as follows:

```rust
pub trait IsProviderFor<Component, Context, Params = ()> {}
```

The `IsProviderFor` trait has nothing interesting, but is intended to be implemented by providers with additional constraints hidden within the trait implementation. The trait then acts as a "trait-erased" trait to carry around the constraints that the provider used to implement the original provider trait.

Users of CGP do not need to understand in details how `IsProviderFor` works, other than that it is used behind the scene by CGP to show better error messages.

### `#[cgp_provider]` Macro

The main change that is required for this to work is that users are now required to annotate CGP provider implementations using the `#[cgp_provider]` or `#[cgp_new_provider]` macros. For example:

```rust
#[cgp_new_provider]
impl<Context> Greeter<Context> for GreetHello
where
    Context: HasName,
{
    fn greet(context: &Context) {
        println!("Hello, {}!", context.name());
    }
}
```

The macro would then generate the following `IsProviderFor` implementation, which includes the `Context: HasName` constraint in it:

```rust
impl<Context> IsProviderFor<GreeterComponent, Context, ()>
    for GreetHello
where
    Context: HasName
{ }
```

The main difference between the `#[cgp_provider]` and `#[cgp_new_provider]` is that `#[cgp_new_provider]` also generates the provider struct definition, i.e. `struct GreetHello;`, allowing less code to be written by hand.

### `check_components!` Macro

Along with the `IsProviderFor` trait, the `check_components!` macro is introduced to allow users to write compile-time tests to check for the correctness of component wiring for a CGP context. For example, the following code generates a check trait called `CanUsePerson`, which checks on whether the `Person` context implements the consumer trait for `GreeterComponent`, i.e. `CanGreet`:

```rust
check_components! {
    CanUsePerson for Person {
        GreeterComponent,
    }
}
```

### Updated Chapter

For further details, the CGP book has been updated with a [new chapter](https://patterns.contextgeneric.dev/debugging-support.html) that explains in details on this improved debugging support.

## Rework `#[cgp_type]` Macro

The `cgp_type!` macro has been reworked in [#68](https://github.com/contextgeneric/cgp/pull/68) to become an attribute macro. Previously in v0.3.0, an abstract type was defined as:

```rust
cgp_type!( Name );
```

From v0.4.0 onward, the macro becomes an attribute macro that follows the same style as `#[cgp_component]`:

```rust
#[cgp_type]
pub trait HasNameType {
    type Name;
}
```

Although it is more verbose, the new syntax allows more advanced abstract types to be defined with the same macro, such as the ability to add generic parameters or supertraits on the type trait.

Aside from that, `#[cgp_type]` also generates default names following a different convention. When left empty, the provider trait would be named `"{Type}TypeProvider"` instead of `"Provide{Type}Type"`, and the component would be named `"{Type}TypeProviderComponent"` instead of `"{Type}TypeComponent"`.

So the example above is a short hand of writing:

```rust
#[cgp_type {
    name: NameTypeProviderComponent,
    provider: NameTypeProvider,
}]
pub trait HasNameType {
    type Name;
}
```

## `#[cgp_context]` Macro

A new `#[cgp_context]` macro has been introduced in [#66](https://github.com/contextgeneric/cgp/pull/66), and can be applied to context types to simplify the wiring of providers with a context. For example, given the following:

```rust
#[cgp_context]
pub struct Person {
    pub name: String
}
```

The macro would generate the context provider struct and the `HasCgpProvider` implementation, which was previously required to be hand-implemented manually:

```rust
pub struct PersonComponents;

impl HasCgpProvider for Person {
    type CgpProvider = PersonComponents;
}
```

The `HasCgpProvider` trait was previously called `HasComponents` in v0.3.0, and has been renamed in [#97](https://github.com/contextgeneric/cgp/pull/97) to better reflect its purpose.

Although the boilerplate reduction is minimal, the `#[cgp_context]` macro significantly reduces the aesthetic and psychological barrier of defining CGP contexts, and make them almost as trivial as defining plain structs.

Additionally, `#[cgp_context]` also brings support on _inheritance_ of a collection of providers in the form of _presets_, which we will cover in a moment.

## Improved Getter Macros

The getter macros `#[cgp_getter]` and `#[cgp_auto_getter]` have been enhanced with several improvements, making them more usable in broader use cases.

First of all, with [#81](https://github.com/contextgeneric/cgp/pull/81) and [#87](https://github.com/contextgeneric/cgp/pull/87) the macros are now more smart in handling several common special cases, such as the use of `&str` and `Option<&T>`. Below shows some examples of the new method signatures that are now supported:

```rust
// Can be used with `String` field
#[cgp_auto_getter]
pub trait HasName {
    fn name(&self) -> &str;
}

// Can be used with `Option<Self::Name>` field
#[cgp_auto_getter]
pub trait HasName: HasNameType {
    fn name(&self) -> Option<&Self::Name>;
}

// Can be used with `Vec<u8>` field
#[cgp_auto_getter]
pub trait HasBytes {
    fn bytes(&self) -> &[u8];
}
```

Additionally, with [#64](https://github.com/contextgeneric/cgp/pull/64) and [#76](https://github.com/contextgeneric/cgp/pull/76), the getter macros also support generic parameters, and accepts a second optional `PhantomData` argument to help with type inference. For example:

```rust
#[cgp_auto_getter]
pub trait HasName<App>
where
    App: HasNameType,
{
    fn name(&self, _tag: PhantomData<App>) -> &App::Name;
}
```

In [#94](https://github.com/contextgeneric/cgp/pull/94), we have also added support for using _getter combinators_ to implement more complex getters to access fields that are nested within other structs in a context. For example, the following code allows the getter for `listen_port` to be implemented via `context.config.network.listen_port`:

```rust
#[cgp_getter]
pub trait HasListenPort {
    fn listen_port(&self) -> &u16;
}

#[cgp_context(MyContextComponents)]
#[derive(HasField)]
pub struct MyContext {
    pub config: Config,
}

#[derive(HasField)]
pub struct Config {
    pub network: NetworkConfig,
}

#[derive(HasField)]
pub struct NetworkConfig {
    pub listen_port: u16,
}

delegate_components! {
    MyContextComponents {
        ListenPortGetterComponent:
            WithProvider<ChainGetters<Product! [
                UseField<symbol!("config")>,
                UseField<symbol!("network")>,
                UseField<symbol!("listen_port")>,
            ]>>
    }
}
```