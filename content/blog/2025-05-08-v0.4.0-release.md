+++

title = "CGP Updates: v0.4.0 Release with Improved Developer Experience"

description = "I'm excited to announce the release of v0.4.0 of the cgp crate, along significantly improved developer experience!"

authors = ["Soares Chen"]

+++

## Summary

It has been a while since the last update. I'm excited to announce the release of [`v0.4.0`](https://github.com/contextgeneric/cgp/releases/tag/v0.4.0) or the [`cgp`](https://docs.rs/cgp/0.4.0/cgp/), with tons of new features along with significantly improved developer experience!

This post hightlights the major updates that have been developed over the past few months, along with some personal updates.

## Improved Debugging

The most significant improvement in this update is that it is now significantly easier to debug CGP errors that arise from unsatisfied dependencies. [Previously](/blog/early-preview-announcement/#improve-error-diagnostics), this was the most significant challenge for CGP to gain wider adoption, as it was virtually impossible to debug CGP programs due to Rust hiding the necessary information. In this release, we have developed new techniques to overcome this challenge, and make Rust show all errors that were previously hidden.

### `IsProviderFor` Trait

In short, the technique works by introducing a new `IsProviderFor` trait in [#63](https://github.com/contextgeneric/cgp/pull/63), which is defined as follows:

```rust
pub trait IsProviderFor<Component, Context, Params = ()> {}
```

The `IsProviderFor` trait has nothing interesting, but is intended to be implemented by providers with additional constraints hidden within the trait implementation. The trait then acts as a "trait-erased" trait to carry around the constraints that the provider used to implement the original provider trait.

Users of CGP do not need to understand in details how `IsProviderFor` works, other than that it is used behind the scene by CGP to show better error messages.

### `#[cgp_provider]` Macro

The main change that is required for this to work is that users are now required to annotate CGP provider implementations using the `#[cgp_provider]` or `#[cgp_new_provider]` macros. For example:

```rust
#[cgp_new_provider]
impl<Context> Greeter<Context> for GreetHello
where
    Context: HasName,
{
    fn greet(context: &Context) {
        println!("Hello, {}!", context.name());
    }
}
```

The macro would then generate the following `IsProviderFor` implementation, which includes the `Context: HasName` constraint in it:

```rust
impl<Context> IsProviderFor<GreeterComponent, Context, ()>
    for GreetHello
where
    Context: HasName
{ }
```

The main difference between the `#[cgp_provider]` and `#[cgp_new_provider]` is that `#[cgp_new_provider]` also generates the provider struct definition, i.e. `struct GreetHello;`, allowing less code to be written by hand.

### `check_components!` Macro

Along with the `IsProviderFor` trait, [#78](https://github.com/contextgeneric/cgp/pull/78) also introduces the `check_components!` macro to allow users to write compile-time tests to check for the correctness of component wiring for a CGP context. For example, the following code generates a check trait called `CanUsePerson`, which checks on whether the `Person` context implements the consumer trait for `GreeterComponent`, i.e. `CanGreet`:

```rust
check_components! {
    CanUsePerson for Person {
        GreeterComponent,
    }
}
```

### Updated Chapter

For further details, the CGP book has been updated with a [new chapter](https://patterns.contextgeneric.dev/debugging-support.html) that explains in details on this improved debugging support.

## Rework `#[cgp_type]` Macro

The `cgp_type!` macro has been reworked in [#68](https://github.com/contextgeneric/cgp/pull/68) to become an attribute macro. Previously in v0.3.0, an abstract type was defined as:

```rust
cgp_type!( Name );
```

From v0.4.0 onward, the macro becomes an attribute macro that follows the same style as `#[cgp_component]`:

```rust
#[cgp_type]
pub trait HasNameType {
    type Name;
}
```

Although it is more verbose, the new syntax allows more advanced abstract types to be defined with the same macro, such as the ability to add generic parameters or supertraits on the type trait.

Aside from that, `#[cgp_type]` also generates default names following a different convention. When left empty, the provider trait would be named `"{Type}TypeProvider"` instead of `"Provide{Type}Type"`, and the component would be named `"{Type}TypeProviderComponent"` instead of `"{Type}TypeComponent"`.

So the example above is a short hand of writing:

```rust
#[cgp_type {
    name: NameTypeProviderComponent,
    provider: NameTypeProvider,
}]
pub trait HasNameType {
    type Name;
}
```

## `#[cgp_context]` Macro

A new `#[cgp_context]` macro has been introduced in [#66](https://github.com/contextgeneric/cgp/pull/66), and can be applied to context types to simplify the wiring of providers with a context. For example, given the following:

```rust
#[cgp_context]
pub struct Person {
    pub name: String
}
```

The macro would generate the context provider struct and the `HasCgpProvider` implementation, which was previously required to be hand-implemented manually:

```rust
pub struct PersonComponents;

impl HasCgpProvider for Person {
    type CgpProvider = PersonComponents;
}
```

The `HasCgpProvider` trait was previously called `HasComponents` in v0.3.0, and has been renamed in [#97](https://github.com/contextgeneric/cgp/pull/97) to better reflect its purpose.

Although the boilerplate reduction is minimal, the `#[cgp_context]` macro significantly reduces the aesthetic and psychological barrier of defining CGP contexts, and make them almost as trivial as defining plain structs.

Additionally, `#[cgp_context]` also brings support on _inheritance_ of a collection of providers in the form of _presets_, which we will cover in a moment.

## Improved Getter Macros

The getter macros `#[cgp_getter]` and `#[cgp_auto_getter]` have been enhanced with several improvements, making them more usable in broader use cases.

First of all, with [#81](https://github.com/contextgeneric/cgp/pull/81) and [#87](https://github.com/contextgeneric/cgp/pull/87) the macros are now more smart in handling several common special cases, such as the use of `&str` and `Option<&T>`. Below shows some examples of the new method signatures that are now supported:

```rust
// Can be used with `String` field
#[cgp_auto_getter]
pub trait HasName {
    fn name(&self) -> &str;
}

// Can be used with `Option<Self::Name>` field
#[cgp_auto_getter]
pub trait HasName: HasNameType {
    fn name(&self) -> Option<&Self::Name>;
}

// Can be used with `Vec<u8>` field
#[cgp_auto_getter]
pub trait HasBytes {
    fn bytes(&self) -> &[u8];
}
```

Additionally, with [#64](https://github.com/contextgeneric/cgp/pull/64) and [#76](https://github.com/contextgeneric/cgp/pull/76), the getter macros also support generic parameters, and accepts a second optional `PhantomData` argument to help with type inference. For example:

```rust
#[cgp_auto_getter]
pub trait HasName<App>
where
    App: HasNameType,
{
    fn name(&self, _tag: PhantomData<App>) -> &App::Name;
}
```

In [#94](https://github.com/contextgeneric/cgp/pull/94), we have also added support for using _getter combinators_ to implement more complex getters to access fields that are nested within other structs in a context. For example, the following code allows the getter for `listen_port` to be implemented via `context.config.network.listen_port`:

```rust
#[cgp_getter]
pub trait HasListenPort {
    fn listen_port(&self) -> &u16;
}

#[cgp_context(MyContextComponents)]
#[derive(HasField)]
pub struct MyContext {
    pub config: Config,
}

#[derive(HasField)]
pub struct Config {
    pub network: NetworkConfig,
}

#[derive(HasField)]
pub struct NetworkConfig {
    pub listen_port: u16,
}

delegate_components! {
    MyContextComponents {
        ListenPortGetterComponent:
            WithProvider<ChainGetters<Product! [
                UseField<symbol!("config")>,
                UseField<symbol!("network")>,
                UseField<symbol!("listen_port")>,
            ]>>
    }
}
```

## Initial Support for Datatype-Generic Programming

PR [#84](https://github.com/contextgeneric/cgp/pull/84) brings initial support for [datatype-generic proramming](https://wiki.haskell.org/Generics) to Rust and CGP. A new `#[derive(HasFields)]` macro has been introduced, together with the relevant traits `HasFields`, `HasFieldsRef`, `FromFields`, `ToFields`, and `ToFieldsRef`.

The constructs introduced make it possible for context-generic providers to access _all_ fields in a context struct or enum, without requiring access to the concrete types. This would enable context-generic implementations for use cases such as encodings to be implemented without requiring the concrete context to derive anything else other than `#[derive(HasFields)]`.

For example, given the following code:

```rust
#[derive(HasFields)]
pub struct Person {
    pub name: string,
    pub age: u8,
}
```

The derive macro would generate the following `HasField` implementation:

```rust
impl HasFields for Person {
    type Fields =
        Product! [
            Field<symbol!("name"), String>,
            Field<symbol!("age"), u64>,
        ];
}
```

The constructs introduced are currently incomplete, and future development is still needed to bring in the full capabilities for datatype-generic programming.

Additionally, [#85](https://github.com/contextgeneric/cgp/pull/85) introduces the use of Greek alphabets to shorten the type representation of field types. For example, given the macro:

```rust
Product! [
    Field<symbol!("name"), String>,
    Field<symbol!("age"), u8>,
]
```

The original expansion would be shown as follows in the IDE and error messages:

```rust
Cons<Field<Char<'n', Char<'a', Char<'m', Char<'e', Nil>>>>, String>, Cons<Field<Char<'a', Char<'g', Char<'e', Nil>>>, u8>, Nil>>
```

But with the new version, it would be shown in a shorter form as:

```rust
π<ω<ι<'n', ι<'a', ι<'m', ι<'e', ε>>>>, String>, π<ω<ι<'a', ι<'g', ι<'e', ε>>>, u8>, ε>>
```

Although this may look very confusing at first, hopefully it will become more readable once readers understand how each Greek alphabet are mapped to their full names.

## Presets and Inheritance

Another major feature introduced is a completely overhauled implementation of _presets_, over a number of major PRs. ([#70](https://github.com/contextgeneric/cgp/pull/70), [#71](https://github.com/contextgeneric/cgp/pull/71), [#72](https://github.com/contextgeneric/cgp/pull/72), [#91](https://github.com/contextgeneric/cgp/pull/91))

A proper full introduction to presets will require its own dedicated chapters written in the CGP book. But until that is written, I will show here a very high level walk through of what are CGP presets.

### Component Delegation as Type-Level Lookup Table

Conceptually, we can think of the use of `delegate_components!` being defining a key-value dictionary at the _type-level_, with the trait `DelegateComponent` serving as a type-level lookup function. In CGP, when we apply component wirings through `delegate_components!`, we are effectively building a type-level lookup table with the component name as the key, and the delegated provider as the value.

With that in mind, it becomes natural to think about whether it is possible to "merge" two of such tables, to form a new table. For example, given one crate containing:

```rust
delegate_components! {
    ComponentsA {
        KeyA: ValueA,
        KeyB: ValueB,
        KeyC: ValueC1,
    }
}
```

and another crate containing:

```rust
delegate_components! {
    ComponentsB {
        KeyC: ValueC2,
        KeyD: ValueD,
        KeyE: ValueE,
    }
}
```

How do we enable the merging of `ComponentsA` and `ComponentsB`, while also handle the cases of merging conflicting entries? In OOP, this merging operation is also commonly known as _inheritance_.

Unfortunately, the coherence restriction of Rust would not allow us to implement such merging operation using generics and blanket implementations. Instead, we have developed macro-based hacks to emulate such merging at the _syntactic_ level. The result is the development of the _preset_ system developed in this update.

### Preset Macros

CGP presets are made of extensible collection of key/value mappings, that can be inherited to form new mappings.
Instead of defining regular structs and build mappings with `delegate_components!`, presets are constructed as _modules_ using the `cgp_preset!` macro together with the `#[re_export_imports]`. For example, the same mappings earlier would be rewritten as:

```rust
#[cgp::re_export_imports]
mod preset {
    use crate_a::{KeyA, ...};
    use crate_b::{ValueA, ...};

    cgp_preset! {
        PresetA {
            KeyA: ValueA,
            KeyB: ValueB,
            KeyC: ValueC1,
        }
    }
}
```

The `#[cgp::re_export_imports]` macro is used over a surrogate `mod preset`, which wraps around the inner module to re-export the imports, so that they can be reused during the merging. This is required, because the merging works through macros, which do not have access to the actual type information. Aside from that, the macro re-exports all exports from the inner module, so that we can write regular code as if the `mod preset` modifier never existed.

The macro `cgp_preset!` works similar to `delegate_components!`, but it defines a new _inner module_ that contains the mapping struct, together with macros and re-exports to support the merging operation.

Similarly, the second preset would be re-written as:

```rust
#[cgp::re_export_imports]
mod preset {
    use crate_c::{KeyC, ...};
    use crate_d::{ValueD, ...};

    cgp_preset! {
        PresetB {
            KeyC: ValueC2,
            KeyD: ValueD,
            KeyE: ValueE,
        }
    }
}
```

To merge the two presets, we can define a new `PresetC` that _inherits_ from both `PresetA` and `PresetB` as follows:

```rust
#[cgp::re_export_imports]
mod preset {
    use preset_a::PresetA;
    use preset_b::PresetB;
    use crate_f::{KeyF, ...};

    cgp_preset! {
        PresetC: PresetA + PresetB {
            override KeyC: ValueC2,
            KeyF: ValueF,
        }
    }
}
```

As we can see, CGP supports _multiple inheritance_ for presets, by using macros to "copy" over the entries form the parent preset. To resolve conflicts or override entries from the parent presets, the `override` keyword can be used to exclude a given mapping to be copied over, and instead use the local definition. And since the underlying implementation still uses `DelegateComponent` to implement the lookup, any non-overridden conflicts would simply result in trait error over overlapping instances.

### Single Inheritance with Context Provider

CGP also supports single inheritance of presets to be used with CGP contexts. For example, the final `PresetC` can be used in a context by writing:

```rust
#[cgp_context(MyContextComponents: PresetC)]
pub struct MyContext {
    ...
}
```

The first optional argument to `#[cgp_context]` is the name of the new provider struct that is used to implement the wirings for the context. It is then followed by an optional `: ParentPreset` argument, which would inherit all entries from the parent preset.

Behind the scene, the single inheritance works through special traits defined in the preset module. As a result, it works with less quirks than the implementation of nested and multiple inheritance between presets. The reason two separate techniques are used is that the trait-based approach can only work with at most one level of inheritance, i.e. having a single parent with no further trait-based grandparents.

### Comparison with OOP Inheritance

The preset inheritance works very similarly to how inheritance is typically understood in OOP. However, there are several key differences that make CGP presets _not_ the same as implementing OOP in Rust.

First of all, presets only work as type-level lookup tables, with no ability to directly implement "methods" on the preset itself. Hence, it works more like protoypal inheritance in languages such as JavaScript. Furthermore, the lookup table only exists at the type level, meaning that it does not exist at runtime, and thus does not introduce any runtime overhead.

More importantly, CGP and Rust do not support the notion of subtyping. This means that two contexts that "inherit" from the same preset are treated as completely distinct types, and there is no mechanism to "upcast" the values to a common preset "parent type", which does not exist. This means that in constrast to OOP, CGP inheritance only exist at the "provider"-side for implementations, but not on the "consumer"-side for polymorphic consumption.