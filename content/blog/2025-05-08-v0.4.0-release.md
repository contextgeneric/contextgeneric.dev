+++

title = "CGP Updates: v0.4.0 Release with Major Improvements"

description = "I'm excited to announce the release of v0.4.0 of the cgp crate, along significantly improved developer experience!"

authors = ["Soares Chen"]

+++

## Summary

It has been a while since the last update. I'm excited to announce the release of [`v0.4.0`](https://github.com/contextgeneric/cgp/releases/tag/v0.4.0) or the [`cgp`](https://docs.rs/cgp/0.4.0/cgp/), packed with tons of new features along with significantly improved developer experience!

This post hightlights the major updates that have been developed over the past few months, along with some personal updates.

## Rework `#[cgp_type]` Macro

The `cgp_type!` macro has been reworked in [#68](https://github.com/contextgeneric/cgp/pull/68) to become an attribute macro. Previously in v0.3.0, an abstract type was defined as:

```rust
cgp_type!( Name );
```

From v0.4.0 onward, the macro becomes an attribute macro that follows the same style as `#[cgp_component]`:

```rust
#[cgp_type]
pub trait HasNameType {
    type Name;
}
```

Although it is more verbose, the new syntax allows more advanced abstract types to be defined with the same macro, such as the ability to add generic parameters or supertraits on the type trait.

Aside from that, `#[cgp_type]` also generates default names following a different convention. When left empty, the provider trait would be named `"{Type}TypeProvider"` instead of `"Provide{Type}Type"`, and the component would be named `"{Type}TypeProviderComponent"` instead of `"{Type}TypeComponent"`.

So the example above is a short hand of writing:

```rust
#[cgp_type {
    name: NameTypeProviderComponent,
    provider: NameTypeProvider,
}]
pub trait HasNameType {
    type Name;
}
```

## `#[cgp_context]` Macro

A new `#[cgp_context]` macro has been introduced in [#66](https://github.com/contextgeneric/cgp/pull/66), and can be applied to context types to simplify the wiring of providers with a context. For example, given the following:

```rust
#[cgp_context]
pub struct Person {
    pub name: String
}
```

The macro would generate the context provider struct and the `HasCgpProvider` implementation, which was previously required to be hand-implemented manually:

```rust
pub struct PersonComponents;

impl HasCgpProvider for Person {
    type CgpProvider = PersonComponents;
}
```

The `HasCgpProvider` trait was previously called `HasComponents` in v0.3.0, and has been renamed in [#97](https://github.com/contextgeneric/cgp/pull/97) to better reflect its purpose.

Although the boilerplate reduction is minimal, the `#[cgp_context]` macro significantly reduces the aesthetic and psychological barrier of defining CGP contexts, and make them almost as trivial as defining plain structs.

Additionally, `#[cgp_context]` also brings support on _inheritance_ of a collection of providers in the form of _presets_, which we will cover in a moment.

## Improved Getter Macros

The getter macros `#[cgp_getter]` and `#[cgp_auto_getter]` have been enhanced with several improvements, making them more usable in broader use cases.

First of all, with [#81](https://github.com/contextgeneric/cgp/pull/81) and [#87](https://github.com/contextgeneric/cgp/pull/87) the macros are now more smart in handling several common special cases, such as the use of `&str` and `Option<&T>`. Below shows some examples of the new method signatures that are now supported:

```rust
// Can be used with `String` field
#[cgp_auto_getter]
pub trait HasName {
    fn name(&self) -> &str;
}

// Can be used with `Option<Self::Name>` field
#[cgp_auto_getter]
pub trait HasName: HasNameType {
    fn name(&self) -> Option<&Self::Name>;
}

// Can be used with `Vec<u8>` field
#[cgp_auto_getter]
pub trait HasBytes {
    fn bytes(&self) -> &[u8];
}
```

Additionally, with [#64](https://github.com/contextgeneric/cgp/pull/64) and [#76](https://github.com/contextgeneric/cgp/pull/76), the getter macros also support generic parameters, and accepts a second optional `PhantomData` argument to help with type inference. For example:

```rust
#[cgp_auto_getter]
pub trait HasName<App>
where
    App: HasNameType,
{
    fn name(&self, _tag: PhantomData<App>) -> &App::Name;
}
```

In [#94](https://github.com/contextgeneric/cgp/pull/94), we have also added support for using _getter combinators_ to implement more complex getters to access fields that are nested within other structs in a context. For example, the following code allows the getter for `listen_port` to be implemented via `context.config.network.listen_port`:

```rust
#[cgp_getter]
pub trait HasListenPort {
    fn listen_port(&self) -> &u16;
}

#[cgp_context(MyContextComponents)]
#[derive(HasField)]
pub struct MyContext {
    pub config: Config,
}

#[derive(HasField)]
pub struct Config {
    pub network: NetworkConfig,
}

#[derive(HasField)]
pub struct NetworkConfig {
    pub listen_port: u16,
}

delegate_components! {
    MyContextComponents {
        ListenPortGetterComponent:
            WithProvider<ChainGetters<Product! [
                UseField<symbol!("config")>,
                UseField<symbol!("network")>,
                UseField<symbol!("listen_port")>,
            ]>>
    }
}
```

## Improved `#[cgp_component]` Macro

We have improved the UX for `#[cgp_component]` to allow the provider name to be specified directly, if there is no other parameters passed. For example, we can now write:

```rust
#[cgp_component(Greeter)]
pub trait CanGreet
{
    fn greet(&self);
}
```

instead of the original form:

```rust
#[cgp_component {
    provider: Greeter,
}]
pub trait CanGreet
{
    fn greet(&self);
}
```

which in turns is shortened from the fully-expanded form:

```rust
#[cgp_component {
    name: GreeterComponent,
    provider: Greeter,
    context: Context,
}]
pub trait CanGreet
{
    fn greet(&self);
}
```

Other than that, [#95](https://github.com/contextgeneric/cgp/pull/95) also bring support for using `const` items inside CGP traits. With that, we can for example define traits such as:

```rust
#[cgp_component(ConstantGetter)]
pub trait HasConstant {
    const CONSTANT: u64;
}
```

## Improved Debugging

The most significant improvement in this update is that it is now significantly easier to debug CGP errors that arise from unsatisfied dependencies. [Previously](/blog/early-preview-announcement/#improve-error-diagnostics), this was the most significant challenge for CGP to gain wider adoption, as it was virtually impossible to debug CGP programs due to Rust hiding the necessary information. In this release, we have developed new techniques to overcome this challenge, and make Rust show all errors that were previously hidden.

### `IsProviderFor` Trait

In short, the technique works by introducing a new `IsProviderFor` trait in [#63](https://github.com/contextgeneric/cgp/pull/63), which is defined as follows:

```rust
pub trait IsProviderFor<Component, Context, Params = ()> {}
```

The `IsProviderFor` trait has nothing interesting, but is intended to be implemented by providers with additional constraints hidden within the trait implementation. The trait then acts as a "trait-erased" trait to carry around the constraints that the provider used to implement the original provider trait.

Users of CGP do not need to understand in details how `IsProviderFor` works, other than that it is used behind the scene by CGP to show better error messages.

### `CanUseComponent` Trait

Along with `IsProviderFor`, a new `CanUseComponent` blanket trait is introduced as a short hand to check that a context's provider has implemented the `IsProviderFor` trait. It is defined as follows:

```rust
pub trait CanUseComponent<Component, Params = ()> {}

impl<Context, Component, Params> CanUseComponent<Component, Params> for Context
where
    Context: HasProvider,
    Context::Provider: IsProviderFor<Component, Context, Params>,
{
}
```

### `#[cgp_provider]` Macro

The main change that is required for this to work is that users are now required to annotate CGP provider implementations using the `#[cgp_provider]` or `#[cgp_new_provider]` macros. For example:

```rust
#[cgp_new_provider]
impl<Context> Greeter<Context> for GreetHello
where
    Context: HasName,
{
    fn greet(context: &Context) {
        println!("Hello, {}!", context.name());
    }
}
```

The macro would then generate the following `IsProviderFor` implementation, which includes the `Context: HasName` constraint in it:

```rust
impl<Context> IsProviderFor<GreeterComponent, Context, ()>
    for GreetHello
where
    Context: HasName
{ }
```

The main difference between the `#[cgp_provider]` and `#[cgp_new_provider]` is that `#[cgp_new_provider]` also generates the provider struct definition, i.e. `struct GreetHello;`, allowing less code to be written by hand.

### Update to `delegate_components!`

In addition to generating `DelegateComponent` implementation, `delegate_components!` now also generate `IsProviderFor` implementation, so that `IsProviderFor` can remain working across component delegations.

As an example, given the following:

```rust
delegate_components! {
    PersonComponents {
        GreeterComponent: GreetHello,
    }
}
```

would result in the following trait impls generated:

```rust
impl DelegateComponent<GreeterComponent> for PersonComponents {
    type Delegate = GreetHello;
}

impl<Context, Params> IsProviderFor<GreeterComponent, Context, Params>
    for PersonComponents
where
    GreetHello: IsProviderFor<GreeterComponent, Context, Params>,
{
}
```

### `check_components!` Macro

Along with the `IsProviderFor` trait, [#78](https://github.com/contextgeneric/cgp/pull/78) also introduces the `check_components!` macro to allow users to write compile-time tests to check for the correctness of component wiring for a CGP context. For example:

```rust
check_components! {
    CanUsePerson for Person {
        GreeterComponent,
    }
}
```

The code above generates a _check trait_ called `CanUsePerson`, which checks on whether the `Person` context implements the consumer trait for `GreeterComponent`, i.e. `CanGreet`:

```rust
trait CanUsePerson<Component, Params>: CanUseComponent<Component, Params> {}

impl CanUsePerson<GreeterComponent, ()> for Person {}
```

### `delegate_and_check_components!` Macro

PR [#84](https://github.com/contextgeneric/cgp/pull/84) introduces a new `delegate_and_check_components!` macro, which combines both `delegate_components!` and `check_components!`, and allows both delegation and checks to be done within the same macro call. This is useful for the majority of simple cases, which developers can now get immediate feedback on whether the wiring that they have implemented works as intended.

As an example, given the following code:

```rust
delegate_and_check_components! {
    CanUsePerson for Person;
    PersonComponents {
        GreeterComponent: GreetHello,
    }
}
```

is equivalent to writing the two separate macro calls:

```rust
delegate_components! {
    PersonComponents {
        GreeterComponent: GreetHello,
    }
}

check_components! {
    CanUsePerson for Person {
        GreeterComponent,
    }
}
```

It is worth noting that in more advanced cases, it may still be necessary to call `delegate_components!` and `check_components` separately. This would be necessary for cases where the CGP traits contain additional generic parameters, or when the new _preset_ feature (discussed later) is used.


### Updated Chapter

For further details, the CGP book has been updated with a [new chapter](https://patterns.contextgeneric.dev/debugging-support.html) that explains in details on this improved debugging support.

## Initial Support for Datatype-Generic Programming

PR [#84](https://github.com/contextgeneric/cgp/pull/84) brings initial support for [datatype-generic proramming](https://wiki.haskell.org/Generics) to Rust and CGP. A new `#[derive(HasFields)]` macro has been introduced, together with the relevant traits `HasFields`, `HasFieldsRef`, `FromFields`, `ToFields`, and `ToFieldsRef`.

The constructs introduced make it possible for context-generic providers to access _all_ fields in a context struct or enum, without requiring access to the concrete types. This would enable context-generic implementations for use cases such as encodings to be implemented without requiring the concrete context to derive anything else other than `#[derive(HasFields)]`.

For example, given the following code:

```rust
#[derive(HasFields)]
pub struct Person {
    pub name: string,
    pub age: u8,
}
```

The derive macro would generate the following `HasField` implementation:

```rust
impl HasFields for Person {
    type Fields =
        Product! [
            Field<symbol!("name"), String>,
            Field<symbol!("age"), u64>,
        ];
}
```

The constructs introduced are currently incomplete, and future development is still needed to bring in the full capabilities for datatype-generic programming.

Additionally, [#85](https://github.com/contextgeneric/cgp/pull/85) introduces the use of Greek alphabets to shorten the type representation of field types. For example, given the macro:

```rust
Product! [
    Field<symbol!("name"), String>,
    Field<symbol!("age"), u8>,
]
```

The original expansion would be shown as follows in the IDE and error messages:

```rust
Cons<Field<Char<'n', Char<'a', Char<'m', Char<'e', Nil>>>>, String>, Cons<Field<Char<'a', Char<'g', Char<'e', Nil>>>, u8>, Nil>>
```

But with the new version, it would be shown in a shorter form as:

```rust
π<ω<ι<'n', ι<'a', ι<'m', ι<'e', ε>>>>, String>, π<ω<ι<'a', ι<'g', ι<'e', ε>>>, u8>, ε>>
```

Although this may look very confusing at first, hopefully it will become more readable once readers understand how each Greek alphabet are mapped to their full names.

## Presets and Inheritance

Another major feature introduced is a completely overhauled implementation of _presets_, over a number of major PRs. ([#70](https://github.com/contextgeneric/cgp/pull/70), [#71](https://github.com/contextgeneric/cgp/pull/71), [#72](https://github.com/contextgeneric/cgp/pull/72), [#91](https://github.com/contextgeneric/cgp/pull/91))

A proper full introduction to presets will require its own dedicated chapters written in the CGP book. But until that is written, I will show here a very high level walk through of what are CGP presets.

### Component Delegation as Type-Level Lookup Table

Conceptually, we can think of the use of `delegate_components!` being defining a key-value dictionary at the _type-level_, with the trait `DelegateComponent` serving as a type-level lookup function. In CGP, when we apply component wirings through `delegate_components!`, we are effectively building a type-level lookup table with the component name as the key, and the delegated provider as the value.

With that in mind, it becomes natural to think about whether it is possible to "merge" two of such tables, to form a new table. For example, given one crate containing:

```rust
delegate_components! {
    ComponentsA {
        KeyA: ValueA,
        KeyB: ValueB,
        KeyC: ValueC1,
    }
}
```

and another crate containing:

```rust
delegate_components! {
    ComponentsB {
        KeyC: ValueC2,
        KeyD: ValueD,
        KeyE: ValueE,
    }
}
```

How do we enable the merging of `ComponentsA` and `ComponentsB`, while also handle the cases of merging conflicting entries? In OOP, this merging operation is also commonly known as _inheritance_.

Unfortunately, the coherence restriction of Rust would not allow us to implement such merging operation using generics and blanket implementations. Instead, we have developed macro-based hacks to emulate such merging at the _syntactic_ level. The result is the development of the _preset_ system developed in this update.

### Preset Macros

CGP presets are made of extensible collection of key/value mappings, that can be inherited to form new mappings.
Instead of defining regular structs and build mappings with `delegate_components!`, presets are constructed as _modules_ using the `cgp_preset!` macro together with the `#[re_export_imports]`. For example, the same mappings earlier would be rewritten as:

```rust
#[cgp::re_export_imports]
mod preset {
    use crate_a::{KeyA, ...};
    use crate_b::{ValueA, ...};

    cgp_preset! {
        PresetA {
            KeyA: ValueA,
            KeyB: ValueB,
            KeyC: ValueC1,
        }
    }
}
```

The `#[cgp::re_export_imports]` macro is used over a surrogate `mod preset`, which wraps around the inner module to re-export the imports, so that they can be reused during the merging. This is required, because the merging works through macros, which do not have access to the actual type information. Aside from that, the macro re-exports all exports from the inner module, so that we can write regular code as if the `mod preset` modifier never existed.

The macro `cgp_preset!` works similar to `delegate_components!`, but it defines a new _inner module_ that contains the mapping struct, together with macros and re-exports to support the merging operation.

Similarly, the second preset would be re-written as:

```rust
#[cgp::re_export_imports]
mod preset {
    use crate_c::{KeyC, ...};
    use crate_d::{ValueD, ...};

    cgp_preset! {
        PresetB {
            KeyC: ValueC2,
            KeyD: ValueD,
            KeyE: ValueE,
        }
    }
}
```

To merge the two presets, we can define a new `PresetC` that _inherits_ from both `PresetA` and `PresetB` as follows:

```rust
#[cgp::re_export_imports]
mod preset {
    use preset_a::PresetA;
    use preset_b::PresetB;
    use crate_f::{KeyF, ...};

    cgp_preset! {
        PresetC: PresetA + PresetB {
            override KeyC: ValueC2,
            KeyF: ValueF,
        }
    }
}
```

As we can see, CGP supports _multiple inheritance_ for presets, by using macros to "copy" over the entries form the parent preset. To resolve conflicts or override entries from the parent presets, the `override` keyword can be used to exclude a given mapping to be copied over, and instead use the local definition. And since the underlying implementation still uses `DelegateComponent` to implement the lookup, any non-overridden conflicts would simply result in trait error over overlapping instances.

### Single Inheritance with Context Provider

CGP also supports single inheritance of presets to be used with CGP contexts. For example, the final `PresetC` can be used in a context by writing:

```rust
#[cgp_context(MyContextComponents: PresetC)]
pub struct MyContext {
    ...
}
```

The first optional argument to `#[cgp_context]` is the name of the new provider struct that is used to implement the wirings for the context. It is then followed by an optional `: ParentPreset` argument, which would inherit all entries from the parent preset.

Behind the scene, the single inheritance works through special traits defined in the preset module. As a result, it works with less quirks than the implementation of nested and multiple inheritance between presets. The reason two separate techniques are used is that the trait-based approach can only work with at most one level of inheritance, i.e. having a single parent with no further trait-based grandparents.

### Comparison with OOP Inheritance

The preset inheritance works very similarly to how inheritance is typically understood in OOP. However, there are several key differences that make CGP presets _not_ the same as implementing OOP in Rust.

First of all, presets only work as type-level lookup tables, with no ability to directly implement "methods" on the preset itself. Hence, it works more like protoypal inheritance in languages such as JavaScript. Furthermore, the lookup table only exists at the type level, meaning that it does not exist at runtime, and thus does not introduce any runtime overhead.

More importantly, CGP and Rust do not support the notion of subtyping. This means that two contexts that "inherit" from the same preset are treated as completely distinct types, and there is no mechanism to "upcast" the values to a common preset "parent type", which does not exist. This means that in constrast to OOP, CGP inheritance only exist at the "provider"-side for implementations, but not on the "consumer"-side for polymorphic consumption.

## `Async` Trait Update

The `Async` trait was defined to be a trait alias to `Send + Sync + 'static`, to make it more easy for users to define abstract types that can be used within async functions that return `impl Future + Send`. However, practical experience has shown that the `'static` bound is not really needed in most cases, and thus removed by [#89](https://github.com/contextgeneric/cgp/pull/89) from the default recommended trait bound.

The removal of `'static` will make it easier to instantiate abstract types with concrete types that do not contain `'static` trait bound. On the other hand, the default inclusion of `Send + Sync` is almost a necessary evil with the current state of async Rust. However, this may soon change when Return Type Notation (RTN) gets stabilized in Rust in the near future in [rust#138424](https://github.com/rust-lang/rust/pull/138424). Once that is stabilized, the `Async` trait itself can entirely be deprecated or removed.

## `#[blanket_trait]` Macro

[#79](https://github.com/contextgeneric/cgp/pull/79) and [#82](https://github.com/contextgeneric/cgp/pull/82) introduces a new `#[blanket_trait]` macro, which can be used to define trait aliases that contain empty body and trivial blanket implementations.

Developers can use the `#[blanket_trait]` macro to define trait aliases, as well as abstract type aliases for more advanced cases. For example, given the following:

```rust
#[trait_alias]
pub trait HasAsyncErrorType: Async + HasErrorType<Error: Async> {}
```

would result in the following blanket implementation to be automatically generated:

```rust
impl<Context> HasAsyncErrorType for Context
where
    Context: Async + HasErrorType<Error: Async> {}
```

## Personal Updates

Aside from all the feature updates, I also have some personal updates related to the development of CGP.

### Persentation at Leipzig Rust Meetup

I have given a presentation of CGP at the [Leipzig Rust meetup](https://www.meetup.com/rust-modern-systems-programming-in-leipzig/events/303729528/) in February. Although there were no video recording, you can check out the [presentation slides](https://github.com/contextgeneric/cgp-presentations/blob/main/2025/cgp-leipzig-2025-02-18.pdf) if you are interested.

### Bank Transfer Example

Along with the meetup presentation, an example [bank transfer](https://github.com/contextgeneric/cgp-examples/tree/main/transfer) application has been drafted to demonstrate the use of CGP in practical applications. The example code is not yet sufficiently documented, but hopefully it can serve as a sneak preview for readers who would like to see more complex examples of CGP programs.

### More Active Development

It has been 4 months since our last update. It was proven to be challenging to manage a side project, while also juggling with a full time job plus child care without support from the grandparents. On the bright side, I have managed to get a short 3-month sabbatical from May to July, before changing to a new job.

During the next 3 months, you can expect to see much more active development from me to push CGP towards wider adoption. If you have suggestions on what should be developed during this time, or how I can make the project more sustainable, do let me know in the comments.

### Attending RustWeek

I will be attending [RustWeek](https://rustweek.org/) in person next week (May 13-17 2025). Although I did not manage to get a presentation slot, I would love to meet up with Rust developers and discuss about how CGP can be used to solve real world problem in their Rust applications.

If there are interests, I would also like to organize [Hackathon](https://rustweek.org/events/hackathon/) sessions during the last day to have coding sessions for CGP. Otherwise, I might look around and try to apply CGP on one of the Hackathon projects. If you have any suggestions, do let me know.

Lastly, if you read until this point and is attending RustWeek, do ping me on [BlueSky](https://bsky.app/profile/maybevoid.com) and I would love to chat with you.

Thank you for reading, and stay tuned for more updates on CGP!