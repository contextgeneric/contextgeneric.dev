+++

title = "CGP v0.4.1 Release"

description = ""

authors = ["Soares Chen"]

+++

# Draft

Following are the summary of each pull requests:

# Support wrapping of Preset::Provider inside cgp_preset! macro #103 

## Summary

This PR enables the user to specify a `#[wrap_provider]` attribute in the `cgp_preset!` macro, to wrap the `Preset::Provider` type around the wrapper type.

## Motivation

CGP presets can be used not just for wiring CGP components, but also to define extensible mappings to be used for generic dispatch through the `UseDelegate` pattern.

Without the provider wrapping, it becomes tedious to extend the non-provider mapping across multiple levels of preset inheritance. This is because the values in the maps are still expected to implement the provider trait, but the non-wrapped mapping type does not implement the provider trait.

With the wrapper, the `Preset::Provider` type would implement the expected provider trait through the wrapper, making it a valid delegation target when a child preset inherits from it.

## Example

Given the following preset definition:

```rust
cgp_preset! {
    #[wrap_provider(UseDelegate)]
    MyHandlerPreset {
        String: HandleString,
        u64: HandleU64,
        ...
    }
}
```

The macro would generate the following implementation:

```rust
pub mod MyHandlerPreset {
    ...

    pub type Provider = UseDelegate<Components>;

    delegate_components! {
        new Components {
            String: HandleString,
            u64: HandleU64,
            ...
        }
    }

    ...
}
```

#  Support derivation of UseDelegate inside #[cgp_component] #106 

## Summary

This PR introduces a new `derive_delegate` field for the `#[cgp_component]` family macros, allowing automated implementation of `UseDelegate` for CGP components.

## Example

The updated `ErrorRaiser` component is defined as follows:

```rust
#[cgp_component {
    provider: ErrorRaiser,
    derive_delegate: UseDelegate<SourceError>,
}]
pub trait CanRaiseError<SourceError>: HasErrorType {
    fn raise_error(error: SourceError) -> Self::Error;
}
```

which would derive the following `UseDelegate` implementation, which previously had to be implemented manually:

```rust
#[cgp_provider(ErrorRaiserComponent)]
impl<Context, SourceError, Components, Delegate> ErrorRaiser<Context, SourceError>
    for UseDelegate<Components>
where
    Context: HasErrorType,
    Components: DelegateComponent<SourceError, Delegate = Delegate>,
    Delegate: ErrorRaiser<Context, SourceError>,
{
    fn raise_error(e: SourceError) -> Context::Error {
        Delegate::raise_error(e)
    }
}
```

# Introduce new cgp-handler crate #105 

## Summary

This PR introduces a new `cgp-handler` crate, which offers abstract interfaces for defining components with common method signatures.

As a semi-unstable and non-essential crate, the `cgp-handler` crate is re-exported by `cgp-extra`, and is available from `cgp::extra::handler`

## `Handler`

The `Handler` component provides the most commonly used interface for performing asynchronous operations that may fail:

```rust
#[cgp_component(Handler)]
#[async_trait]
pub trait CanHandle<Code: Send, Input: Send>: HasAsyncErrorType {
    type Output: Send;

    async fn handle(
        &self,
        _tag: PhantomData<Code>,
        input: Input,
    ) -> Result<Self::Output, Self::Error>;
}
```

## `Computer`

The `Computer` component mirrors a pure function that takes some input, perform some computation, and produces an output.

```rust
#[cgp_component(Computer)]
pub trait CanCompute<Code, Input> {
    type Output;

    fn compute(&self, _tag: PhantomData<Code>, input: Input) -> Self::Output;
}
```

## `Producer`

The `Producer` component mirrors a global singleton function to produce an output value. It is useful to emulate global values that cannot be constructed through the `const` context in Rust, such as `String`.

```rust
#[cgp_component(Producer)]
pub trait CanProduce<Code> {
    type Output;

    fn produce(&self, _tag: PhantomData<Code>) -> Self::Output;
}
```

## `Code` Parameter

All the traits in `cgp-handler` contains a phantom `Code` parameter, that can be used for building type-level DSLs such as [Hypershell](https://github.com/contextgeneric/hypershell). They can also be used as type-level identifiers, can be used for dispatching for cases such as API handlers.

#  Minor improvements #107 

- Implement `UseInputDelegate` for `Handler`
- Implement `TryPromote`
- Use `__Self__` instead of `T` when deriving `Preset::IsPreset`
- Include trait bound identifiers in `Preset::components` re-export 