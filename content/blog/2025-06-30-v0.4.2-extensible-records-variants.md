+++

title = "Unleashing extensible records and variants in Rust with CGP v0.4.2"

description = ""

authors = ["Soares Chen"]

+++

# Overview

I am pleased to announce the release of CGP v0.4.2! This new release of CGP brings a huge milestone accomplishment that enables CGP to be used with much more diverse use cases. In particular, CGP now brings full support on the use of **extensible records and variants** in Rust.

In short, extensible records and variants makes it possible to write generic code that works with _any structs containing certain fields, or any enums containing certain variants_.

Previously, CGP already have limited support for extensible records, with the `HasField` trait allowing the reading a field value from any struct that contains the given field. But the new release comes with the full support of also _building_ or _constructing_ field values, as well as supporting the same extensibilty for enums.

This feature unlocks two new proramming patterns that can be used with CGP: The **builder pattern** supports modular composition of multiple independent builder components to construct or build a struct. And the **dispatcher pattern** supports multiple independent handler components to _deconstruct_ or match on an enum.

For readers from other programming language background, what this means is that CGP has managed to bring in features equivalent to [row polymorphism](https://book.purescript.org/chapter4.html) and [polymorphic variants](https://ocaml.org/manual/5.1/polyvariant.html) to Rust. Additionally, CGP also now supports safe upcasting and downcasting between two enum types that contain compatible variants.

# Table of Contents

In this post, we will go through a high level overview of each feature introduced, together with some practical examples of how they can be used.

# Safe Enum Upcasting

Supposed that we have the following `FooBarBaz` enum:

```rust
#[derive(HasFields, ExtractField, FromVariant)]
pub enum FooBarBaz {
    Foo(u64),
    Bar(String),
    Baz(bool),
}
```

and a different `FooBar` enum that contains a subset of variants of `FooBarBaz`:

```rust
#[derive(HasFields, ExtractField, FromVariant)]
pub enum FooBar {
    Foo(u64),
    Bar(String),
}
```

CGP now supports upcasting of a `FooBar` value to a `FooBarBaz` value as follows:

```rust
let foo_bar: FooBar = FooBar::Foo(1);
let foo_bar_baz: FooBarBaz = foo_bar.upcast(PhantomData::<FooBarBaz>);
assert_eq!(foo_bar_baz, FooBarBaz::Foo(1));
```

The upcasting operation is done fully in safe Rust, and the only requirement is to derive the relevant CGP traits `HasFields`, `ExtractField`, and `FromVariant` on the enum. After that, for any source enum whose variants are a subset of the target enum, we would be possible to perform upcasting on it.

The two enums can be defined in completely different crates, without being aware of each other. The CGP traits derived on the enums are general and can be applicable to all other enums. In other words, there is no need to derive traits that are specific to a certain enum for the upcasting to work.

# Safe Enum Downcasting

Similar to upcasting, we can also use the derived CGP traits to perform safe downcasting of an enum to a different enum that contains _subset_ of the variants.

With the same example enums as before, we can downcast a `FooBarBaz` into `FooBar` as follows:

```rust
let foo_bar_baz: FooBarBaz = FooBarBaz::Bar("hello".to_owned());
let foo_bar: Result<FooBar, _> = foo_bar_baz.downcast(PhantomData::<FooBar>);
assert_eq!(foo_bar.ok(), Some(FooBar::Foo(1)));
```

Similar to `upcast`, the `downcast` method can be used for any two enums that derive the relevant CGP traits, with compatible variants. The method returns a `Result`, with the "remainder" of the enum returned in the `Err` case if the downcasting is not successful. In the assertion, we use `.ok()` to convert the `Result` into an option, as the remainder does not implement `Debug` or `Debug`, which is required when used with `assert_eq!`.

## Safe Exhaustive Downcasting

A key feature provided by CGP downcasting is that it is possible to exhaustively downcast an enum until all variants are handled. We will see how this is done in action with the earlier example.

After we attempt to downcast `FooBarBaz` to `FooBar`, the only variant left that is not yet handled is `Baz`. To handle that, we can define a separate `Baz` enum that contains the `Baz` variant as follows:

```rust
#[derive(HasFields, ExtractField, FromVariant)]
pub enum Baz {
    Baz(bool),
}
```

The combination of `FooBar` and `Baz` covers all possible variants in `FooBarBaz`. So with that, we can exhaustively downcast `FooBarBaz`, and safely return a result for each case such as:

```rust
let foo_bar_baz: FooBarBaz = FooBarBaz::Foo(1);

let result: String = match foo_bar_baz.downcast(PhantomData::<FooBar>) {
    Ok(foo_bar) => {
        format!("downcasted to FooBar: {:?}", foo_bar)
    }
    Err(remainder) => match remainder.downcast_fields(PhantomData::<Baz>) {
        Ok(baz) => {
            format!("downcasted to Baz: {:?}", baz)
        }
        Err(remainder) => remainder.finalize_extract(),
    },
};
```

In the example, we first try to downcast `FooBarBaz` into `FooBar`, and if that fails, we use `downcast_fields` on the _remainder_ to try and downcast it again into `Baz`. Finally, when all variants have been extracted, we can call `finalize_extract` on the _final remainder_ to assert that the case can never be reach.

Compared to `downcast`, the `downcast_fields` method is provided for "partial" enums, i.e. an intermediary enum that "contains" only the unextracted variants. Similarly, the `finalize_extract` method can be used on "empty" enums, i.e. an intermediary enum that has all variants extracted, which is equivalent to the [never](https://doc.rust-lang.org/reference/types/never.html) type. The operations are all **panic-free** and done in **safe** Rust.

In the example, it may not seem obvious why the nested downcasting is needed, when we can simply perform a `match` on the concrete `FooBarBaz` enum. But as we will see later, the main power we get from this is being able to "match" on a **generic** enum type, without needing to have access to the concrete types.

# Safe Struct Building

Similar to enum downcasting, CGP also brings the same extensibilty to structs by "merging" one struct into a bigger struct that contains additional fields. This is used for supporting modular _building_ of a struct, by breaking down its construction into smaller steps.

To demonstrate this, suppose that we have `FooBarBaz` which is now defined as a _struct_ as follows:

```rust
#[derive(HasFields, BuildField)]
pub struct FooBarBaz {
    pub foo: u64,
    pub bar: String,
    pub baz: bool,
}
```

And if we have two smaller structs `FooBar` and `FooBaz`:

```rust
#[derive(HasFields, BuildField)]
pub struct FooBar {
    pub foo: u64,
    pub bar: String,
}

#[derive(HasFields, BuildField)]
pub struct Baz {
    pub baz: bool,
}
```

We can now construct `FooBarBaz` by first constructing `FooBar` and `Baz`, and then merge them into a **builder** to construct the final `FooBarBaz` struct as follows:

```rust
let foo_bar = FooBar {
    foo: 1,
    bar: "bar".to_owned(),
};

let baz = Baz { baz: true };

let foo_bar_baz: FooBarBaz = FooBarBaz::builder()
    .build_from(foo_bar)
    .build_from(baz)
    .finalize_build();
```

Compared to the enum example, the `FooBarBaz` struct provides a `builder` method that returns a _builder_, i.e. a "partial" struct that only has some of the fields set. The builder provides a `build_from` method, which accepts any other struct that contains any fields that have not yet been filled into the builder, and returns a new builder that has those fields filled in. Finally, once all fields in a builder is set, the `finalize_build` method can be used to convert the builder into the target struct.

Similar to extensible variants, the struct builder implementation is done completely in **safe** and **panic-free** Rust. The only requirement is to have the structs to have compatible fields and derive the CGP `HasFields` and `BuildField` traits. The structs can all live in different crates, and there is no need to derive macros specific to a given struct.

The example we presented here may look superfluous, as one could as easily construct a `FooBarBaz` value directly without using the builder. However, as we will see in the later sections, the builder enables us to implement and **compose** code that can build **generic** structs without needing to access the concrete types.