+++

title = "Unleashing Extensible Records and Variants in Rust with CGP v0.4.2"

description = ""

authors = ["Soares Chen"]

+++

# Overview

I’m excited to announce the release of **CGP v0.4.2**, a major milestone that significantly expands the expressive power of generic programming in Rust. With this release, CGP introduces full support for **extensible records and variants**, unlocking a range of new capabilities for developers working with highly modular and reusable code.

Extensible records and variants allow developers to write code that operates on *any struct containing specific fields* or *any enum containing specific variants*, regardless of their complete definition. This makes it possible to write truly generic and flexible logic that is decoupled from rigid type definitions.

In earlier versions, CGP already offered a foundational feature through the `HasField` trait, which made it possible to *read* a field from any struct that included it. With version 0.4.2, this functionality is dramatically extended. Not only can you now read fields, but you can also *construct* values onto these fields in a type-safe manner. More importantly, the same level of extensibility is now available for enums, enabling operations over variants in a similarly generic fashion.

This advancement introduces two powerful programming patterns that are now possible with CGP:

1. **Modular Builder Pattern**: This pattern allows for modular construction of structs from independent sub-structs, each contributing specific fields. It enables highly composable and decoupled design in data construction.

2. **Modular Visitor Pattern**: This pattern enables the modular deconstruction of enums, allowing independent components to handle different variants without requiring full knowledge of the entire enum definition. This effectively enables a modularized version of the _visitor pattern_, by allowing new variants to be handled by extensible visitors.

For readers coming from more advanced programming languages, this development effectively brings the power of [structural typing](https://en.wikipedia.org/wiki/Structural_type_system), [row polymorphism](https://book.purescript.org/chapter4.html) and [polymorphic variants](https://ocaml.org/manual/5.1/polyvariant.html) to Rust. These are advanced type system features commonly found in languages like PureScript and OCaml, and their availability in CGP represents a major leap in what is possible with the type system in Rust.

In addition, CGP v0.4.2 introduces support for safe **upcasting and downcasting between enums** that share a common subset of variants. This provides a foundation for writing extensible and evolvable APIs that remain compatible across different layers of abstraction or across independently maintained modules.

# Table of Contents

In this post, we will go through a high level overview of each feature introduced, together with some practical examples of how they can be used.


# Safe Enum Upcasting

Let’s begin by looking at how CGP enables safe upcasting between enums. Imagine you have the following enum definition:

```rust
#[derive(HasFields, ExtractField, FromVariant)]
pub enum FooBarBaz {
    Foo(u64),
    Bar(String),
    Baz(bool),
}
```

You may also have a different enum, defined elsewhere, that represents only a subset of the variants:

```rust
#[derive(HasFields, ExtractField, FromVariant)]
pub enum FooBar {
    Foo(u64),
    Bar(String),
}
```

With CGP v0.4.2, it is now possible to *upcast* a `FooBar` value into a `FooBarBaz` value in fully safe Rust:

```rust
let foo_bar: FooBar = FooBar::Foo(1);
let foo_bar_baz: FooBarBaz = foo_bar.upcast(PhantomData::<FooBarBaz>);
assert_eq!(foo_bar_baz, FooBarBaz::Foo(1));
```

This operation works by leveraging the derived CGP traits `HasFields`, `ExtractField`, and `FromVariant`. As long as the source enum’s variants are a subset of the target enum’s, CGP can automatically generate the logic required to lift the smaller enum into the larger one.

A particularly powerful aspect of this design is that the two enums do not need to know about each other. They can be defined in entirely separate crates, and the trait derivations are completely general. You don’t need to define any enum-specific conversion traits. This makes it possible to build libraries of reusable variant groups and compose them freely in application code.

# Safe Enum Downcasting

In the reverse direction, CGP also supports *safe downcasting* from a larger enum to a smaller one that contains only a subset of its variants. Using the same `FooBarBaz` and `FooBar` enums, the following example demonstrates how this works:

```rust
let foo_bar_baz: FooBarBaz = FooBarBaz::Bar("hello".to_owned());
let foo_bar: Result<FooBar, _> = foo_bar_baz.downcast(PhantomData::<FooBar>);
assert_eq!(foo_bar.ok(), Some(FooBar::Bar("hello".to_owned())));
```

Like `upcast`, this `downcast` method relies on the same set of derived CGP traits and works for any pair of compatible enums. The operation returns a `Result`, where the `Ok` variant contains the downcasted value, and the `Err` variant carries the unhandled remainder of the original enum.

In the example above, we use `.ok()` to simplify the comparison, but in practice, the `Err` case contains useful data that can be further examined or downcasted again, which leads us to one of the most innovative aspects of CGP’s enum handling.

## Safe Exhaustive Downcasting

One of the unique capabilities CGP provides is the ability to *exhaustively downcast* an enum, step by step, until all possible variants are handled. This pattern becomes especially useful when working with generic enums in extensible APIs, where the concrete enum definition is unknown or evolving.

To demonstrate this, suppose we define another enum to represent the remaining `Baz` variant:

```rust
#[derive(HasFields, ExtractField, FromVariant)]
pub enum Baz {
    Baz(bool),
}
```

Now, the combination of `FooBar` and `Baz` covers the entire set of variants from `FooBarBaz`. We can use this setup to exhaustively handle all possible cases, while staying entirely within the bounds of safe Rust:

```rust
let foo_bar_baz: FooBarBaz = FooBarBaz::Foo(1);

let result: String = match foo_bar_baz.downcast(PhantomData::<FooBar>) {
    Ok(foo_bar) => {
        format!("downcasted to FooBar: {:?}", foo_bar)
    }
    Err(remainder) => match remainder.downcast_fields(PhantomData::<Baz>) {
        Ok(baz) => {
            format!("downcasted to Baz: {:?}", baz)
        }
        Err(remainder) => remainder.finalize_extract(),
    },
};
```

In this example, we first attempt to downcast into `FooBar`. If that fails, the remainder is passed to `downcast_fields`, which attempts to extract the `Baz` variant. Finally, if all known variants have been handled and nothing remains, we call `finalize_extract`, which is only valid on an "empty" enum. This indicates that all variants have been successfully matched, and the code is guaranteed to be exhaustive.

The `downcast_fields` method is intended for intermediary or "partial" enums that contain only the unhandled variants, while `finalize_extract` is used when no variants are left. This closely models the behavior of Rust’s `!` (never) type and ensures that every path in your code is covered without panics or unsafe code.

At first glance, this approach may appear more complex than simply matching against the original enum directly. However, its true strength lies in its **generality**. With CGP’s downcasting mechanism, you can pattern match over generic enum types without knowing their full structure in advance. This enables highly extensible and type-safe designs where variants can be added or removed modularly, without breaking existing logic.


# Safe Struct Building

Just as CGP enables safe, composable deconstruction of enums, it also brings **extensible construction** to structs. This is achieved through a form of structural merging, where smaller structs can be incrementally combined into larger ones. The result is a flexible and modular approach to building complex data types, well-suited for highly decoupled or plugin-style architectures.

To illustrate this, let’s take the example of a `FooBarBaz` struct:

```rust
#[derive(HasFields, BuildField)]
pub struct FooBarBaz {
    pub foo: u64,
    pub bar: String,
    pub baz: bool,
}
```

Suppose we also define two smaller structs—`FooBar` and `Baz`—each containing a subset of the fields in `FooBarBaz`:

```rust
#[derive(HasFields, BuildField)]
pub struct FooBar {
    pub foo: u64,
    pub bar: String,
}

#[derive(HasFields, BuildField)]
pub struct Baz {
    pub baz: bool,
}
```

With CGP, we can now construct a `FooBarBaz` value in a modular and extensible way, by composing these smaller building blocks:

```rust
let foo_bar = FooBar {
    foo: 1,
    bar: "bar".to_owned(),
};

let baz = Baz { baz: true };

let foo_bar_baz: FooBarBaz = FooBarBaz::builder()
    .build_from(foo_bar)
    .build_from(baz)
    .finalize_build();
```

Here’s what’s happening: The `builder()` method on `FooBarBaz` initiates a *partial builder*, an intermediate structure that initially contains none of the target fields. Each call to `build_from` takes a struct that contributes one or more of the remaining fields and returns a new builder with those fields filled in. Once all required fields have been supplied, the `finalize_build()` method consumes the builder and produces a fully constructed `FooBarBaz` instance.

Just like enum upcasting and downcasting, the struct builder is implemented entirely in **safe**, **panic-free** Rust. There’s no runtime reflection or unsafe code involved. The only requirement is that the participating structs must have compatible fields and derive the CGP-provided traits `HasFields` and `BuildField`.

Moreover, this system is completely decoupled from specific struct definitions. The individual component structs—`FooBar`, `Baz`, and `FooBarBaz`—can be defined in separate crates, with no awareness of each other. Once the CGP traits are derived, they become interoperable through structural field compatibility alone.

While this example may seem trivial—after all, constructing `FooBarBaz` directly is straightforward—it serves as a foundation for much more powerful generic abstractions. As you’ll see in the upcoming sections, the builder pattern opens the door to writing highly reusable, type-safe logic that can construct **generic structs** without ever referencing their concrete types. This makes it possible to write libraries or plugins that contribute data to a shared structure without tight coupling or dependency on a central type definition.

# Modular Builder Example

To understand how extensible records enable modular builders, let’s explore a practical use case: constructing an application context from configuration inputs.

Imagine we’re building an API client for our application. The application context needs to include an SQLite database connection and an HTTP client. A typical way to model this in Rust would be to define a struct like the following:

```rust
#[cgp_context]
pub struct App {
    pub sqlite_pool: SqlitePool,
    pub http_client: Client,
}
```

This `App` struct holds a [`SqlitePool`](https://docs.rs/sqlx/latest/sqlx/sqlite/type.SqlitePool.html) from the `sqlx` crate, and an HTTP [`Client`](https://docs.rs/reqwest/latest/reqwest/struct.Client.html) from `reqwest`. To construct this context, we might implement a `new` function as follows:

```rust
impl App {
    pub async fn new(db_path: &str) -> Result<Self, Error> {
        let http_client = Client::new();
        let sqlite_pool = SqlitePool::connect(db_path).await?;

        Ok(Self {
            http_client,
            sqlite_pool,
        })
    }
}
```

This constructor is asynchronous and returns a `Result<App, Error>`. It creates a default `Client` using `reqwest`, connects to the database using the provided path, and assembles both into an `App` struct.

## Adding AI Capabilities to `App`

At this point, the constructor looks simple. But in a real-world setting, it’s rarely that clean. Suppose the product team now wants to integrate AI capabilities into the application. To support this, we decide to use an LLM service like ChatGPT and extend the `App` struct accordingly:

```rust
#[cgp_context]
pub struct App {
    pub sqlite_pool: SqlitePool,
    pub http_client: Client,
    pub open_ai_client: openai::Client,
    pub open_ai_agent: Agent<openai::CompletionModel>,
}
```

In this updated version, we introduce two new fields: `open_ai_client`, which is used to communicate with the OpenAI API, and `open_ai_agent`, which encapsulates a configured agent that can perform conversational tasks using a model like GPT-4o.

The `new` constructor must now also handle the initialization logic for these fields:

```rust
impl App {
    pub async fn new(db_path: &str) -> Result<Self, Error> {
        let http_client = Client::new();
        let sqlite_pool = SqlitePool::connect(db_path).await?;
        let open_ai_client = openai::Client::from_env();
        let open_ai_agent = open_ai_client.agent("gpt-4o").build();

        Ok(Self {
            http_client,
            sqlite_pool,
            open_ai_client,
            open_ai_agent,
        })
    }
}
```

Here, we initialize the OpenAI client using environment variables, and then build an agent configured for the `gpt-4o` model. These values are added alongside the existing HTTP and database clients.

## From Simple to Complex

Even with these additions, our constructor remains relatively manageable. However, as often happens in production, the requirements grow—and so does the configuration logic. Let’s imagine a more realistic version of this `new` function:

```rust
impl App {
    pub async fn new(
        db_options: &str,
        db_journal_mode: &str,
        http_user_agent: &str,
        open_ai_key: &str,
        open_ai_model: &str,
        llm_preamble: &str,
    ) -> Result<Self, Error> {
        let journal_mode = SqliteJournalMode::from_str(db_journal_mode)?;

        let db_options = SqliteConnectOptions::from_str(db_options)?.journal_mode(journal_mode);

        let sqlite_pool = SqlitePool::connect_with(db_options).await?;

        let http_client = Client::builder()
            .user_agent(http_user_agent)
            .connect_timeout(Duration::from_secs(5))
            .build()?;

        let open_ai_client = openai::Client::new(open_ai_key);
        let open_ai_agent = open_ai_client
            .agent(open_ai_model)
            .preamble(llm_preamble)
            .build();

        Ok(Self {
            open_ai_client,
            open_ai_agent,
            sqlite_pool,
            http_client,
        })
    }
}
```

This constructor now handles five separate input parameters, each contributing to the configuration of different parts of the application. It creates a `SqliteConnectOptions` object to configure the database with the specified journal mode. The HTTP client is set up with a custom user agent and a longer timeout. The AI client is initialized using an explicit API key, and the agent is constructed with a custom model and preamble.

While none of these steps are especially difficult on their own, the function is starting to grow in complexity. It’s also becoming more fragile, as all responsibilities are bundled into one place. Every change to a single subsystem—whether it’s database, HTTP, or AI—requires editing the same constructor.

This is exactly the kind of problem extensible struct builders can help solve. In the next section, we will see how CGP allows each subsystem to define its own builder component independently. With this approach, we can modularize the construction logic, reduce tight coupling, and compose the final `App` struct without writing a monolithic constructor function.

## Why Modular Constructor Matters

As we've seen in the previous example, even modest configurability can cause a constructor's complexity to grow rapidly. With just a few additional fields or customization options, the function becomes harder to maintain, test, and reason about.

In many cases, there's no single “correct” way to construct an application context. For example, you might want to retain both versions of the `new` constructor from earlier: a minimal one for unit tests with default values, and a more elaborate, configurable one for production. In fact, it's common for different parts of an application to require different levels of configurability—some using defaults, others requiring fine-grained setup.

To manage this complexity, Rust developers often reach for the [*builder pattern*](https://rust-unofficial.github.io/patterns/patterns/creational/builder.html). This involves creating a separate builder struct, typically with optional or defaultable fields and fluent setter methods. The builder is used to gradually assemble values before producing the final struct.

## Challenges for Modular Builders

The traditional builder pattern works, but it comes with serious limitations—especially when extensibility and modularity are important.

The first limitation is **tight coupling**. A builder is usually tied directly to a specific struct. If you create a new context that’s only slightly different from an existing one, you often have to duplicate the entire builder implementation, even if most of the logic is the same.

Second, builders are typically **non-extensible**. If you want to extend the construction logic—say, by adding a new step to initialize an additional field—you usually have to modify the original builder struct. This makes it hard to share construction logic across crates or teams without exposing internal implementation details.

The root cause of these problems is that struct construction in Rust typically requires direct access to the **concrete type**. That means the builder must know the exact shape of the final struct and have access to all its field values up front. If you need intermediate values or want to plug in custom build steps, those values must be manually threaded through the builder and its state.

This rigidity makes it difficult to define reusable, composable building blocks—especially in large or evolving codebases.

## Modular Builders with CGP

Earlier versions of CGP also ran into these limitations. When writing *context-generic* code, we wanted to construct structs in a way that didn’t require knowing their concrete types ahead of time. But because Rust structs require all field values to be present simultaneously at construction time, we couldn’t easily implement flexible or reusable context-generic constructors.

With the latest release, that limitation is fully resolved.

CGP now supports **modular, extensible struct builders** that can be composed from smaller, independent parts. Each module can define how to build a piece of a context struct, and the builder automatically merges them—without needing to know the final shape of the struct ahead of time.

This opens the door to a new style of constructor logic: one that is **modular**, **composable**, and **context-generic**. You can define builders for individual subsystems (e.g., database, HTTP client, AI agent), and combine them to build any compatible application context.

In the next section, we’ll revisit the constructor examples we’ve already seen—and show how to rewrite them using CGP’s new builder pattern to achieve clean, modular, and reusable construction logic.
## A Modular SQLite Builder

Let’s now explore how to implement modular construction of the `App` context using multiple CGP providers. We’ll start by defining a default SQLite builder provider using CGP's `Handler` component:

```rust
#[cgp_new_provider]
impl<Build, Code: Send, Input: Send> Handler<Build, Code, Input> for BuildDefaultSqliteClient
where
    Build: HasSqlitePath + CanRaiseAsyncError<sqlx::Error>,
{
    type Output = SqliteClient;

    async fn handle(
        build: &Build,
        _code: PhantomData<Code>,
        _input: Input,
    ) -> Result<Self::Output, Build::Error> {
        let sqlite_pool = SqlitePool::connect(build.db_path())
            .await
            .map_err(Build::raise_error)?;

        Ok(SqliteClient { sqlite_pool })
    }
}
```

In this example, we define `BuildDefaultSqliteClient` as a CGP provider that implements the `Handler` component. This is the same `Handler` trait we introduced in [Hypershell](/blog/hypershell-release/#handler-component), where it was used to power shell-like pipelines. Here, we repurpose the same trait to construct modular context components. This demonstrates how general-purpose the `Handler` trait is—it can be used for pipelines, API endpoints, matchers, and now, context builders.

The `Build` type parameter refers to a generic **builder context**, not the final `App` struct. This context includes the inputs required to construct a `SqliteClient`. In this case, the builder must be able to provide a database path, as well as a way to raise errors from `sqlx`. These requirements are expressed through the `HasSqlitePath` and `CanRaiseAsyncError<sqlx::Error>` constraints.

The `HasSqlitePath` trait is defined as follows:

```rust
#[cgp_auto_getter]
pub trait HasSqlitePath {
    fn db_path(&self) -> &str;
}
```

By marking the trait with [`#[cgp_auto_getter]`](https://patterns.contextgeneric.dev/generic-accessor-providers.html#the-cgp_auto_getter-macro), CGP can automatically implement this trait for any builder context that contains a `db_path` field of type `String`. This automatic implementation reduces boilerplate and ensures that any context with the appropriate fields can satisfy the trait bounds.

Although our example does not make use of the `Code` or `Input` parameters, they remain part of the `Handler` signature. The `Code` parameter may be used for compile-time options that allow contexts to be constructed in multiple ways. Meanwhile, `Input` typically refers to the **partial** value of the final struct being built. These capabilities are useful in more advanced scenarios, but we will leave their explanation for a later section.

In this implementation, the `handle` method simply connects to the SQLite database using the provided path, wraps the resulting pool in a `SqliteClient` struct, and returns it. The `SqliteClient` is defined as:

```rust
#[derive(HasField, HasFields, BuildField)]
pub struct SqliteClient {
    pub sqlite_pool: SqlitePool,
}
```

This struct acts as a wrapper around `SqlitePool` and serves as the output of our modular builder. Although `BuildDefaultSqliteClient` does not build the full `App` context, we can merge its output into `App` using CGP’s `build_from` mechanism we covered earlier. Deriving `HasField`, `HasFields`, and `BuildField` on `SqliteClient` allows it to be safely and automatically merged into the final context during composition.

At this point, you might be wondering why so much infrastructure is needed just to call `SqlitePool::connect`. The answer is that, while this example is simple, real-world construction logic can be much more complex. By encapsulating each part of the logic into modular components, we gain flexibility, reusability, and testability.

To demonstrate this flexibility, consider a more complex version of the SQLite builder. This version uses connection options and journal mode configuration rather than a simple path string:

```rust
#[cgp_new_provider]
impl<Build, Code: Send, Input: Send> Handler<Build, Code, Input> for BuildSqliteClient
where
    Build: HasSqliteOptions + CanRaiseAsyncError<sqlx::Error>,
{
    type Output = SqliteClient;

    async fn handle(
        build: &Build,
        _code: PhantomData<Code>,
        _input: Input,
    ) -> Result<Self::Output, Build::Error> {
        let journal_mode =
            SqliteJournalMode::from_str(build.db_journal_mode()).map_err(Build::raise_error)?;

        let db_options = SqliteConnectOptions::from_str(build.db_options())
            .map_err(Build::raise_error)?
            .journal_mode(journal_mode);

        let sqlite_pool = SqlitePool::connect_with(db_options)
            .await
            .map_err(Build::raise_error)?;

        Ok(SqliteClient { sqlite_pool })
    }
}

#[cgp_auto_getter]
pub trait HasSqliteOptions {
    fn db_options(&self) -> &str;

    fn db_journal_mode(&self) -> &str;
}
```

In this version, `BuildSqliteClient` constructs a `SqliteClient` using fully configurable connection options. The `Build` context must now implement `HasSqliteOptions`, a trait that provides both the connection URI and the desired journal mode.

This example illustrates the key advantage of modular builders: the builder logic is entirely **decoupled** from the context itself. If we want to use `BuildDefaultSqliteClient`, we can define a simple builder context with just a `db_path` field. If we switch to `BuildSqliteClient`, we only need to provide a different context that includes `db_options` and `db_journal_mode`. All other components of the builder can remain unchanged.

Thanks to this decoupling, we can easily swap in different builder providers depending on the needs of the environment — be it development, testing, or production — without rewriting the entire construction logic. This modularity makes CGP builders highly scalable and adaptable to real-world applications.

## HTTP Client Builder

Just as we modularized the construction of the SQLite client, we can also define a modular builder for an HTTP client using CGP. In this case, we will construct a custom `reqwest` client with specific configuration options. To keep the focus on advanced use cases, we will skip the simpler version and go directly to the more complex construction logic.

The HTTP client builder is implemented as follows:

```rust
#[cgp_new_provider]
impl<Build, Code: Send, Input: Send> Handler<Build, Code, Input> for BuildHttpClient
where
    Build: HasHttpClientConfig + CanRaiseAsyncError<reqwest::Error>,
{
    type Output = HttpClient;

    async fn handle(
        build: &Build,
        _code: PhantomData<Code>,
        _input: Input,
    ) -> Result<Self::Output, Build::Error> {
        let http_client = Client::builder()
            .user_agent(build.http_user_agent())
            .connect_timeout(Duration::from_secs(5))
            .build()
            .map_err(Build::raise_error)?;

        Ok(HttpClient { http_client })
    }
}
```

This provider, `BuildHttpClient`, is structured very similarly to `BuildSqliteClient`. It implements the `Handler` trait and defines `HttpClient` as its output. The `Build` context is required to implement two traits: `HasHttpClientConfig`, which supplies the necessary configuration values, and `CanRaiseAsyncError<reqwest::Error>`, which allows the context to convert `reqwest` errors into its own error type.

The required configuration is minimal. In this case, we only need a user agent string, which is defined through the following trait:

```rust
#[cgp_auto_getter]
pub trait HasHttpClientConfig {
    fn http_user_agent(&self) -> &str;
}
```

As with the previous examples, the `#[cgp_auto_getter]` macro ensures that this trait is automatically implemented for any context that includes a `http_user_agent` field. This allows us to easily reuse the same trait across multiple builder contexts without having to write additional code.

The output of this builder is a simple wrapper around `reqwest::Client`:

```rust
#[derive(HasField, HasFields, BuildField)]
pub struct HttpClient {
    pub http_client: Client,
}
```

Here again, we derive `HasField`, `HasFields`, and `BuildField` to support field merging into the final context later on. This makes the `HttpClient` output compatible with CGP’s `build_from` mechanism, allowing it to be composed with other builder outputs.

The `handle` method creates a new `reqwest::Client` using the client builder from `reqwest`. It sets the user agent using a value from the context, and specifies a connection timeout of five seconds. The constructed client is then wrapped in the `HttpClient` struct and returned.

Although this example remains relatively simple, it illustrates how each field or component in a context can be modularly constructed using dedicated builder logic. Each builder is independently defined, type-safe, and reusable. If the way we configure our HTTP client changes — for example, if we want to support proxies or TLS settings — we can define a new provider that implements a different construction strategy, without needing to change any of the other components in our application context.

This modularity provides a scalable, maintainable way to construct rich application contexts from independently developed and composable building blocks.

## Combined SQLite and HTTP Client Builder

Before we move on, it is important to emphasize that CGP does **not** require you to break down the construction logic of every component in your application context into separate builders. While the modular approach can offer more flexibility and reuse, you are entirely free to combine multiple construction tasks into a single provider if that better suits your needs.

For example, here is how you might implement a single builder that constructs both the SQLite client and the HTTP client together:

```rust
#[cgp_new_provider]
impl<Build, Code: Send, Input: Send> Handler<Build, Code, Input> for BuildDefaultSqliteAndHttpClient
where
    Build: HasSqlitePath + CanRaiseAsyncError<sqlx::Error>,
{
    type Output = SqliteAndHttpClient;

    async fn handle(
        build: &Build,
        _code: PhantomData<Code>,
        _input: Input,
    ) -> Result<Self::Output, Build::Error> {
        let sqlite_pool = SqlitePool::connect(build.db_path())
            .await
            .map_err(Build::raise_error)?;

        let http_client = Client::new();

        Ok(SqliteAndHttpClient { sqlite_pool, http_client })
    }
}

#[derive(HasField, HasFields, BuildField)]
pub struct SqliteAndHttpClient {
    pub sqlite_pool: SqlitePool,
    pub http_client: Client,
}
```

In this implementation, we define a single provider `BuildDefaultSqliteAndHttpClient` that returns a combined struct `SqliteAndHttpClient`, which contains both a `SqlitePool` and a `reqwest::Client`. The construction logic is written in one place, which can be convenient when these components are always used together or when their configuration is tightly integrated.

However, the tradeoff of this approach is that it reduces flexibility. This tight coupling can limit reuse and make future changes more difficult.

That said, the choice of whether to combine or separate builders is entirely up to you. CGP does not impose any rules on how you structure your builder logic. It provides the tools to compose and reuse components where helpful, but it leaves design decisions to the developer.

For the remainder of this article, we will continue to use the fully modular approach, breaking construction logic down into smaller, independent units. Our goal is to illustrate the full extent of flexibility and reusability that CGP enables. However, if you prefer a different organizational structure, you are free to structure your builders in whatever way best suits your project.

## ChatGPT Client Builder

Regardless of whether you prefer to split or combine the construction of components such as the SQLite and HTTP clients, there are many situations where it makes sense to separate construction logic into smaller, more focused units. For instance, you might want to offer two versions of your application — one standard version and one "pro" version that includes AI capabilities. In such cases, it is useful to define a separate builder provider for the ChatGPT client, so that AI-related logic can be included only when necessary.

The implementation for the ChatGPT client builder follows the same general pattern as the previous builders. It is defined as follows:

```rust
#[cgp_new_provider]
impl<Build, Code: Send, Input: Send> Handler<Build, Code, Input> for BuildOpenAiClient
where
    Build: HasOpenAiConfig + HasAsyncErrorType,
{
    type Output = OpenAiClient;

    async fn handle(
        build: &Build,
        _code: PhantomData<Code>,
        _input: Input,
    ) -> Result<Self::Output, Build::Error> {
        let open_ai_client = openai::Client::new(build.open_ai_key());
        let open_ai_agent = open_ai_client
            .agent(build.open_ai_model())
            .preamble(build.llm_preamble())
            .build();

        Ok(OpenAiClient {
            open_ai_client,
            open_ai_agent,
        })
    }
}
```

This builder requires the `Build` context to provide three string fields: the OpenAI API key, the model name, and a custom preamble string. These requirements are captured by the `HasOpenAiConfig` trait:

```rust
#[cgp_auto_getter]
pub trait HasOpenAiConfig {
    fn open_ai_key(&self) -> &str;

    fn open_ai_model(&self) -> &str;

    fn llm_preamble(&self) -> &str;
}
```

As with the other providers, we use the `#[cgp_auto_getter]` macro to automatically generate trait implementations, as long as the builder context contains the corresponding fields and derives `HasField`.

The `BuildOpenAiClient` provider returns an `OpenAiClient` struct that wraps two values: the low-level `openai::Client` and the higher-level `Agent` configured with the specified model and preamble.

```rust
#[derive(HasField, HasFields, BuildField)]
pub struct OpenAiClient {
    pub open_ai_client: openai::Client,
    pub open_ai_agent: Agent<openai::CompletionModel>,
}
```

By defining this logic in a standalone builder provider, we can easily opt in or out of ChatGPT support in our application context. This modular approach keeps the design flexible and makes it easier to extend or modify individual components without disrupting the overall system.

## Builder Context

With all three example builder providers implemented, we can now look at how we can define a builder context that uses the providers to build `App` for us. In fact, the builder context can be implemented easily with only few lines of code as follows:

```rust
#[cgp_context]
#[derive(HasField, Deserialize)]
pub struct FullAppBuilder {
    pub db_options: String,
    pub db_journal_mode: String,
    pub http_user_agent: String,
    pub open_ai_key: String,
    pub open_ai_model: String,
    pub llm_preamble: String,
}

delegate_components! {
    FullAppBuilderComponents {
        ErrorTypeProviderComponent:
            UseAnyhowError,
        ErrorRaiserComponent:
            RaiseAnyhowError,
        HandlerComponent:
            BuildAndMergeOutputs<
                App,
                Product![
                    BuildSqliteClient,
                    BuildHttpClient,
                    BuildOpenAiClient,
                ]>,
    }
}
```

We first define a `FullAppBuilder` struct containing all fields that are required by our builder providers. We use `#[cgp_context]` to turn it into a CGP context, and derives `HasField` so that the `#[cgp_auto_getter]` traits get automatically implemented. We also derive `Deserialize` in this example, to demonstrate that we can load `FullAppBuilder` directly from a config file with a serialization scheme such as JSON or TOML.

We then use `delegate_components!` to wire up the provider of the context, `FullAppBuilderComponents`, with the providers that we want to use. First, we choose to use `anyhow::Error` to handle any build errors, using the providers from `cgp-anyhow-error`. The `UseAnyhowError` provider sets the abstract error type to `anyhow::Error`. The `RaiseAnyhowError` provider can be used to convert any error type that implements `core::error::Error` into `anyhow::Error`, such as `sqlx::Error` and `reqwest::Error`.

Finally, for `HandlerComponent` we make use of a **builder dispatcher** called `BuildAndMergeOutputs` to combine all builder providers to build the application context for us. The first argument to `BuildAndMergeOutputs`, `App`, specifies that we want to build `App` as the final result. Following that, we use `Product!` to pass in a _type-level list_ of builder providers that would be used together to build `App`. Inside the list, we pass in `BuildSqliteClient`, `BuildHttpClient`, and `BuildOpenAiClient` that we have defined earlier.

With everything in place, we can now build `App` using the custom `FullAppBuilder` that we have defined, by simply filling in the configuration values and call `handle`:

```rust
async fn main() -> Result<(), Error> {
    let builder = FullAppBuilder {
        db_options: "file:./db.sqlite".to_owned(),
        db_journal_mode: "WAL".to_owned(),
        http_user_agent: "SUPER_AI_AGENT".to_owned(),
        open_ai_key: "1234567890".to_owned(),
        open_ai_model: "gpt-4o".to_owned(),
        llm_preamble: "You are a helpful assistant".to_owned(),
    };

    let app = builder.handle(PhantomData::<()>, ()).await?;

    /* Call methods on the app here */

    Ok(())
}
```

For our implementation of `Handler`, we can pass call `builder.handle` with any `Code` or `Input` type. This is because the type parameters are not used for the given example, and so there is no constraint on what can be used. For our demo, we just use the unit type `()`, making it equivalent to calling just `builder.handle()`.