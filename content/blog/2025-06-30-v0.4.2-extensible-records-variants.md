+++

title = "Unleashing extensible records and variants in Rust with CGP v0.4.2"

description = ""

authors = ["Soares Chen"]

+++

# Overview

I am pleased to announce the release of CGP v0.4.2! This new release of CGP brings a huge milestone accomplishment that enables CGP to be used with much more diverse use cases. In particular, CGP now brings full support on the use of **extensible records and variants** in Rust.

In short, extensible records and variants makes it possible to write generic code that works with _any structs containing certain fields, or any enums containing certain variants_.

Previously, CGP already have limited support for extensible records, with the `HasField` trait allowing the reading a field value from any struct that contains the given field. But the new release comes with the full support of also _building_ or _constructing_ field values, as well as supporting the same extensibilty for enums.

This feature unlocks two new proramming patterns that can be used with CGP: The **builder pattern** supports modular composition of multiple independent builder components to construct or build a struct. And the **dispatcher pattern** supports multiple independent handler components to _deconstruct_ or match on an enum.

For readers from other programming language background, what this means is that CGP has managed to bring in features equivalent to [row polymorphism](https://book.purescript.org/chapter4.html) and [polymorphic variants](https://ocaml.org/manual/5.1/polyvariant.html) to Rust. Additionally, CGP also now supports safe upcasting and downcasting between two enum types that contain compatible variants.

# Table of Contents

In this post, we will go through a high level overview of each feature introduced, together with some practical examples of how they can be used.

# Safe Enum Upcasting

Supposed that we have the following `FooBarBaz` enum:

```rust
#[derive(HasFields, ExtractField, FromVariant)]
pub enum FooBarBaz {
    Foo(u64),
    Bar(String),
    Baz(bool),
}
```

and a different `FooBar` enum that contains a subset of variants of `FooBarBaz`:

```rust
#[derive(HasFields, ExtractField, FromVariant)]
pub enum FooBar {
    Foo(u64),
    Bar(String),
}
```

CGP now supports upcasting of a `FooBar` value to a `FooBarBaz` value as follows:

```rust
let foo_bar: FooBar = FooBar::Foo(1);
let foo_bar_baz: FooBarBaz = foo_bar.upcast(PhantomData::<FooBarBaz>);
assert_eq!(foo_bar_baz, FooBarBaz::Foo(1));
```

The upcasting operation is done fully in safe Rust, and the only requirement is to derive the relevant CGP traits `HasFields`, `ExtractField`, and `FromVariant` on the enum. After that, for any source enum whose variants are a subset of the target enum, we would be possible to perform upcasting on it.

The two enums can be defined in completely different crates, without being aware of each other. The CGP traits derived on the enums are general and can be applicable to all other enums. In other words, there is no need to derive traits that are specific to a certain enum for the upcasting to work.

# Safe Enum Downcasting

Similar to upcasting, we can also use the derived CGP traits to perform safe downcasting of an enum to a different enum that contains _subset_ of the variants.

With the same example enums as before, we can downcast a `FooBarBaz` into `FooBar` as follows:

```rust
let foo_bar_baz: FooBarBaz = FooBarBaz::Bar("hello".to_owned());
let foo_bar: Result<FooBar, _> = foo_bar_baz.downcast(PhantomData::<FooBar>);
assert_eq!(foo_bar.ok(), Some(FooBar::Foo(1)));
```

Similar to `upcast`, the `downcast` method can be used for any two enums that derive the relevant CGP traits, with compatible variants. The method returns a `Result`, with the "remainder" of the enum returned in the `Err` case if the downcasting is not successful. In the assertion, we use `.ok()` to convert the `Result` into an option, as the remainder does not implement `Debug` or `Debug`, which is required when used with `assert_eq!`.

## Safe Exhaustive Downcasting

A key feature provided by CGP downcasting is that it is possible to exhaustively downcast an enum until all variants are handled. We will see how this is done in action with the earlier example.

After we attempt to downcast `FooBarBaz` to `FooBar`, the only variant left that is not yet handled is `Baz`. To handle that, we can define a separate `Baz` enum that contains the `Baz` variant as follows:

```rust
#[derive(HasFields, ExtractField, FromVariant)]
pub enum Baz {
    Baz(bool),
}
```

The combination of `FooBar` and `Baz` covers all possible variants in `FooBarBaz`. So with that, we can exhaustively downcast `FooBarBaz`, and safely return a result for each case such as:

```rust
let foo_bar_baz: FooBarBaz = FooBarBaz::Foo(1);

let result: String = match foo_bar_baz.downcast(PhantomData::<FooBar>) {
    Ok(foo_bar) => {
        format!("downcasted to FooBar: {:?}", foo_bar)
    }
    Err(remainder) => match remainder.downcast_fields(PhantomData::<Baz>) {
        Ok(baz) => {
            format!("downcasted to Baz: {:?}", baz)
        }
        Err(remainder) => remainder.finalize_extract(),
    },
};
```

In the example, we first try to downcast `FooBarBaz` into `FooBar`, and if that fails, we use `downcast_fields` on the _remainder_ to try and downcast it again into `Baz`. Finally, when all variants have been extracted, we can call `finalize_extract` on the _final remainder_ to assert that the case can never be reach.

Compared to `downcast`, the `downcast_fields` method is provided for "partial" enums, i.e. an intermediary enum that "contains" only the unextracted variants. Similarly, the `finalize_extract` method can be used on "empty" enums, i.e. an intermediary enum that has all variants extracted, which is equivalent to the [never](https://doc.rust-lang.org/reference/types/never.html) type. The operations are all **panic-free** and done in **safe** Rust.

In the example, it may not seem obvious why the nested downcasting is needed, when we can simply perform a `match` on the concrete `FooBarBaz` enum. But as we will see later, the main power we get from this is being able to "match" on a **generic** enum type, without needing to have access to the concrete types.

# Safe Struct Building

Similar to enum downcasting, CGP also brings the same extensibilty to structs by "merging" one struct into a bigger struct that contains additional fields. This is used for supporting modular _building_ of a struct, by breaking down its construction into smaller steps.

To demonstrate this, suppose that we have `FooBarBaz` which is now defined as a _struct_ as follows:

```rust
#[derive(HasFields, BuildField)]
pub struct FooBarBaz {
    pub foo: u64,
    pub bar: String,
    pub baz: bool,
}
```

And if we have two smaller structs `FooBar` and `FooBaz`:

```rust
#[derive(HasFields, BuildField)]
pub struct FooBar {
    pub foo: u64,
    pub bar: String,
}

#[derive(HasFields, BuildField)]
pub struct Baz {
    pub baz: bool,
}
```

We can now construct `FooBarBaz` by first constructing `FooBar` and `Baz`, and then merge them into a **builder** to construct the final `FooBarBaz` struct as follows:

```rust
let foo_bar = FooBar {
    foo: 1,
    bar: "bar".to_owned(),
};

let baz = Baz { baz: true };

let foo_bar_baz: FooBarBaz = FooBarBaz::builder()
    .build_from(foo_bar)
    .build_from(baz)
    .finalize_build();
```

Compared to the enum example, the `FooBarBaz` struct provides a `builder` method that returns a _builder_, i.e. a "partial" struct that only has some of the fields set. The builder provides a `build_from` method, which accepts any other struct that contains any fields that have not yet been filled into the builder, and returns a new builder that has those fields filled in. Finally, once all fields in a builder is set, the `finalize_build` method can be used to convert the builder into the target struct.

Similar to extensible variants, the struct builder implementation is done completely in **safe** and **panic-free** Rust. The only requirement is to have the structs to have compatible fields and derive the CGP `HasFields` and `BuildField` traits. The structs can all live in different crates, and there is no need to derive macros specific to a given struct.

The example we presented here may look superfluous, as one could as easily construct a `FooBarBaz` value directly without using the builder. However, as we will see in the later sections, the builder enables us to implement and **compose** code that can build **generic** structs without needing to access the concrete types.

# Config Loading Example

To understand how extensible records can help us implement modular builders, we will look at a practical example of building an application context from a config.

Suppose that we want to build an API client for our application, we may want the application context to hold an SQLite database connection and a HTTP client. We would define our application struct as follows:

```rust
#[cgp_context]
pub struct App {
    pub sqlite_pool: SqlitePool,
    pub http_client: Client,
}
```

Our `App` context contains a [`SqlitePool`](https://docs.rs/sqlx/latest/sqlx/sqlite/type.SqlitePool.html) provided by `sqlx`, and a HTTP [`Client`](https://docs.rs/reqwest/latest/reqwest/struct.Client.html) provided by `reqwest`. To build `App`, we may define a _constructor_ function `new` such as follows:

```rust
impl App {
    pub async fn new(
        db_path: &str,
    ) -> Result<Self, Error> {
        let http_client = Client::new();
        let sqlite_pool = SqlitePool::connect(db_path).await?;

        Ok(Self {
            http_client,
            sqlite_pool,
        })
    }
}
```

Our constructor is an async function that accepts a string path to the SQLite database, and returns a `Result<Self>`. Inside the construtor, we use `Client::new()` to construct a default `reqwest` client. Following that, we use `SqlitePool::connect` to load the database from the specified path. When the database loading is successful, we construct our `App` struct with the results and return it.

## Adding AI to `App`

The example constructor function we have defined look very simple. However in real world applications, an `App` struct may contain many fields with complicated initialization logic. To give unfamiliar readers a sense of the complexity, let's say the CEO of our company now asks us to include AI capabilities to our application. To do that, we would choose an LLM provider such as ChatGPT, and include the AI client in our application context:

```rust
#[cgp_context]
pub struct App {
    pub sqlite_pool: SqlitePool,
    pub http_client: Client,
    pub open_ai_client: openai::Client,
    pub open_ai_agent: Agent<openai::CompletionModel>,
}
```

For this example, we opt to use the [OpenAI client](https://docs.rs/rig-core/latest/rig/providers/openai/index.html) provided by `rig` to interact with ChatGPT. With the new fields added to `App`, We also introduce an `Agent` field to the app, to use an AI agent that is empowered by ChatGPT.

we now also need to update the `new` function with logic on how to build the OpenAI client, such as follows:

```rust
impl App {
    pub async fn new(db_path: &str) -> Result<Self, Error> {
        let http_client = Client::new();
        let sqlite_pool = SqlitePool::connect(db_path).await?;
        let open_ai_client = openai::Client::from_env();
        let open_ai_agent = open_ai_client.agent("gpt-4o").build();

        Ok(Self {
            http_client,
            sqlite_pool,
            open_ai_client,
            open_ai_agent,
        })
    }
```

In our example constructor, we use `Client::from_env` to construct a ChatGPT client from the environment variables. Following that, we use the `agent` method to construct a `gpt-4o` agent. With the client and agent values constructed, we add them to the new fields in `App` to be returned.

## Complex Constructors

Up to this point, our example constructor still looks pretty minimal. But in real world applications, the construction of field values may involve more complicated logic, which can increase the complexity of the constructor function pretty quickly. As an example, a production-ready constructor for `App` may look something like follows:

```rust
impl App {
    pub async fn new(
        db_options: &str,
        http_user_agent: &str,
        open_ai_key: &str,
        open_ai_model: &str,
        llm_preamble: &str,
    ) -> Result<Self, Error> {
        let db_options = SqliteConnectOptions::from_str(db_options)?
            .journal_mode(SqliteJournalMode::Wal);

        let sqlite_pool = SqlitePool::connect_with(db_options).await?;

        let http_client = Client::builder()
            .user_agent(http_user_agent)
            .connect_timeout(Duration::from_secs(5))
            .build()?;

        let open_ai_client = openai::Client::new(open_ai_key);

        let open_ai_agent = open_ai_client
            .agent(open_ai_model)
            .preamble(llm_preamble)
            .build();

        Ok(Self {
            open_ai_client,
            open_ai_agent,
            sqlite_pool,
            http_client,
        })
    }
}
```

Our new constructor now looks much more complicated before. Instead of a database filepath, the function accepts an [SQLite URI](https://www.sqlite.org/uri.html) string to construct the database with additional configuration. The HTTP client is also configured with a longer connection timeout and a custom user agent, which may be overridden by the user. The ChatGPT client is now configured with an explicit API key. The agent can now be configured with different models and initialized with a custom preamble.

## Why Modular Constructor Matters

As we can see with the example, when we want to make the construction of our application context slightly more configurable, the complexity of the constructor can increase very quickly. If we add a few more fields to `App` with a few more ways to configure it, the complexity can quickly become unmanageable.