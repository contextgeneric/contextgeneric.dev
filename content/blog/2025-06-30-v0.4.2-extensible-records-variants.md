+++

title = "Unleashing Extensible Records and Variants in Rust with CGP v0.4.2"

description = ""

authors = ["Soares Chen"]

+++

# Overview

I’m excited to announce the release of **CGP v0.4.2**, a major milestone that significantly expands the expressive power of generic programming in Rust. With this release, CGP introduces full support for **extensible records and variants**, unlocking a range of new capabilities for developers working with highly modular and reusable code.

Extensible records and variants allow developers to write code that operates on *any struct containing specific fields* or *any enum containing specific variants*, regardless of their complete definition. This makes it possible to write truly generic and flexible logic that is decoupled from rigid type definitions.

In earlier versions, CGP already offered a foundational feature through the `HasField` trait, which made it possible to *read* a field from any struct that included it. With version 0.4.2, this functionality is dramatically extended. Not only can you now read fields, but you can also *construct* values onto these fields in a type-safe manner. More importantly, the same level of extensibility is now available for enums, enabling operations over variants in a similarly generic fashion.

This advancement introduces two powerful programming patterns that are now possible with CGP:

1. **The Builder Pattern**: This pattern allows for modular construction of structs from independent sub-structs, each contributing specific fields. It enables highly composable and decoupled design in data construction.

2. **The Matcher Pattern**: This pattern enables the modular deconstruction of enums, allowing independent components to handle different variants without requiring full knowledge of the entire enum definition. This effectively enables a modularized version of the _visitor pattern_, by allowing new variants to be handled by extensible visitors.

For readers coming from more advanced programming languages, this development effectively brings the power of [structural typing](https://en.wikipedia.org/wiki/Structural_type_system), [row polymorphism](https://book.purescript.org/chapter4.html) and [polymorphic variants](https://ocaml.org/manual/5.1/polyvariant.html) to Rust. These are advanced type system features commonly found in languages like PureScript and OCaml, and their availability in CGP represents a major leap in what is possible with the type system in Rust.

In addition, CGP v0.4.2 introduces support for safe **upcasting and downcasting between enums** that share a common subset of variants. This provides a foundation for writing extensible and evolvable APIs that remain compatible across different layers of abstraction or across independently maintained modules.

# Table of Contents

In this post, we will go through a high level overview of each feature introduced, together with some practical examples of how they can be used.


# Safe Enum Upcasting

Let’s begin by looking at how CGP enables safe upcasting between enums. Imagine you have the following enum definition:

```rust
#[derive(HasFields, ExtractField, FromVariant)]
pub enum FooBarBaz {
    Foo(u64),
    Bar(String),
    Baz(bool),
}
```

You may also have a different enum, defined elsewhere, that represents only a subset of the variants:

```rust
#[derive(HasFields, ExtractField, FromVariant)]
pub enum FooBar {
    Foo(u64),
    Bar(String),
}
```

With CGP v0.4.2, it is now possible to *upcast* a `FooBar` value into a `FooBarBaz` value in fully safe Rust:

```rust
let foo_bar: FooBar = FooBar::Foo(1);
let foo_bar_baz: FooBarBaz = foo_bar.upcast(PhantomData::<FooBarBaz>);
assert_eq!(foo_bar_baz, FooBarBaz::Foo(1));
```

This operation works by leveraging the derived CGP traits `HasFields`, `ExtractField`, and `FromVariant`. As long as the source enum’s variants are a subset of the target enum’s, CGP can automatically generate the logic required to lift the smaller enum into the larger one.

A particularly powerful aspect of this design is that the two enums do not need to know about each other. They can be defined in entirely separate crates, and the trait derivations are completely general. You don’t need to define any enum-specific conversion traits. This makes it possible to build libraries of reusable variant groups and compose them freely in application code.

# Safe Enum Downcasting

In the reverse direction, CGP also supports *safe downcasting* from a larger enum to a smaller one that contains only a subset of its variants. Using the same `FooBarBaz` and `FooBar` enums, the following example demonstrates how this works:

```rust
let foo_bar_baz: FooBarBaz = FooBarBaz::Bar("hello".to_owned());
let foo_bar: Result<FooBar, _> = foo_bar_baz.downcast(PhantomData::<FooBar>);
assert_eq!(foo_bar.ok(), Some(FooBar::Bar("hello".to_owned())));
```

Like `upcast`, this `downcast` method relies on the same set of derived CGP traits and works for any pair of compatible enums. The operation returns a `Result`, where the `Ok` variant contains the downcasted value, and the `Err` variant carries the unhandled remainder of the original enum.

In the example above, we use `.ok()` to simplify the comparison, but in practice, the `Err` case contains useful data that can be further examined or downcasted again, which leads us to one of the most innovative aspects of CGP’s enum handling.

## Safe Exhaustive Downcasting

One of the unique capabilities CGP provides is the ability to *exhaustively downcast* an enum, step by step, until all possible variants are handled. This pattern becomes especially useful when working with generic enums in extensible APIs, where the concrete enum definition is unknown or evolving.

To demonstrate this, suppose we define another enum to represent the remaining `Baz` variant:

```rust
#[derive(HasFields, ExtractField, FromVariant)]
pub enum Baz {
    Baz(bool),
}
```

Now, the combination of `FooBar` and `Baz` covers the entire set of variants from `FooBarBaz`. We can use this setup to exhaustively handle all possible cases, while staying entirely within the bounds of safe Rust:

```rust
let foo_bar_baz: FooBarBaz = FooBarBaz::Foo(1);

let result: String = match foo_bar_baz.downcast(PhantomData::<FooBar>) {
    Ok(foo_bar) => {
        format!("downcasted to FooBar: {:?}", foo_bar)
    }
    Err(remainder) => match remainder.downcast_fields(PhantomData::<Baz>) {
        Ok(baz) => {
            format!("downcasted to Baz: {:?}", baz)
        }
        Err(remainder) => remainder.finalize_extract(),
    },
};
```

In this example, we first attempt to downcast into `FooBar`. If that fails, the remainder is passed to `downcast_fields`, which attempts to extract the `Baz` variant. Finally, if all known variants have been handled and nothing remains, we call `finalize_extract`, which is only valid on an "empty" enum. This indicates that all variants have been successfully matched, and the code is guaranteed to be exhaustive.

The `downcast_fields` method is intended for intermediary or "partial" enums that contain only the unhandled variants, while `finalize_extract` is used when no variants are left. This closely models the behavior of Rust’s `!` (never) type and ensures that every path in your code is covered without panics or unsafe code.

At first glance, this approach may appear more complex than simply matching against the original enum directly. However, its true strength lies in its **generality**. With CGP’s downcasting mechanism, you can pattern match over generic enum types without knowing their full structure in advance. This enables highly extensible and type-safe designs where variants can be added or removed modularly, without breaking existing logic.


# Safe Struct Building

Just as CGP enables safe, composable deconstruction of enums, it also brings **extensible construction** to structs. This is achieved through a form of structural merging, where smaller structs can be incrementally combined into larger ones. The result is a flexible and modular approach to building complex data types, well-suited for highly decoupled or plugin-style architectures.

To illustrate this, let’s take the example of a `FooBarBaz` struct:

```rust
#[derive(HasFields, BuildField)]
pub struct FooBarBaz {
    pub foo: u64,
    pub bar: String,
    pub baz: bool,
}
```

Suppose we also define two smaller structs—`FooBar` and `Baz`—each containing a subset of the fields in `FooBarBaz`:

```rust
#[derive(HasFields, BuildField)]
pub struct FooBar {
    pub foo: u64,
    pub bar: String,
}

#[derive(HasFields, BuildField)]
pub struct Baz {
    pub baz: bool,
}
```

With CGP, we can now construct a `FooBarBaz` value in a modular and extensible way, by composing these smaller building blocks:

```rust
let foo_bar = FooBar {
    foo: 1,
    bar: "bar".to_owned(),
};

let baz = Baz { baz: true };

let foo_bar_baz: FooBarBaz = FooBarBaz::builder()
    .build_from(foo_bar)
    .build_from(baz)
    .finalize_build();
```

Here’s what’s happening: The `builder()` method on `FooBarBaz` initiates a *partial builder*, an intermediate structure that initially contains none of the target fields. Each call to `build_from` takes a struct that contributes one or more of the remaining fields and returns a new builder with those fields filled in. Once all required fields have been supplied, the `finalize_build()` method consumes the builder and produces a fully constructed `FooBarBaz` instance.

Just like enum upcasting and downcasting, the struct builder is implemented entirely in **safe**, **panic-free** Rust. There’s no runtime reflection or unsafe code involved. The only requirement is that the participating structs must have compatible fields and derive the CGP-provided traits `HasFields` and `BuildField`.

Moreover, this system is completely decoupled from specific struct definitions. The individual component structs—`FooBar`, `Baz`, and `FooBarBaz`—can be defined in separate crates, with no awareness of each other. Once the CGP traits are derived, they become interoperable through structural field compatibility alone.

While this example may seem trivial—after all, constructing `FooBarBaz` directly is straightforward—it serves as a foundation for much more powerful generic abstractions. As you’ll see in the upcoming sections, the builder pattern opens the door to writing highly reusable, type-safe logic that can construct **generic structs** without ever referencing their concrete types. This makes it possible to write libraries or plugins that contribute data to a shared structure without tight coupling or dependency on a central type definition.

# Config Loading Example

To understand how extensible records enable modular builders, let’s explore a practical use case: constructing an application context from configuration inputs.

Imagine we’re building an API client for our application. The application context needs to include an SQLite database connection and an HTTP client. A typical way to model this in Rust would be to define a struct like the following:

```rust
#[cgp_context]
pub struct App {
    pub sqlite_pool: SqlitePool,
    pub http_client: Client,
}
```

This `App` struct holds a [`SqlitePool`](https://docs.rs/sqlx/latest/sqlx/sqlite/type.SqlitePool.html) from the `sqlx` crate, and an HTTP [`Client`](https://docs.rs/reqwest/latest/reqwest/struct.Client.html) from `reqwest`. To construct this context, we might implement a `new` function as follows:

```rust
impl App {
    pub async fn new(db_path: &str) -> Result<Self, Error> {
        let http_client = Client::new();
        let sqlite_pool = SqlitePool::connect(db_path).await?;

        Ok(Self {
            http_client,
            sqlite_pool,
        })
    }
}
```

This constructor is asynchronous and returns a `Result<App, Error>`. It creates a default `Client` using `reqwest`, connects to the database using the provided path, and assembles both into an `App` struct.

## Adding AI Capabilities to `App`

At this point, the constructor looks simple. But in a real-world setting, it’s rarely that clean. Suppose the product team now wants to integrate AI capabilities into the application. To support this, we decide to use an LLM service like ChatGPT and extend the `App` struct accordingly:

```rust
#[cgp_context]
pub struct App {
    pub sqlite_pool: SqlitePool,
    pub http_client: Client,
    pub open_ai_client: openai::Client,
    pub open_ai_agent: Agent<openai::CompletionModel>,
}
```

In this updated version, we introduce two new fields: `open_ai_client`, which is used to communicate with the OpenAI API, and `open_ai_agent`, which encapsulates a configured agent that can perform conversational tasks using a model like GPT-4o.

The `new` constructor must now also handle the initialization logic for these fields:

```rust
impl App {
    pub async fn new(db_path: &str) -> Result<Self, Error> {
        let http_client = Client::new();
        let sqlite_pool = SqlitePool::connect(db_path).await?;
        let open_ai_client = openai::Client::from_env();
        let open_ai_agent = open_ai_client.agent("gpt-4o").build();

        Ok(Self {
            http_client,
            sqlite_pool,
            open_ai_client,
            open_ai_agent,
        })
    }
}
```

Here, we initialize the OpenAI client using environment variables, and then build an agent configured for the `gpt-4o` model. These values are added alongside the existing HTTP and database clients.

## From Simple to Complex

Even with these additions, our constructor remains relatively manageable. However, as often happens in production, the requirements grow—and so does the configuration logic. Let’s imagine a more realistic version of this `new` function:

```rust
impl App {
    pub async fn new(
        db_options: &str,
        db_journal_mode: &str,
        http_user_agent: &str,
        open_ai_key: &str,
        open_ai_model: &str,
        llm_preamble: &str,
    ) -> Result<Self, Error> {
        let journal_mode = SqliteJournalMode::from_str(db_journal_mode)?;

        let db_options = SqliteConnectOptions::from_str(db_options)?.journal_mode(journal_mode);

        let sqlite_pool = SqlitePool::connect_with(db_options).await?;

        let http_client = Client::builder()
            .user_agent(http_user_agent)
            .connect_timeout(Duration::from_secs(5))
            .build()?;

        let open_ai_client = openai::Client::new(open_ai_key);
        let open_ai_agent = open_ai_client
            .agent(open_ai_model)
            .preamble(llm_preamble)
            .build();

        Ok(Self {
            open_ai_client,
            open_ai_agent,
            sqlite_pool,
            http_client,
        })
    }
}
```

This constructor now handles five separate input parameters, each contributing to the configuration of different parts of the application. It creates a `SqliteConnectOptions` object to configure the database with the specified journal mode. The HTTP client is set up with a custom user agent and a longer timeout. The AI client is initialized using an explicit API key, and the agent is constructed with a custom model and preamble.

While none of these steps are especially difficult on their own, the function is starting to grow in complexity. It’s also becoming more fragile, as all responsibilities are bundled into one place. Every change to a single subsystem—whether it’s database, HTTP, or AI—requires editing the same constructor.

This is exactly the kind of problem extensible struct builders can help solve. In the next section, we will see how CGP allows each subsystem to define its own builder component independently. With this approach, we can modularize the construction logic, reduce tight coupling, and compose the final `App` struct without writing a monolithic constructor function.

## Why Modular Constructor Matters

As we've seen in the previous example, even modest configurability can cause a constructor's complexity to grow rapidly. With just a few additional fields or customization options, the function becomes harder to maintain, test, and reason about.

In many cases, there's no single “correct” way to construct an application context. For example, you might want to retain both versions of the `new` constructor from earlier: a minimal one for unit tests with default values, and a more elaborate, configurable one for production. In fact, it's common for different parts of an application to require different levels of configurability—some using defaults, others requiring fine-grained setup.

To manage this complexity, Rust developers often reach for the [*builder pattern*](https://rust-unofficial.github.io/patterns/patterns/creational/builder.html). This involves creating a separate builder struct, typically with optional or defaultable fields and fluent setter methods. The builder is used to gradually assemble values before producing the final struct.

## Challenges for Modular Builders

The traditional builder pattern works, but it comes with serious limitations—especially when extensibility and modularity are important.

The first limitation is **tight coupling**. A builder is usually tied directly to a specific struct. If you create a new context that’s only slightly different from an existing one, you often have to duplicate the entire builder implementation, even if most of the logic is the same.

Second, builders are typically **non-extensible**. If you want to extend the construction logic—say, by adding a new step to initialize an additional field—you usually have to modify the original builder struct. This makes it hard to share construction logic across crates or teams without exposing internal implementation details.

The root cause of these problems is that struct construction in Rust typically requires direct access to the **concrete type**. That means the builder must know the exact shape of the final struct and have access to all its field values up front. If you need intermediate values or want to plug in custom build steps, those values must be manually threaded through the builder and its state.

This rigidity makes it difficult to define reusable, composable building blocks—especially in large or evolving codebases.

## Modular Builders with CGP

Earlier versions of CGP also ran into these limitations. When writing *context-generic* code, we wanted to construct structs in a way that didn’t require knowing their concrete types ahead of time. But because Rust structs require all field values to be present simultaneously at construction time, we couldn’t easily implement flexible or reusable context-generic constructors.

With the latest release, that limitation is fully resolved.

CGP now supports **modular, extensible struct builders** that can be composed from smaller, independent parts. Each module can define how to build a piece of a context struct, and the builder automatically merges them—without needing to know the final shape of the struct ahead of time.

This opens the door to a new style of constructor logic: one that is **modular**, **composable**, and **context-generic**. You can define builders for individual subsystems (e.g., database, HTTP client, AI agent), and combine them to build any compatible application context.

In the next section, we’ll revisit the constructor examples we’ve already seen—and show how to rewrite them using CGP’s new builder pattern to achieve clean, modular, and reusable construction logic.

## A Modular SQLite Builder

Let's take a look at how we would implement modular construction of the example `App` as multiple CGP providers. First, we would define a default SQLite builder provider as follows:

```rust
#[cgp_new_provider]
impl<Build, Code: Send, Input: Send> Handler<Build, Code, Input> for BuildDefaultSqliteClient
where
    Build: HasSqlitePath + CanRaiseAsyncError<sqlx::Error>,
{
    type Output = SqliteClient;

    async fn handle(
        build: &Build,
        _code: PhantomData<Code>,
        _input: Input,
    ) -> Result<Self::Output, Build::Error> {
        let sqlite_pool = SqlitePool::connect(build.db_path())
            .await
            .map_err(Build::raise_error)?;

        Ok(SqliteClient { sqlite_pool })
    }
}
```

We define `BuildDefaultSqliteClient` as a CGP _provider_ for `Handler`, which is the same [handler component we introduced in Hypershell](/blog/hypershell-release/#handler-component). So yes, in case if it is not clear to you, the `Handler` component is a very general CGP component that can be used for implementing providers for _many_ use cases, including shell-like pipes, API handlers, modular builders, and modular matchers.

In the `Handler` implementation of `BuildDefaultSqliteClient`, we use the identifier `Build` to identify the generic context that we are in. This signifies that the generic context for this handler is _not_ going to be `App`, but rather a _builder context_ that would contain the same set of parameters that we used in `new` in the earlier example.

We make use of [dependency injection](https://patterns.contextgeneric.dev/impl-side-dependencies.html) to require the generic `Build` context to provide the database path through `HasSqlitePath`, as well as the ability to [raise errors](https://patterns.contextgeneric.dev/error-handling.html) from `sqlx` through `CanRaiseError`. The trait `HasSqlitePath` is defined as follows:

```rust
#[cgp_auto_getter]
pub trait HasSqlitePath {
    fn db_path(&self) -> &str;
}
```

We make use of [`#[cgp_auto_getter]`](https://patterns.contextgeneric.dev/generic-accessor-providers.html#the-cgp_auto_getter-macro) to require the `Build` context to contain a field `db_path` of type `String`. As long as the builder context contains that field and derives `HasField`, the trait `HasSqlitePath` will be automatically implemented with no futher action required.

The generic parameters `Code` and `Input` are ignored in our example providers. Unlike Hypershell, we are not using `Handler` to build a DSL here. However as we will see later, the `Code` parameter can still be useful for specifying _options_ to build a context in multiple ways. For the case of the builder pattern, the `Input` type would be a reference to the **partial** value of the final `App` struct that would be built. The advanced usage of this is out of the scope for this example, so we will ignore it for now and defer the explanation to later sections.

Our `Handler` implementation also sets the associated `Output` type to `SqliteClient`, which would be return in the result of the `handle` method. This is how `SQliteClient` is defined:

```rust
#[derive(HasField, HasFields, BuildField)]
pub struct SqliteClient {
    pub sqlite_pool: SqlitePool,
}
```

The `SqliteClient` struct only contains one field, which is the `SqlitePool` that is constructed by `BuildSqliteClient`. In other words, `BuildSqliteClient` is really just a builder for `SqliteClient`, _not_ `App`. However, recall that with [safe struct building](#safe-struct-building), we can _merge_ the fields from `SqliteClient` into `App` using the `build_from` method. So all we have to do is to derive `HasField`, `HasFields`, and `BuildField` on `SqliteClient` to support the merging operation in later sections.

Once we have all the type signatures in place, the method body for `handle` is pretty straightforward. We just call `SqlitePool::connect(build.db_path())` to build the `SqlitePool`, and then return the `SqliteClient`.

At this point, you may wonder why should we write so much code to implement a `Handler` just to call `SqlitePool::connect`. Of course in practice, the construction of a field may be much more complex than this. For example, we can implement the more complicated construction of `SqlitePool` that we had earlier by defining a _different_ builder provider `BuildSqliteClient` as follows:

```rust
#[cgp_new_provider]
impl<Build, Code: Send, Input: Send> Handler<Build, Code, Input> for BuildSqliteClient
where
    Build: HasSqliteOptions + CanRaiseAsyncError<sqlx::Error>,
{
    type Output = SqliteClient;

    async fn handle(
        build: &Build,
        _code: PhantomData<Code>,
        _input: Input,
    ) -> Result<Self::Output, Build::Error> {
        let journal_mode =
            SqliteJournalMode::from_str(build.db_journal_mode()).map_err(Build::raise_error)?;

        let db_options = SqliteConnectOptions::from_str(build.db_options())
            .map_err(Build::raise_error)?
            .journal_mode(journal_mode);

        let sqlite_pool = SqlitePool::connect_with(db_options)
            .await
            .map_err(Build::raise_error)?;

        Ok(SqliteClient { sqlite_pool })
    }
}

#[cgp_auto_getter]
pub trait HasSqliteOptions {
    fn db_options(&self) -> &str;

    fn db_journal_mode(&self) -> &str;
}
```

Compared to before, instead of requiring a `db_path`, the provider `BuildSqliteClient` now requires the `Build` context to provide a `db_options` string as well as a `db_journal_mode` string.

This also shows how the builder provider is fully _decoupled_ from the builder context. If we are using `BuildDefaultSqliteClient`, we can define and construct a builder context containing only a `db_path` field. But if we want to switch to use `BuildSqliteClient` later, we can define a second builder context containing the `db_options` and `db_journal_mode` fields and wire it up with the new builder provider. Furthermore, if the construction of the other fields remain the same, we can now easily reuse and mix the builder providers based on the specific use cases.

## HTTP Client Builder

Similar to how we implement the SQLite builder, we can define a HTTP client builder to build a custom `reqwest` client for us. For brievity, we will focus only on the more complex construction of the HTTP client. The implementation is as follows:

```rust
#[cgp_new_provider]
impl<Build, Code: Send, Input: Send> Handler<Build, Code, Input> for BuildHttpClient
where
    Build: HasHttpClientConfig + CanRaiseAsyncError<reqwest::Error>,
{
    type Output = HttpClient;

    async fn handle(
        build: &Build,
        _code: PhantomData<Code>,
        _input: Input,
    ) -> Result<Self::Output, Build::Error> {
        let http_client = Client::builder()
            .user_agent(build.http_user_agent())
            .connect_timeout(Duration::from_secs(5))
            .build()
            .map_err(Build::raise_error)?;

        Ok(HttpClient { http_client })
    }
}

#[cgp_auto_getter]
pub trait HasHttpClientConfig {
    fn http_user_agent(&self) -> &str;
}

#[derive(HasField, HasFields, BuildField)]
pub struct HttpClient {
    pub http_client: Client,
}
```

Similar to `BuildSqliteClient`, `BuildHttpClient` requires the `Build` context to provide a HTTP user agent string, and returns a constructed `HttpClient` struct that contains the constructed `reqwest::Client`. The handler also requires a new error type, `reqwest::Error`, to be handled by the builder context. The `handle` method then builds as reqwest client with the default user agent set, as well as tweaking the connection timeout.

## Combined SQLite and HTTP Client Builder

Before we move on, it is worth noting that CGP does **not** dictate that you must split up the construction logic of every small part of the application context into separate builder. For example, you are totally free to combine both the construction of the SQLite client and the HTTP client into one builder, such as follows:

```rust
#[cgp_new_provider]
impl<Build, Code: Send, Input: Send> Handler<Build, Code, Input> for BuildDefaultSqliteAndHttpClient
where
    Build: HasSqlitePath + CanRaiseAsyncError<sqlx::Error>,
{
    type Output = SqliteAndHttpClient;

    async fn handle(
        build: &Build,
        _code: PhantomData<Code>,
        _input: Input,
    ) -> Result<Self::Output, Build::Error> {
        let sqlite_pool = SqlitePool::connect(build.db_path())
            .await
            .map_err(Build::raise_error)?;

        let http_client = Client::new();

        Ok(SqliteAndHttpClient { sqlite_pool, http_client })
    }
}

#[derive(HasField, HasFields, BuildField)]
pub struct SqliteAndHttpClient {
    pub sqlite_pool: SqlitePool,
    pub http_client: Client,
}
```

The main consequence of this approach is that the construction of SQLite and HTTP clients are now tightly coupled, making them not as easily customized as implementing them as separate providers. **However**, it is up to _your own_ preference and responsibility to decide on which approach is the most appropriate for your application.

For the purpose of the article, we will continue with the approach of splitting application logic down to the minimal to maximize the modularity. If you disagree with our approach, please be reminded that you can break down your own application logic in any way you prefer.

## ChatGPT Client Builder

Regardless of whether you believe it is better to split up or combine the construction of the SQLite and HTTP clients, there are often cases that you _do_ want to splut up the construction logic into at least two smaller parts. For example, we may want to two versions of the application context, where only the pro version of the app is enhanced with AI capabilities. In such case, it would be beneficial for us to define the builder provider for ChatGPT separately.

The implementation for the ChatGPT client follows the same pattern, and is implemented as follows:

```rust
#[cgp_new_provider]
impl<Build, Code: Send, Input: Send> Handler<Build, Code, Input> for BuildOpenAiClient
where
    Build: HasOpenAiConfig + HasAsyncErrorType,
{
    type Output = OpenAiClient;

    async fn handle(
        build: &Build,
        _code: PhantomData<Code>,
        _input: Input,
    ) -> Result<Self::Output, Build::Error> {
        let open_ai_client = openai::Client::new(build.open_ai_key());
        let open_ai_agent = open_ai_client
            .agent(build.open_ai_model())
            .preamble(build.llm_preamble())
            .build();

        Ok(OpenAiClient {
            open_ai_client,
            open_ai_agent,
        })
    }
}

#[cgp_auto_getter]
pub trait HasOpenAiConfig {
    fn open_ai_key(&self) -> &str;

    fn open_ai_model(&self) -> &str;

    fn llm_preamble(&self) -> &str;
}

#[derive(HasField, HasFields, BuildField)]
pub struct OpenAiClient {
    pub open_ai_client: openai::Client,
    pub open_ai_agent: Agent<openai::CompletionModel>,
}
```

The provider `BuildOpenAiClient` requires the `Build` context to contain the string fields `open_ai_key`, `open_ai_model`, and `llm_preamble` via the `HasOpenAiConfig` trait. It then constructs an `OpenAiClient` struct with two fields that contain the ChatGPT client and the agent with the configured completion model.

## Builder Context

```rust
#[cgp_context]
#[derive(HasField, Deserialize)]
pub struct FullAppBuilder {
    pub db_options: String,
    pub db_journal_mode: String,
    pub http_user_agent: String,
    pub open_ai_key: String,
    pub open_ai_model: String,
    pub llm_preamble: String,
}

delegate_components! {
    FullAppBuilderComponents {
        ErrorTypeProviderComponent:
            UseAnyhowError,
        ErrorRaiserComponent:
            RaiseAnyhowError,
        HandlerComponent:
            BuildAndMergeOutputs<
                App,
                Product![
                    BuildSqliteClient,
                    BuildHttpClient,
                    BuildOpenAiClient,
                ]>,
    }
}
```