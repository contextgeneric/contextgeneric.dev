+++

title = "CGP v0.5.0 Release"

authors = ["Soares Chen"]

+++

# Overview

CGP v0.5.0 is now released, along with various feature improvements as well as some breaking changes in preparation for stabilization. Here is a summary of the changes in this major release.

---

# New Features

## `#[cgp_auto_dispatch]` Macro

A new `#[cgp_auto_dispatch]` macro has been introduced to allow automatic dispatch of trait implementation of an enum to its variants, if all its variants implement the trait.

For example, given the following definition of the `Shape` enum:

```rust
#[derive(CgpData)]
pub enum Shape {
    Circle(Circle),
    Rectangle(Rectangle),
}

pub struct Circle {
    pub radius: f64,
}

pub struct Rectangle {
    pub width: f64,
    pub height: f64,
}
```

Suppose that we want to define a trait `HasArea` for computing the area of shapes, we could define and implement the trait as follows:

```rust
#[cgp_auto_dispatch]
pub trait HasArea {
    fn area(&self) -> f64;
}

impl HasArea for Circle {
    fn area(&self) -> f64 {
        PI * self.radius * self.radius
    }
}

impl HasArea for Rectangle {
    fn area(&self) -> f64 {
        self.width * self.height
    }
}
```

And just like that, `HasArea` is now automatically implemented for `Shape`, without requiring us to write any `impl` definition!

Behind the scene, the macro `#[cgp_auto_dispatch]` generates a blanket implementation for `HasArea` that makes use of [extensible visitors](/blog/extensible-datatypes-part-4/) to implement the trait for any extensible variant. And by using `#[derive(CgpData)]` on `Shape`, we derive the extensible variants constructs to be used by the blanket implementation.

It is also worth noting that we can use `#[derive(CgpData)]` and `#[cgp_auto_dispatch]` on any supported constructs, and the traits would automatically be implemented even if they are in separate crates. In other words, neither `Shape` nor `HasArea` need to be aware of each others' existence, and the trait implementation would still work out of the box.

A full introduction of how `#[cgp_auto_dispatch]` work is worth its own blog post. But for now, you can try using it directly in your project and see if it works without any issue. At least for the simple case, you don't need to understand or adopt the rest of CGP in order to use `#[cgp_auto_dispatch]`, so do try it out!

## Monadic Computation Pipeline

The `cgp-monad` crate has been introduced to provide support for basic form of monadic computation. This monadic computation is used to simplify the implementation of [extensible visitors](/blog/extensible-datatypes-part-4/#what-is-a-monad).

Compared to the standard definition of monads in languages like Haskell, the monadic implementation in CGP is "lazy" and retroactive. That is, it allows existing Rust types like `Result` and `Option` to be used as monads, without implementing traits on these types.

For instance, instead of defining monad as a higher kinded type, CGP allows extraction of inner value types from a monadic type using a monadic provider:

```rust
pub trait ContainsValue<Output> {
    type Value;
}

impl<T, E> ContainsValue<Result<T, E>> for ErrMonadic {
    type Value = T;
}
```

Above shows the `ContainsValue` trait, which would match on an `Output` type and give us its pure `Value` type. We can then define providers like `ErrMonadic`, which implements `ContainsValue` by extracting a value type `T` from a result type `Result<T, E>`.

Additionally, instead of the standard monadic `bind` operation, CGP instead provide lifting operation to lift the input of a `Computer` provider:

```rust
impl<Context, Code, T1, T2, E, M, Cont> Computer<Context, Code, Result<T1, E>> for BindErr<M, Cont>
where
    Cont: Computer<Context, Code, T1>,
    M: ContainsValue<Cont::Output, Value = Result<T2, E>> + ...,
{ ... }
```

In the above example, the provider `BindErr<ErrMonadic, F>` can be used to wrap a provider `F` that implements `Computer` with input type `T1` and output type `Result<T2, E>`, and turns it into a `Computer` provider with input type `Result<T1, E>` and output type `Result<T2, E>`.

In other words, the provider is equivalent to the following Haskell signature:

```rust
bind :: (a -> m b) -> m a -> m b
```

which switches the argument order with the original `(>>=)` operator, which is defined as:

```rust
(>>=) :: m a -> (a -> m b) -> m b
```

By switching the argument ordering, we effectively turn the bind operator into a higher order function that lifts monadic functions, so that they can be composed using regular function composition.

Currently, the monadic implementation in CGP requires separate monadic bind implementation for synchronous and asynchronous computations. This is because the stable version Rust currently lacks the feature [impl trait in type aliases](https://rust-lang.github.io/impl-trait-initiative/explainer/tait.html), which makes it impossible for us to extract the pure value type from an anonymous `Future` type. However, once the feature is stabilized in Rust, we will be able to extend the monadic support to opaque types that implements impl traits, including `Future`, `Stream`, and `Iterator`.

A full introduction to monadic computation is worth its own blog post. For now, the main takeaway is that CGP now has basic monadic support that paves way to more advanced abstractions to be built, such as the ones we seen in extensible visitor.

## Extensible Visitor Dispatchers

## Generate static string from symbols

# Breaking Changes

## Removal of `Async` and `Send` bounds for async constructs

## Desugaring of `Symbols!`

## Reorganize exports in `cgp-field`

# Improvements

## Allow non-self argument in getter methods

## Support use of lifetime parameters inside CGP traits

# Bug Fixes

## Fix use of `new` in `delegate_components!` when keys array are used
