+++

title = "CGP v0.5.0 Release"

authors = ["Soares Chen"]

+++

# Overview

CGP v0.5.0 is now released, along with various feature improvements as well as some breaking changes in preparation for stabilization. Here is a summary of the changes in this major release.

# New Features

## `#[cgp_auto_dispatch]` Macro

## Monadic Computation Pipeline

The `cgp-monad` crate has been introduced to provide support for basic form of monadic computation. This monadic computation is used to simplify the implementation of [extensible visitors](/blog/extensible-datatypes-part-4/#what-is-a-monad).

Compared to the standard definition of monads in languages like Haskell, the monadic implementation in CGP is "lazy" and retroactive. That is, it allows existing Rust types like `Result` and `Option` to be used as monads, without implementing traits on these types.

For instance, instead of defining monad as a higher kinded type, CGP allows extraction of inner value types from a monadic type using a monadic provider:

```rust
pub trait ContainsValue<Output> {
    type Value;
}

impl<T, E> ContainsValue<Result<T, E>> for ErrMonadic {
    type Value = T;
}
```

Above shows the `ContainsValue` trait, which would match on an `Output` type and give us its pure `Value` type. We can then define providers like `ErrMonadic`, which implements `ContainsValue` by extracting a value type `T` from a result type `Result<T, E>`.

Additionally, instead of the standard monadic `bind` operation, CGP instead provide lifting operation to lift the input of a `Computer` provider:

```rust
impl<Context, Code, T1, T2, E, M, Cont> Computer<Context, Code, Result<T1, E>> for BindErr<M, Cont>
where
    Cont: Computer<Context, Code, T1>,
    M: ContainsValue<Cont::Output, Value = Result<T2, E>> + ...,
{ ... }
```

In the above example, the provider `BindErr<ErrMonadic, F>` can be used to wrap a provider `F` that implements `Computer` with input type `T1` and output type `Result<T2, E>`, and turns it into a `Computer` provider with input type `Result<T1, E>` and output type `Result<T2, E>`.

In other words, the provider is equivalent to the following Haskell signature:

```rust
bind :: (a -> m b) -> m a -> m b
```

which switches the argument order with the original `(>>=)` operator, which is defined as:

```rust
(>>=) :: m a -> (a -> m b) -> m b
```

By switching the argument ordering, we effectively turn the bind operator into a higher order function that lifts monadic functions, so that they can be composed using regular function composition.

Currently, the monadic implementation in CGP requires separate monadic bind implementation for synchronous and asynchronous computations. This is because the stable version Rust currently lacks the feature [impl trait in type aliases](https://rust-lang.github.io/impl-trait-initiative/explainer/tait.html), which makes it impossible for us to extract the pure value type from an anonymous `Future` type. However, once the feature is stabilized in Rust, we will be able to extend the monadic support to opaque types that implements impl traits, including `Future`, `Stream`, and `Iterator`.

A full introduction to monadic computation is worth its own blog post. For now, the main takeaway is that CGP now has basic monadic support that paves way to more advanced abstractions to be built, such as the ones we seen in extensible visitor.

## Extensible Visitor Dispatchers

## Generate static string from symbols

# Breaking Changes

## Removal of `Async` and `Send` bounds for async constructs

## Desugaring of `Symbols!`

## Reorganize exports in `cgp-field`

# Improvements

## Allow non-self argument in getter methods

## Support use of lifetime parameters inside CGP traits

# Bug Fixes

## Fix use of `new` in `delegate_components!` when keys array are used
