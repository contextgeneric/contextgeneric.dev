+++

title = "CGP v0.5.0 Release"

authors = ["Soares Chen"]

+++

# Overview

CGP v0.5.0 is now released, along with various feature improvements as well as some breaking changes in preparation for stabilization. Here is a summary of the changes in this major release.

---

# New Features

## `#[cgp_auto_dispatch]` Macro

A new `#[cgp_auto_dispatch]` macro has been introduced to allow automatic dispatch of trait implementation of an enum to its variants, if all its variants implement the trait.

For example, given the following definition of the `Shape` enum:

```rust
#[derive(CgpData)]
pub enum Shape {
    Circle(Circle),
    Rectangle(Rectangle),
}

pub struct Circle {
    pub radius: f64,
}

pub struct Rectangle {
    pub width: f64,
    pub height: f64,
}
```

Suppose that we want to define a trait `HasArea` for computing the area of shapes, we could define and implement the trait as follows:

```rust
#[cgp_auto_dispatch]
pub trait HasArea {
    fn area(&self) -> f64;
}

impl HasArea for Circle {
    fn area(&self) -> f64 {
        PI * self.radius * self.radius
    }
}

impl HasArea for Rectangle {
    fn area(&self) -> f64 {
        self.width * self.height
    }
}
```

And just like that, `HasArea` is now automatically implemented for `Shape`, without requiring us to write any `impl` definition!

Behind the scene, the macro `#[cgp_auto_dispatch]` generates a blanket implementation for `HasArea` that makes use of [extensible visitors](/blog/extensible-datatypes-part-4/) to implement the trait for any extensible variant. And by using `#[derive(CgpData)]` on `Shape`, we derive the extensible variants constructs to be used by the blanket implementation.

It is also worth noting that we can use `#[derive(CgpData)]` and `#[cgp_auto_dispatch]` on any supported constructs, and the traits would automatically be implemented even if they are in separate crates. In other words, neither `Shape` nor `HasArea` need to be aware of each others' existence, and the trait implementation would still work out of the box.

A full introduction of how `#[cgp_auto_dispatch]` work is worth its own blog post. But for now, you can try using it directly in your project and see if it works without any issue. At least for the simple case, you don't need to understand or adopt the rest of CGP in order to use `#[cgp_auto_dispatch]`, so do try it out!

## Extensible Visitor Dispatchers

The extensible visitor providers have been overhauled to support more diverse use cases. The library now provides the following dispatchers:

- `MatchWithValueHandlers` - match and dispatch on an owned input `Value`.
- `MatchWithValueHandlersRef` - match and dispatch on a borrowed input `&Value`.
- `MatchWithValueHandlersMut` - match and dispatch on a mutably borrowed input `&mut Value`.

These dispatchers now work with both the owned variants of the handler traits, e.g. `Computer` and `ComputerRef`. Inside `Computer`, the borrowed value including the reference is used as the `Input` parameter, e.g.:

```rust
MatchWithValueHandlersRef: Computer<Context, &Value>
```

and also:

```rust
MatchWithValueHandlersRef: ComputerRef<Context, Value>
```

Additionally, a tuple variant of the matchers are introduced to match on input values along with additional arguments:

- `MatchFirstWithValueHandlers` - match and dispatch on an owned `Value` within an input `(Value, Args)`.
- `MatchFirstWithValueHandlersRef` - match and dispatch on a borrowed `&Value` within an input `(&Value, Args)`.
- `MatchFirstWithValueHandlersMut` - match and dispatch on a mutably borrowed `&mut Value` within an input `(&mut Value, Args)`.

These handlers are implemented to assist the implementation of `#[cgp_auto_dispatch]`, to allow additional arguments to be passed through the dispatchers without being matched on. They can also be used in more advanced use cases of extensible visitor, so that additional arguments can be forwarded to the visitors.

It is also worth noting that the handlers do not implement the ref variants of the handler traits, e.g:

```rust
MatchFirstWithValueHandlersRef: Computer<Context, (&Value, Args)>
```

is implemented, but **not**:

```rust
MatchFirstWithValueHandlersRef: ComputerRef<Context, (Value, Args)>
```

This is because `ComputerRef` turns the entire input type into reference, and that makes it challenging to pass owned value within `Args`.

This also shows that the `Computer` trait is more flexible than `ComputerRef`, as it can still work with borrowed values as the input type. On the other hand, the `ComputerRef` trait makes it easier for beginners to work with borrowed values without needing to learn about higher-ranked trait bounds. With this in mind, the use case of extra arguments is advanced enough that it is simpler to use `Computer` directly, as compared to trying to complicate the design of `ComputerRef` to support the use case.

Behind the scene, all dispatchers share the same underlying abstraction that empowers extensible visitors. In other words, we don't actually repeat the same pattern slightly differently for 6 times to implement the dispatchers. This also means that advanced users can also make use of the underlying abstractions to define custom dispatchers for more advanced use cases.

The implementation details for the dispatchers is available at the blog post for [extensible visitors](/blog/extensible-datatypes-part-4/#implementation-of-visitor-dispatcher). I will also write about follow up blog posts about the extended features some time in the future (hopefully).

## Monadic Computation Pipeline

The `cgp-monad` crate has been introduced to provide support for basic form of monadic computation. This monadic computation is used to simplify the implementation of [extensible visitors](/blog/extensible-datatypes-part-4/#what-is-a-monad).

Compared to the standard definition of monads in languages like Haskell, the monadic implementation in CGP is "lazy" and retroactive. That is, it allows existing Rust types like `Result` and `Option` to be used as monads, without implementing traits on these types.

For instance, instead of defining monad as a higher kinded type, CGP allows extraction of inner value types from a monadic type using a monadic provider:

```rust
pub trait ContainsValue<Output> {
    type Value;
}

impl<T, E> ContainsValue<Result<T, E>> for ErrMonadic {
    type Value = T;
}
```

Above shows the `ContainsValue` trait, which would match on an `Output` type and give us its pure `Value` type. We can then define providers like `ErrMonadic`, which implements `ContainsValue` by extracting a value type `T` from a result type `Result<T, E>`.

Additionally, instead of the standard monadic `bind` operation, CGP instead provide lifting operation to lift the input of a `Computer` provider:

```rust
impl<Context, Code, T1, T2, E, M, Cont> Computer<Context, Code, Result<T1, E>> for BindErr<M, Cont>
where
    Cont: Computer<Context, Code, T1>,
    M: ContainsValue<Cont::Output, Value = Result<T2, E>> + ...,
{ ... }
```

In the above example, the provider `BindErr<ErrMonadic, F>` can be used to wrap a provider `F` that implements `Computer` with input type `T1` and output type `Result<T2, E>`, and turns it into a `Computer` provider with input type `Result<T1, E>` and output type `Result<T2, E>`.

In other words, the provider is equivalent to the following Haskell signature:

```rust
bind :: (a -> m b) -> m a -> m b
```

which switches the argument order with the original `(>>=)` operator, which is defined as:

```rust
(>>=) :: m a -> (a -> m b) -> m b
```

By switching the argument ordering, we effectively turn the bind operator into a higher order function that lifts monadic functions, so that they can be composed using regular function composition.

Currently, the monadic implementation in CGP requires separate monadic bind implementation for synchronous and asynchronous computations. This is because the stable version Rust currently lacks the feature [impl trait in type aliases](https://rust-lang.github.io/impl-trait-initiative/explainer/tait.html), which makes it impossible for us to extract the pure value type from an anonymous `Future` type. However, once the feature is stabilized in Rust, we will be able to extend the monadic support to opaque types that implements impl traits, including `Future`, `Stream`, and `Iterator`.

A full introduction to monadic computation is worth its own blog post. For now, the main takeaway is that CGP now has basic monadic support that paves way to more advanced abstractions to be built, such as the ones we seen in extensible visitor.

## Generate static string from symbols

The type produced from `Symbol!` can now generically produce a `&'static str` value to be used within generic code. for example:

```rust
const HELLO: &'static str = <Symbol!("hello") as StaticString>::VALUE;
```

This is implemented through the `StaticString` trait, which is defined as:

```rust
pub trait StaticString {
    const VALUE: &'static str;
}
```

This is a significant break through, because we are now able to "pass" actual `&'static str` strings as types through generic parameters, by wrapping them in the CGP symbol types.

Behind the scene, a symbol like `Symbol!("abc")` is expanded into:

```rust
ψ<3, ζ<'a', ζ<'b', ζ<'c', ε>>>>
```

or, in the human-readable form:

```rust
Symbol<3, Chars<'a', Chars<'b', Chars<'c', Nil>>>>
```

The value `3` at the first position is the length of the symbol. This additional metadata is generated by `Symbol!` since v0.5.0, to make it possible to reconstruct the `&'static str` value inside const evaluation.

This hack is needed, because without it, we would need the full const-generics feature to be stabilized in Rust, to be able to "count" how many characters are there in the type. But by pre-computing the length inside the `Symbol!` macro, we are able to construct an array of the appropriate size and loop within const evaluation to reproduce the string.

The ability to produce static strings is especially useful in generic code that needs to pass `&str` values to other functions, such as in [`cgp-serde`](https://github.com/contextgeneric/cgp-serde/blob/d7a08cf99f3a741e6eb16ae58f61af5fb5e5253c/crates/cgp-serde/src/providers/fields.rs#L33-L59). Without this, a new `String` value would have to be re-constructed every time the function is called, which would significantly impact the performance of using symbols as strings.


# Breaking Changes

Along with the new features, v0.5.0 also introduces a couple of breaking changes. This is in preparation for a v1 stabilization in the future, so that any potential breaking changes happen now rather than later.

## Removal of `Async` and `Send` bounds for async constructs

The most significant breaking change of all is the removal of the `Async` trait, which was defined roughly as:

```rust
pub trait Async: Send + Sync {}
impl<T: Send + Sync> Async for T {}
```

The `Async` trait was used in CGP as an alias for `Send + Sync`. It was used in the trait bounds for abstract types and generic parameter, in order to ensure that the `Future` in the generic async functions could implement `Send`. The `Send` bound is commonly needed in functions such as [`tokio::spawn`](https://docs.rs/tokio/latest/tokio/task/fn.spawn.html), and it is the leading cause of why Rust developers tend to annotate `Send + Sync` everywhere in their code.

In order to support `Send`-able futures, CGP code used to be full of boilerplate of the use of `Async`. It also makes it more complicated to support both async and sync use cases in CGP. For example, prior to v0.5.0, we have traits like `HasAsyncErrorType`, which is an alias to `HasErrorType<Error: Async> + Async`. The two versions of the traits are needed, so that users who do not use async could potentially instantiate the abstract `Error` type to something that is `!Send`.

To improve the ergonomic of using `Send`-able `Future`s, the Rust compiler team have been working on a feature called [Return Type Notation (RTN)](https://github.com/rust-lang/rust/issues/109417) that could allow the `Send` bound of a `Future` to be imposed retroactively, such as at the code where the `Future` needs to be passed to `tokio::spawn`. With RTN, it would allow us to use CGP in async code without adding the `Send + Sync` bounds everywhere.

However, unfortunately RTN does not seem to be getting stabilized anytime soon, and as a result, CGP is originally on-track to keep the `Async` constructs around in the short term. But the good news is that I have found an alternative way to retroactively add the `Send` bound to a `Future`, without needing to wait for RTN to stabilize.

### Getting Around RTN

The trick to this is to introduce a second proxy trait that provides the same method as the original, but with the returned `Future` implementing `Send`. This proxy trait would need to be implemented manually by a concrete context without the help of CGP, but the implementation can be forwarded to the original trait, which can be implemented using CGP.

A full example with the use of `spawn` is available [here](https://github.com/contextgeneric/cgp/blob/a4878587d221af141bc238fb34e08e373239b4d3/crates/cgp-tests/src/tests/async/spawn.rs) and [here](https://github.com/contextgeneric/cgp-examples/blob/4469aa38fce125c0c50f2bf05ac5502f820076e7/transfer/src/contexts/app.rs#L125-L133). The example involves use of the `CanRun` trait, which is defined as:

```rust
#[cgp_component(Runner)]
pub trait CanRun: HasErrorType {
    fn run(&self) -> impl Future<Output = Result<(), Self::Error>>;
}
```

To be able to use `run` inside `tokio::spawn`, we would define a proxy trait that adds the `Send` bound to the returned `Future` as follows:

```rust
#[cgp_component(SendRunner)]
pub trait CanSendRun: Send + HasErrorType {
    fn send_run(&self) -> impl Future<Output = Result<(), Self::Error>> + Send;
}
```

We can use `Runner` to implement context-generic providers, so that we don't need to worry about the `Send` bounds of our generic types. For example:

```rust
#[cgp_new_provider]
impl<Context> Runner<Context> for RunWithFooBar
where
    Context: HasFooBar, // don't need to require Context::FooBar:Send
{
    async fn run(&self) { ... }
}
```

On the other hand, if we need to call `CanRun` inside `tokio::spawn` within a generic code, we can instead use `CanSendRun`, such as follows:

```rust
fn spawn_and_run_foo_bar<
    Context: 'static + CanSendRun<RunFooBar>,
>(context: Context) {
    tokio::spawn(async move {
        let _ = context.send_run(PhantomData).await;
    })
}
```

When we implement a concrete context, we would delegate the implementation of `Runner` to `RunWithFooBar`, but we would manually implement `SendRunner` by forwarding it to `Runner`:

```rust
#[cgp_context]
pub struct App { ... }

delegate_components! {
    AppComponents {
        RunnerComponent:
            RunWithFooBar,
        ...
    }
}

#[cgp_provider]
impl SendRunner<App> for AppComponents {
    async fn send_run(context: &App) -> Result<(), Error> {
        context.run(code).await
    }
}
```

When we implement `SendRunner` for `App`, since the trait system can have full access to the concrete type `App` and all its associated types, it is able to retroactively see that the future returned by `run` actually implements `Send`. As a result, we esentially emulate RTN by implementing the proxy trait `SendRunner` at the top level.

With this hack, we are able to fully remove the use of `Async` in CGP without needing to wait for RTN to get stabilized. In the meanwhile, users who really need the `Send` bound can make use of the proxy trait technique outlined here to recover the `Send` bound through the concrete context.

It is worth noting that we can expect the use of this hack to be temporary, as they can be completely eliminated once RTN is stabilized. On the other hand, it is much easier to remove the use of proxy traits as compared to removing all use of `Async` when RTN is stabilized. As a result, by migrating to the proxy trait hack now, we can avoid painful migration of removing `Async` at a later time, in case if CGP gets more widely used in the future.

### Migration Advice

For existing code bases, in case if you still rely on `Async` and the `Send`-safe variants like `HasAsyncErrorType`, you are free to copy the definitions to be used in your projects locally.

Even though CGP removed the `Async` constructs, it does not prevent anyone from continue requiring the `Send` bounds in their own projects. The main thing that affects you is that all async traits that are officially defined by the `cgp` crate no longer have the `Send` bound in the returned `Future`. This means that if your project defines traits that require their returned `Future` to implement `Send`, then you might have issues calling the async traits in CGP.

In the short term, the best way to mitigate this is by also dropping all the `Send` bounds in your code base. But if that is too much work, the simplest workaround is to define your own versions of the CGP traits that include the `Send` bounds in the `Future`.

At the moment, there are only a handful of async traits in CGP, such as `CanRun`, `CanComputeAsync`, and `CanHandle`. This means that unless you heavily rely on abstractions provided by these traits, there should be not much issue for you to redefine these traits in your own projects, in case if you really still need the `Send` bound.

## Desugaring of `Symbols!`

The `symbol!` macro has been renamed to `Symbol!` to better reflect that it desugars to a type, not a value. Aside from this, it also desugars to a different form.

For instance, before v0.5.0, `symbol!("abc")` desugars to:

```rust
ι<'a', ι<'b', ι<'c', ε>>>
```

But with v0.5.0, it desugars to:

```rust
ψ<3, ζ<'a', ζ<'b', ζ<'c', ε>>>>
```

First, the `ι` identifier has been replaced with `ζ`. This is because the use of `ι` will cause Rust to emit the `confusable_idents` warning, if the variable `i` is used in the code. As a result, we have to choose a different character to make it less likely to trigger `confusable_idents`.

Additionally, `ψ` is added to the head of the symbol type, together with the length metadata, so that we can implement `StaticString` to produce `&'static str`, without needing to wait for the full const-generics to get stabilized in Rust.

Finally, the `Char` type, which is an alias to `ζ`, has been renamed to `Chars`. This is to better reflect that the type represents a list of characters, not a single character.

## Reorganize exports in `cgp-field`

# Improvements

## Allow non-self argument in getter methods

## Support use of lifetime parameters inside CGP traits

# Bug Fixes

## Fix use of `new` in `delegate_components!` when keys array are used
