+++

title = "CGP v0.5.0 Release - Auto dispatchers, extensible datatype improvements, monadic computation, modular serde, and more"

authors = ["Soares Chen"]

+++

# Overview

CGP v0.5.0 is now released, along with various feature improvements as well as some breaking changes in preparation for stabilization. Here is a summary of the changes in this major release.

---

# New Features

## `#[derive(CgpData)]` Macro

A new `#[derive(CgpData)]` macro is introduced as an all-in-one macro for turning any struct or enum into extensible data types.

For example, given:

```rust
#[derive(CgpData)]
pub struct Person {
    pub name: String,
    pub age: u8,
}

#[derive(CgpData)]
pub enum User {
    Known(Person),
    Anonymous(u64),
}
```

The extensible data traits such as `HasField`, `FromVariant`, `HasFields`, `BuildField`, `ExtractField` would be derived for the given data types.

Prior to v0.5.0, you would have to derive the traits separately to implement them all:

```rust
#[derive(HasField, HasFields, BuildField)]
pub struct Person {
    pub name: String,
    pub age: u8,
}

#[derive(FromVariant, HasFields, ExtractField)]
pub enum User {
    Known(Person),
    Anonymous(u64),
}
```

## `#[cgp_auto_dispatch]` Macro

A new `#[cgp_auto_dispatch]` macro has been introduced to allow automatic dispatch of trait implementation of an enum to its variants, if all its variants implement the trait.

For example, given the following definition of the `Shape` enum:

```rust
#[derive(CgpData)]
pub enum Shape {
    Circle(Circle),
    Rectangle(Rectangle),
}

pub struct Circle {
    pub radius: f64,
}

pub struct Rectangle {
    pub width: f64,
    pub height: f64,
}
```

Suppose that we want to define a trait `HasArea` for computing the area of shapes, we could define and implement the trait as follows:

```rust
#[cgp_auto_dispatch]
pub trait HasArea {
    fn area(&self) -> f64;
}

impl HasArea for Circle {
    fn area(&self) -> f64 {
        PI * self.radius * self.radius
    }
}

impl HasArea for Rectangle {
    fn area(&self) -> f64 {
        self.width * self.height
    }
}
```

And just like that, `HasArea` is now automatically implemented for `Shape`, without requiring us to write any `impl` definition!

Behind the scene, the macro `#[cgp_auto_dispatch]` generates a blanket implementation for `HasArea` that makes use of [extensible visitors](/blog/extensible-datatypes-part-4/) to implement the trait for any extensible variant. And by using `#[derive(CgpData)]` on `Shape`, we derive the extensible variants constructs to be used by the blanket implementation.

It is also worth noting that we can use `#[derive(CgpData)]` and `#[cgp_auto_dispatch]` on any supported constructs, and the traits would automatically be implemented even if they are in separate crates. In other words, neither `Shape` nor `HasArea` need to be aware of each others' existence, and the trait implementation would still work out of the box.

A full introduction of how `#[cgp_auto_dispatch]` work is worth its own blog post. But for now, you can try using it directly in your project and see if it works without any issue. At least for the simple case, you don't need to understand or adopt the rest of CGP in order to use `#[cgp_auto_dispatch]`, so do try it out!

## `UpdateField` Trait

A new `UpdateField` trait have been introduced to generalize the update of extensible records:

```rust
pub trait UpdateField<Tag, M: MapType> {
    type Value;

    type Mapper: MapType;

    type Output;

    fn update_field(
        self,
        _tag: PhantomData<Tag>,
        value: M::Map<Self::Value>,
    ) -> (<Self::Mapper as MapType>::Map<Self::Value>, Self::Output);
}
```

The `UpdateField` trait makes it possible to swap a *wrapped* value within a partial record to a different wrapped value. This is derived by `#[CgpData]`, so that any field update operation can work with `UpdateField` instead of being derived manually by the macro.

For example, the [`BuildField`](/blog/extensible-datatypes-part-3/#buildfield-trait) trait is now implemented as a blanket implementation that uses `UpdateField`:

```rust
pub trait BuildField<Tag> {
    type Value;

    type Output;

    fn build_field(self, _tag: PhantomData<Tag>, value: Self::Value) -> Self::Output;
}

impl<Context, Tag> BuildField<Tag> for Context
where
    Context: UpdateField<Tag, IsPresent, Mapper = IsNothing>,
{
    type Value = Context::Value;

    type Output = Context::Output;

    fn build_field(self, tag: PhantomData<Tag>, value: Self::Value) -> Self::Output {
        self.update_field(tag, value).1
    }
}
```

Basically, `BuildField` is implemented by updating a `IsNothing` field in a partial record into a `IsPresent` field.

## Finalize extensible builder with default values

The [extensible builder pattern](/blog/extensible-datatypes-part-1/) now supports finalizing a partial record by filling the uninitialized fields using `Default`. This can be done using the `finalize_with_default` method.

For example, given the following extensible record:

```rust
#[derive(CgpData)]
pub struct FooBar {
    pub foo: String,
    pub bar: u64,
}
```

We can for example construct `FooBar` with the `bar` field initialized with a default value of `0`:

```rust
let foo_bar = FooBar::builder()
    .build_field(PhantomData::<Symbol!("foo")>, "foo".to_owned())
    .finalize_with_default();
```

Behind the scene, `finalize_with_default` is implemented by making use of `UpdateField` to perform *natural transformation* on each field modifier, and use `Default` to transform a `IsNothing` field into `IsPresent`.

## Extensible builder with optional field status

The original design of extensible builder makes use of the **typestate pattern** to keep track of whether the a given field in a partial record has been set, with `IsPresent` indicating that the field is set, and `IsNothing` indicating that a field is not set.

While this pattern is powerful, it also means that each state of the partial record has a different type. For example, `__PartialFooBar<IsPresent, IsNothing>` is a different type from `__PartialFooBar<IsNothing, IsPresent>`. However, there are times when we need the builder to stay in the same type throughout the build stage, such as when dynamically deserializing JSON values to be filled into a partial record.

To support these use cases, the `IsOptional` field state is introduced to allow a partial record to remain in the same type when field is being updated. This is done by mapping the field values to `Option`, so that the status of the field is only determined at runtime. With this, we can use a partial record such as `__PartialFooBar<IsOptional, IsOptional>` as an optional builder.

We can use the optional builder by using the methods `optional_builder`, `set`, and `finalize_optional` as follows:

```rust
let foo_bar = FooBar::optional_builder()
    .set(PhantomData::<Symbol!("foo")>, "foo".to_owned())
    .set(PhantomData::<Symbol!("bar")>, 42)
    .finalize_optional()
    .unwrap()
```

Compared to before, the type of the builder remains the same as `__PartialFooBar<IsOptional, IsOptional>` after each call to `set`. It is also worth noting that `finalize_optional` returns a `Result`, with an error returned in case if any field contains a `None` value. This is necessary, because without the typestate, the type system cannot know during compile time whether all fields are present.

It is also possible to use the optional builder with `finalize_with_default`, if all fields in the extensible record implements `Default`. So we can safely finalize the partial record without returning an error:

```rust
let foo_bar = FooBar::optional_builder()
    .set(PhantomData::<Symbol!("foo")>, "foo".to_owned())
    .finalize_with_default();
```

The optional builder is used by [`cgp-serde`](https://github.com/contextgeneric/cgp-serde/blob/46ff47fce3aa3e57700340a05833b404b9d59ddf/crates/cgp-serde/src/providers/record.rs#L49-L65) to implement generic deserialization of the fields in an extensible record.

## Extensible visitor dispatchers

The extensible visitor providers have been overhauled to support more diverse use cases. The library now provides the following dispatchers:

- `MatchWithValueHandlers` - match and dispatch on an owned input `Value`.
- `MatchWithValueHandlersRef` - match and dispatch on a borrowed input `&Value`.
- `MatchWithValueHandlersMut` - match and dispatch on a mutably borrowed input `&mut Value`.

These dispatchers now work with both the owned variants of the handler traits, e.g. `Computer` and `ComputerRef`. Inside `Computer`, the borrowed value including the reference is used as the `Input` parameter, e.g.:

```rust
MatchWithValueHandlersRef: Computer<Context, &Value>
```

and also:

```rust
MatchWithValueHandlersRef: ComputerRef<Context, Value>
```

Additionally, a tuple variant of the matchers are introduced to match on input values along with additional arguments:

- `MatchFirstWithValueHandlers` - match and dispatch on an owned `Value` within an input `(Value, Args)`.
- `MatchFirstWithValueHandlersRef` - match and dispatch on a borrowed `&Value` within an input `(&Value, Args)`.
- `MatchFirstWithValueHandlersMut` - match and dispatch on a mutably borrowed `&mut Value` within an input `(&mut Value, Args)`.

These handlers are implemented to assist the implementation of `#[cgp_auto_dispatch]`, to allow additional arguments to be passed through the dispatchers without being matched on. They can also be used in more advanced use cases of extensible visitor, so that additional arguments can be forwarded to the visitors.

It is also worth noting that the handlers do not implement the ref variants of the handler traits, e.g:

```rust
MatchFirstWithValueHandlersRef: Computer<Context, (&Value, Args)>
```

is implemented, but **not**:

```rust
MatchFirstWithValueHandlersRef: ComputerRef<Context, (Value, Args)>
```

This is because `ComputerRef` turns the entire input type into reference, and that makes it challenging to pass owned value within `Args`.

This also shows that the `Computer` trait is more flexible than `ComputerRef`, as it can still work with borrowed values as the input type. On the other hand, the `ComputerRef` trait makes it easier for beginners to work with borrowed values without needing to learn about higher-ranked trait bounds. With this in mind, the use case of extra arguments is advanced enough that it is simpler to use `Computer` directly, as compared to trying to complicate the design of `ComputerRef` to support the use case.

Behind the scene, all dispatchers share the same underlying abstraction that empowers extensible visitors. In other words, we don't actually repeat the same pattern slightly differently for 6 times to implement the dispatchers. This also means that advanced users can also make use of the underlying abstractions to define custom dispatchers for more advanced use cases.

The implementation details for the dispatchers is available at the blog post for [extensible visitors](/blog/extensible-datatypes-part-4/#implementation-of-visitor-dispatcher). I will also write about follow up blog posts about the extended features some time in the future (hopefully).

## `AsyncComputer` Trait

A new `AsyncComputer` trait has been introduced as an async version of `Computer`, which is defined as:

```rust
#[cgp_component {
    provider: AsyncComputer,
    derive_delegate: [
        UseDelegate<Code>,
        UseInputDelegate<Input>,
    ],
}]
#[async_trait]
pub trait CanComputeAsync<Code, Input> {
    type Output;

    async fn compute_async(&self, _code: PhantomData<Code>, input: Input) -> Self::Output;
}
```

The `AsyncComputer` trait is more general than `Handler`, in that it does not require the function to always return a `Result`. This helps provide a symmetry between the sync and async versions of handler components, with `AsyncComputer` being the async version of `Computer`, and `Handler` being the async version of `TryComputer`.

With this, abstractions such as extensible visitors and monadic computation now have their async implementations written using `AsyncComputer` instead of `Handler`. We then use then same promotion pattern to lift the implementations to `TryComputer` and `Handler`.

## Monadic computation pipeline

The `cgp-monad` crate has been introduced to provide support for basic form of monadic computation. This monadic computation is used to simplify the implementation of [extensible visitors](/blog/extensible-datatypes-part-4/#what-is-a-monad).

Compared to the standard definition of monads in languages like Haskell, the monadic implementation in CGP is "lazy" and retroactive. That is, it allows existing Rust types like `Result` and `Option` to be used as monads, without implementing traits on these types.

For instance, instead of defining monad as a higher kinded type, CGP allows extraction of inner value types from a monadic type using a monadic provider:

```rust
pub trait ContainsValue<Output> {
    type Value;
}

impl<T, E> ContainsValue<Result<T, E>> for ErrMonadic {
    type Value = T;
}
```

Above shows the `ContainsValue` trait, which would match on an `Output` type and give us its pure `Value` type. We can then define providers like `ErrMonadic`, which implements `ContainsValue` by extracting a value type `T` from a result type `Result<T, E>`.

Additionally, instead of the standard monadic `bind` operation, CGP instead provide lifting operation to lift the input of a `Computer` provider:

```rust
impl<Context, Code, T1, T2, E, M, Cont> Computer<Context, Code, Result<T1, E>> for BindErr<M, Cont>
where
    Cont: Computer<Context, Code, T1>,
    M: ContainsValue<Cont::Output, Value = Result<T2, E>> + ...,
{ ... }
```

In the above example, the provider `BindErr<ErrMonadic, F>` can be used to wrap a provider `F` that implements `Computer` with input type `T1` and output type `Result<T2, E>`, and turns it into a `Computer` provider with input type `Result<T1, E>` and output type `Result<T2, E>`.

In other words, the provider is equivalent to the following Haskell signature:

```rust
bind :: (a -> m b) -> m a -> m b
```

which switches the argument order with the original `(>>=)` operator, which is defined as:

```rust
(>>=) :: m a -> (a -> m b) -> m b
```

By switching the argument ordering, we effectively turn the bind operator into a higher order function that lifts monadic functions, so that they can be composed using regular function composition.

Currently, the monadic implementation in CGP requires separate monadic bind implementation for synchronous and asynchronous computations. This is because the stable version Rust currently lacks the feature [impl trait in type aliases](https://rust-lang.github.io/impl-trait-initiative/explainer/tait.html), which makes it impossible for us to extract the pure value type from an anonymous `Future` type. However, once the feature is stabilized in Rust, we will be able to extend the monadic support to opaque types that implements impl traits, including `Future`, `Stream`, and `Iterator`.

A full introduction to monadic computation is worth its own blog post. For now, the main takeaway is that CGP now has basic monadic support that paves way to more advanced abstractions to be built, such as the ones we seen in extensible visitor.

## Generate static string from symbols

The type produced from `Symbol!` can now generically produce a `&'static str` value to be used within generic code. for example:

```rust
const HELLO: &'static str = <Symbol!("hello") as StaticString>::VALUE;
```

This is implemented through the `StaticString` trait, which is defined as:

```rust
pub trait StaticString {
    const VALUE: &'static str;
}
```

This is a significant break through, because we are now able to "pass" actual `&'static str` strings as types through generic parameters, by wrapping them in the CGP symbol types.

Behind the scene, a symbol like `Symbol!("abc")` is expanded into:

```rust
ψ<3, ζ<'a', ζ<'b', ζ<'c', ε>>>>
```

or, in the human-readable form:

```rust
Symbol<3, Chars<'a', Chars<'b', Chars<'c', Nil>>>>
```

The value `3` at the first position is the length of the symbol. This additional metadata is generated by `Symbol!` since v0.5.0, to make it possible to reconstruct the `&'static str` value inside const evaluation.

This hack is needed, because without it, we would need the full const-generics feature to be stabilized in Rust, to be able to "count" how many characters are there in the type. But by pre-computing the length inside the `Symbol!` macro, we are able to construct an array of the appropriate size and loop within const evaluation to reproduce the string.

The ability to produce static strings is especially useful in generic code that needs to pass `&str` values to other functions, such as in [`cgp-serde`](https://github.com/contextgeneric/cgp-serde/blob/d7a08cf99f3a741e6eb16ae58f61af5fb5e5253c/crates/cgp-serde/src/providers/fields.rs#L33-L59). Without this, a new `String` value would have to be re-constructed every time the function is called, which would significantly impact the performance of using symbols as strings.

---

# Breaking Changes

Along with the new features, v0.5.0 also introduces a couple of breaking changes. This is in preparation for a v1 stabilization in the future, so that any potential breaking changes happen now rather than later.

## Removal of `Async` and `Send` bounds for async constructs

The most significant breaking change of all is the removal of the `Async` trait, which was defined roughly as:

```rust
pub trait Async: Send + Sync {}
impl<T: Send + Sync> Async for T {}
```

The `Async` trait was used in CGP as an alias for `Send + Sync`. It was used in the trait bounds for abstract types and generic parameter, in order to ensure that the `Future` in the generic async functions could implement `Send`. The `Send` bound is commonly needed in functions such as [`tokio::spawn`](https://docs.rs/tokio/latest/tokio/task/fn.spawn.html), and it is the leading cause of why Rust developers tend to annotate `Send + Sync` everywhere in their code.

In order to support `Send`-able futures, CGP code used to be full of boilerplate of the use of `Async`. It also makes it more complicated to support both async and sync use cases in CGP. For example, prior to v0.5.0, we have traits like `HasAsyncErrorType`, which is an alias to `HasErrorType<Error: Async> + Async`. The two versions of the traits are needed, so that users who do not use async could potentially instantiate the abstract `Error` type to something that is `!Send`.

To improve the ergonomic of using `Send`-able `Future`s, the Rust compiler team have been working on a feature called [Return Type Notation (RTN)](https://github.com/rust-lang/rust/issues/109417) that could allow the `Send` bound of a `Future` to be imposed retroactively, such as at the code where the `Future` needs to be passed to `tokio::spawn`. With RTN, it would allow us to use CGP in async code without adding the `Send + Sync` bounds everywhere.

However, unfortunately RTN does not seem to be getting stabilized anytime soon, and as a result, CGP is originally on-track to keep the `Async` constructs around in the short term. But the good news is that I have found an alternative way to retroactively add the `Send` bound to a `Future`, without needing to wait for RTN to stabilize.

### Getting Around RTN

The trick to this is to introduce a second proxy trait that provides the same method as the original, but with the returned `Future` implementing `Send`. This proxy trait would need to be implemented manually by a concrete context without the help of CGP, but the implementation can be forwarded to the original trait, which can be implemented using CGP.

A full example with the use of `spawn` is available [here](https://github.com/contextgeneric/cgp/blob/a4878587d221af141bc238fb34e08e373239b4d3/crates/cgp-tests/src/tests/async/spawn.rs) and [here](https://github.com/contextgeneric/cgp-examples/blob/4469aa38fce125c0c50f2bf05ac5502f820076e7/transfer/src/contexts/app.rs#L125-L133). The example involves use of the `CanRun` trait, which is defined as:

```rust
#[cgp_component(Runner)]
pub trait CanRun: HasErrorType {
    fn run(&self) -> impl Future<Output = Result<(), Self::Error>>;
}
```

To be able to use `run` inside `tokio::spawn`, we would define a proxy trait that adds the `Send` bound to the returned `Future` as follows:

```rust
#[cgp_component(SendRunner)]
pub trait CanSendRun: Send + HasErrorType {
    fn send_run(&self) -> impl Future<Output = Result<(), Self::Error>> + Send;
}
```

We can use `Runner` to implement context-generic providers, so that we don't need to worry about the `Send` bounds of our generic types. For example:

```rust
#[cgp_new_provider]
impl<Context> Runner<Context> for RunWithFooBar
where
    Context: HasFooBar, // don't need to require Context::FooBar:Send
{
    async fn run(&self) { ... }
}
```

On the other hand, if we need to call `CanRun` inside `tokio::spawn` within a generic code, we can instead use `CanSendRun`, such as follows:

```rust
fn spawn_and_run_foo_bar<
    Context: 'static + CanSendRun<RunFooBar>,
>(context: Context) {
    tokio::spawn(async move {
        let _ = context.send_run(PhantomData).await;
    })
}
```

When we implement a concrete context, we would delegate the implementation of `Runner` to `RunWithFooBar`, but we would manually implement `SendRunner` by forwarding it to `Runner`:

```rust
#[cgp_context]
pub struct App { ... }

delegate_components! {
    AppComponents {
        RunnerComponent:
            RunWithFooBar,
        ...
    }
}

#[cgp_provider]
impl SendRunner<App> for AppComponents {
    async fn send_run(context: &App) -> Result<(), Error> {
        context.run(code).await
    }
}
```

When we implement `SendRunner` for `App`, since the trait system can have full access to the concrete type `App` and all its associated types, it is able to retroactively see that the future returned by `run` actually implements `Send`. As a result, we esentially emulate RTN by implementing the proxy trait `SendRunner` at the top level.

With this hack, we are able to fully remove the use of `Async` in CGP without needing to wait for RTN to get stabilized. In the meanwhile, users who really need the `Send` bound can make use of the proxy trait technique outlined here to recover the `Send` bound through the concrete context.

It is worth noting that we can expect the use of this hack to be temporary, as they can be completely eliminated once RTN is stabilized. On the other hand, it is much easier to remove the use of proxy traits as compared to removing all use of `Async` when RTN is stabilized. As a result, by migrating to the proxy trait hack now, we can avoid painful migration of removing `Async` at a later time, in case if CGP gets more widely used in the future.

### Migration Advice

For existing code bases, in case if you still rely on `Async` and the `Send`-safe variants like `HasAsyncErrorType`, you are free to copy the definitions to be used in your projects locally.

Even though CGP removed the `Async` constructs, it does not prevent anyone from continue requiring the `Send` bounds in their own projects. The main thing that affects you is that all async traits that are officially defined by the `cgp` crate no longer have the `Send` bound in the returned `Future`. This means that if your project defines traits that require their returned `Future` to implement `Send`, then you might have issues calling the async traits in CGP.

In the short term, the best way to mitigate this is by also dropping all the `Send` bounds in your code base. But if that is too much work, the simplest workaround is to define your own versions of the CGP traits that include the `Send` bounds in the `Future`.

At the moment, there are only a handful of async traits in CGP, such as `CanRun`, `CanComputeAsync`, and `CanHandle`. This means that unless you heavily rely on abstractions provided by these traits, there should be not much issue for you to redefine these traits in your own projects, in case if you really still need the `Send` bound.

## Desugaring of `Symbols!`

The `symbol!` macro has been renamed to `Symbol!` to better reflect that it desugars to a type, not a value. Aside from this, it also desugars to a different form.

For instance, before v0.5.0, `symbol!("abc")` desugars to:

```rust
ι<'a', ι<'b', ι<'c', ε>>>
```

But with v0.5.0, it desugars to:

```rust
ψ<3, ζ<'a', ζ<'b', ζ<'c', ε>>>>
```

First, the `ι` identifier has been replaced with `ζ`. This is because the use of `ι` will cause Rust to emit the `confusable_idents` warning, if the variable `i` is used in the code. As a result, we have to choose a different character to make it less likely to trigger `confusable_idents`.

Additionally, `ψ` is added to the head of the symbol type, together with the length metadata, so that we can implement `StaticString` to produce `&'static str`, without needing to wait for the full const-generics to get stabilized in Rust.

Finally, the `Char` type, which is an alias to `ζ`, has been renamed to `Chars`. This is to better reflect that the type represents a list of characters, not a single character.

## Reorganize exports in `cgp-field`

The `cgp-field` crate is getting pretty large, and we have reorganized the exports to group them into several sub-modules. For example, the trait `HasField` is now exported at `cgp::fields::traits::HasField` instead of at the top level `cgp::fields::HasField`.

## Add `__Partial` prefix to derived partial data types

The partial data types derived from extensible data type macros are given `__Prefix` prefix, so that they become hidden and make it less likely to clash with other user defined structs.

For example, given:

```rust
#[derive(CgpData)]
pub struct Person {
    pub name: String,
    pub age: u8,
}
```

The partial data type `__PartialPerson` is generated:

```rust
pub struct __PartialPerson<F0: MapType, F1: MapType> {
    pub name: F0::Map<String>,
    pub age: F1::Map<u8>,
}
```

Before v0.5.0, the derived partial data type was named `PartialPerson`. So you could run into name conflict if you define a `PartialPerson` struct somewhere in the same module.

Note that this breaking change should not affect most of the existing code, as the partial data types are not meant to be used directly by end users.

## Add `Code` parameter to `CanRun`

The `CanRun` trait has been updated to include a `Code` parameter:

```rust
#[cgp_component {
    provider: Runner,
    derive_delegate: UseDelegate<Code>,
}]
#[async_trait]
pub trait CanRun<Code>: HasErrorType {
    async fn run(&self, _code: PhantomData<Code>) -> Result<(), Self::Error>;
}
```

Prior to v0.5.0, the `CanRun` trait was defined as:

```rust
#[cgp_component(Runner)]
#[async_trait]
pub trait CanRun: HasErrorType {
    async fn run(&self) -> Result<(), Self::Error>;
}
```

The `Code` parameter is added to allow us to embed type-level DSLs for running top-level functions, similar to how `Code` is used in `Computer` and `Handler` for DSLs like [Hypershell](/blog/hypershell-release/).

For existing users, if you would like to use the original `CanRun` trait without migrating your code, you can copy over the original definition of `CanRun` to use it in your own code base.

## Removal of `HasInner` trait

The `HasInner` trait has been removed alongside with the `cgp-inner` crate, which was defined as:

```rust
#[cgp_component {
    name: InnerComponent,
    provider: ProvideInner,
}]
pub trait HasInner {
    type Inner;

    fn inner(&self) -> &Self::Inner;
}
```

The use of `HasInner` has largely been obsoleted by the `UseField` pattern, which enables more flexible composition of multiple contexts.

For existing users, if you would like to use the original `HasInner` trait without migrating your code, you can copy over the original definition of `HasInner` to use it in your own code base.

# Improvements

A couple of improvements have been made for the existing constructs in CGP. Here are a few highlights.

## Allow non-self argument in getter methods

It is now possible to use `#[cgp_getter]` and `#[cgp_auto_getter]` with types other than `Self` as the target. For example, you can now use it on a trait like:

```rust
#[cgp_getter]
pub trait HasFooBar: HasFooType + HasBarType {
    fn foo_bar(foo: &Self::Foo) -> &Self::Bar;
}
```

With this, the provider `UseField<Symbol!("bar")>` would implement `FooBarGetter<Context>`, if `Context::Foo` implements `HasField<Symbol!("bar")>, Value = Context::Bar>`.

## Support use of lifetime parameters inside CGP traits

You can now include lifetimes inside the component trait parameters. For example, `cgp-serde` defines a component that corresponds to `serde`'s `Deserialize` as follows:

```rust
#[cgp_component {
    provider: ValueDeserializer,
    derive_delegate: UseDelegate<Value>,
}]
pub trait CanDeserializeValue<'de, Value> {
    fn deserialize<D>(&self, deserializer: D) -> Result<Value, D::Error>
    where
        D: serde::Deserializer<'de>;
}
```

Inside the type parameters of `IsProviderFor`, the lifetime `'de` is captured as `Life<'de>`, which is defined as:

```rust
pub struct Life<'a>(pub PhantomData<*mut &'a ()>);
```

Using `Life`, we can refer to the lifetime inside of `check_components!`, such as:

```rust
check_components! {
    <'de> CanDeserializeApp for App {
        ValueDeserializerComponent: [
            (Life<'de>, u64),
            (Life<'de>, String),
        ]
    }
}
```

## Allow shortcut for overriding provider names in `#[cgp_type]` and `#[cgp_getter]`

If you want to customize only the name of the provider trait in `#[cgp_type]` and `#[cgp_getter]`, you can now specify them directly without using the fully qualified key-value syntax.

For example:

```rust
#[cgp_type(FooTypeProviderComponent)]
pub trait HasFooType {
    type Foo;
}

#[cgp_getter(FooGettterComponent)]
pub trait HasFoo: HasFooType {
    fn foo(&self) -> &Self::Foo;
}
```

is equivalent to:


```rust
#[cgp_type {
    provider: FooTypeProviderComponent,
}]
pub trait HasFooType {
    type Foo;
}

#[cgp_getter {
    provider: FooGettterComponent,
}]
pub trait HasFoo: HasFooType {
    fn foo(&self) -> &Self::Foo;
}
```

---

# Bug Fixes

## Fix use of `new` in `delegate_components!` when keys array are used

We have fixed a bug in `delegate_components!`, when value expressions such as `UseDelegate<new InnerComponents { ... }>` are used together with multiple keys in a list.

For example, given the following:

```rust
delegate_components! {
    MyAppComponents {
        [
            FooComponent,
            BarComponent,
        ]:
            UseDelegate<new InnerComponents {
                u64: HandleNumber,
                String: HandleString,
            }>,
    }
}
```

Previously, the inner struct `InnerComponents` would be expanded twice. With this PR, the struct `InnerComponents` would be expanded once regardless of how many keys are in the delegate entry.

# Other Updates

## RustLab Presentation

Next month in November, I will be presenting about CGP at [RustLab](https://rustlab.it/talks/how-to-stop-fighting-with-coherence-and-start-writing-context-generic-trait-impls) in Florence, with the presentation titled [How to Stop Fighting with Coherence and Start Writing Context-Generic Trait Impls](https://rustlab.it/talks/how-to-stop-fighting-with-coherence-and-start-writing-context-generic-trait-impls).

If you are interested to attend the conference, you can use the discount code `SP20FR` for a 20% discount.

## `cgp-serde`

Together with the RustLab presentation, I am working on [`cgp-serde`](https://github.com/contextgeneric/cgp-serde) to provide an extensible version of the popular `serde` crate. Here is a sneak preview of what it is going to offer.

The crate offers context-generic versions of the `Serialize` and `Deserialize` traits as follows:

```rust
#[cgp_component {
    provider: ValueSerializer,
    derive_delegate: UseDelegate<Value>,
}]
pub trait CanSerializeValue<Value: ?Sized> {
    fn serialize<S>(&self, value: &Value, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer;
}

#[cgp_component {
    provider: ValueDeserializer,
    derive_delegate: UseDelegate<Value>,
}]
pub trait CanDeserializeValue<'de, Value> {
    fn deserialize<D>(&self, deserializer: D) -> Result<Value, D::Error>
    where
        D: serde::Deserializer<'de>;
}
```

The `cgp-serde` traits remain compatible with the original `serde` constructs. This means that we can reuse existing `serde` implementations without needing to re-implement everything to work with `cgp-serde`.

In addition to the existing capabilities, `cgp-serde` makes it possible for us to customize how specific field types should be serialized. For example, we can customize how `Vec<u8>` or `Datetime` should be serialized, without being restricted by the coherence restrictions of the trait system.

Another key feature that is unlocked by `cgp-serde` is that it unlocks the use of the ideas behind [context and capabilities](https://tmandry.gitlab.io/blog/posts/2021-12-21-context-capabilities/), and makes them usable with `serde`. For example, here is a CGP provider implementation that allocates memory for a value type using an arena allocator provided by the context:

```rust
#[cgp_new_provider]
impl<'de, 'a, Context, Value> ValueDeserializer<'de, Context, &'a Value>
    for DeserializeAndAllocate
where
    Context: CanAlloc<'a, Value> + CanDeserializeValue<'de, Value>,
{
    fn deserialize<D>(context: &Context, deserializer: D) -> Result<&'a Value, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let value = context.deserialize(deserializer)?;
        let value = context.alloc(value);

        Ok(value)
    }
}
```

With that, we can for example implement a deserialization context that provides an arena allocator, and use that to deserialize into a `&'a Payload` value.

Following shows an example deserializer context, together with some custom deserializer providers:

```rust
#[derive(CgpData)]
pub struct Payload { ... }

#[cgp_context]
#[derive(HasField)]
pub struct App<'a> {
    pub arena: &'a Arena<Payload>,
}

delegate_components! {
    AppComponents {
        ...,
        ValueDeserializerComponent:
            UseDelegate<new DeserializeComponents {
                u64:
                    UseSerde,
                Vec<u8>:
                    DeserializeHex,
                Payload:
                    DeserializeRecordFields,
                <'a> &'a Payload:
                    DeserializeAndAllocate,
                ...
            }>,
    }
}
```

As we can see in the above example, in the wiring for `ValueDeserializerComponent`, we use `UseDelegate` to create a table lookup for the deserialization implementation for different value types. We first use `UseSerde` to implement deserialization using the original `Deserialize` trait from `serde`. We then use `DeserializeHex` to deserialize a hex string into `Vec<u8>` bytes.

Next, we use `DeserializeRecordFields` to deserialize each field in `Payload` by using their respective value deserializers. This is made possible with the use of `#[derive(CgpData)]` on the `Payload` struct. It also demonstrates that we don't even need to derive any serialization trait on `Payload` in order to make it serializable using `cgp-serde`.

Finally, we use `DeserializeAndAllocate` to deserialize a `&'a Payload` value by allocating the payload into the arena allocator provided by the context.

There are many more details that I skipped here, that will need to be explained further along with the official release of `cgp-serde`. The crate is almost usable already, and the final work is on preparing for the remaining documentation.

I will also be demonstrating the use of `cgp-serde` at [RustLab](https://rustlab.it/talks/how-to-stop-fighting-with-coherence-and-start-writing-context-generic-trait-impls). So if you are interested to find out more, do come and join me at the conference!

# Acknowledgement

Thank you Abhishek Tripathi and Dzmitry Lahoda for [sponsoring](https://github.com/sponsors/soareschen) the development of CGP!
