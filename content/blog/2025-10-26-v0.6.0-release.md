+++

title = "CGP v0.6.0 Release - Major ergonomic improvements on provider and context implementations"

authors = ["Soares Chen"]

+++

# Overview

It has only been two weeks since [v0.5.0 was released](/blog/v0-5-0-release/). But here is a new major release of CGP v0.6.0, that is packed with some major improvements in the ergonomics of implementing CGP providers and contexts.

# Simplified provider implementation with `#[cgp_impl]`

The most significant improvement is that v0.6.0 introduces a new `#[cgp_impl]` macro that replaces the `#[cgp_provider]` macro and provides much better ergonomics for implementing provider traits in CGP.

In essence, `#[cgp_impl]` allows you to write a provider trait implementation as if it is a blanket implementation for the consumer trait. With this, the implementation of CGP providers become as intuitive as just implementing regular Rust traits.

## Example

Consider the following example trait:

```rust
#[cgp_component(HttpRequestFetcher)]
pub trait CanFetchHttpRequest: HasErrorType {
    fn fetch_http_request(&self, request: Request) -> Result<Response, Self::Error>;
}
```

With `#[cgp_impl]`, you can now implement a provider such as follows:

```rust
#[cgp_impl(new FetchWithHttpClient)]
impl<Context> HttpRequestFetcher for Context
where
    Self: HasHttpClient + HasErrorType,
{
    fn fetch_http_request(&self, request: Request) -> Result<Response, Self::Error> {
        ...
    }
}
```

Compared to before, you would have to implement the provider using `#[cgp_provider]` as follows:

```rust
#[cgp_new_provider]
impl<Context> HttpRequestFetcher<Context> for FetchWithHttpClient
where
    Context: HasHttpClient + HasErrorType,
{
    fn fetch_http_request(context: &Context, request: Request) -> Result<Response, Context::Error> {
        ...
    }
}
```

As we can see, the ergonomic for `#[cgp_impl]` is much closer to vanilla Rust trait implementation.

Behind the scene, `#[cgp_impl]` desugars the provider trait implementation to the same as how you would manually write it using `#[cgp_provider]`. So understanding of provider traits is still necessary, especially during debugging.

# Direct component delegation on context types

v0.6.0 also enables CGP context types to use `delegate_components!` directly, without needing to make use of a separate provider struct for the context. That is, we can now do:

```rust
pub struct App { ... }

delegate_components! {
    App {
        FooComponent: FooProvider,
        BarComponent: BarProvider,
        ...
    }
}
```

instead of the original:

```rust
#[cgp_context]
pub struct App { ... }

delegate_components! {
    AppComponents {
        FooComponent: FooProvider,
        BarComponent: BarProvider,
        ...
    }
}
```

This significantly reduces the ergonomics of wiring for the concrete context, as we no longer need to think of having a separate `AppComponents` provider to act as a type-level lookup table. Instead, the type-level lookup table is directly stored in `App`.

This should also slightly improve the compilation performance of compiling CGP code, as there is one less level of indirection for the trait solver to go through.

## Direct implementation of consumer traits

A significant advantage that arise is that we can now implement a consumer trait on a concrete context directly. For example:

```rust
#[cgp_getter]
pub trait HasName {
    fn name(&self) -> &str;
}

#[cgp_getter]
pub trait HasCount {
    fn count(&self) -> u32;
}

#[derive(HasField)]
pub struct App {
    pub name: String,
    pub count: u32,
}

delegate_components! {
    App {
        NameGetterComponent: UseField<Symbol!("name")>,
    }
}

// Consumer trait can now be implemented directly
impl HasCount for App {
    fn count(&self) -> u32 {
        self.count
    }
}
```
Previously, we would have to write:

```rust
#[cgp_provider]
impl CountGetter<App> for AppComponents {
    fn count(app: &App) -> u32 {
        app.count
    }
}
```

which makes the code look much worse especially for newcomers.

## Unlock use of `#[cgp_component]` on any trait

The simplification of the direct consumer trait implementation unlocks the ability for anyone to add `#[cgp_component]` on almost any existing Rust trait without breaking any existing code. This is significant, as it enables seamless onboarding of CGP without requiring the user to first learn about CGP.

As an example, we could in theory add `#[cgp_component]` to the [`Hash`](https://doc.rust-lang.org/std/hash/trait.Hash.html) trait:

```rust
#[cgp_component(HashProvider)]
pub trait Hash { ... }
```

This would not break any existing code that uses or implement `Hash`. But we will be able to write overlapping implementation of `Hash`, such as follows:

```rust
#[cgp_impl(HashWithDisplay)]
impl<T: Display> HashProvider for T {
    ...
}
```

We can then reuse the implementation on any type by using `delegate_components!`:

```rust
pub struct MyData { ... }

impl Display for MyData { ... }

delegate_components! {
    MyData {
        HashProviderComponent: HashWithDisplay,
    }
}
```

With this change, CGP can now benefit any existing Rust trait without changing how existing implementations are written. At the same time, by unlocking overlapping and orphan implementations, it is much more compelling for users to try out CGP, since the cost of using it has become much lower.

## Removal of `HasCgpProvider` trait

The consumer traits can be implemented directly, because we have now removed the `HasCgpProvider` trait from CGP. Instead of using `HasCgpProvider`, the blanket implementation for the consumer trait now also uses `DelegateComponent` in the same way as the provider trait's blanket implementation.

For example, the `HasName` trait earlier now has the following blanket implementation:

```rust
impl<Context> HasName for Context
where
    Context: DelegateComponent<NameGetterComponent>,
    Context::Delegate: NameGetter<Context>,
{
    fn name(&self) -> &str {
        Context::Delegate::name(self)
    }
}
```

While before this, the following was generated:


```rust
impl<Context> HasName for Context
where
    Context: HasCgpProvider,
    Context::CgpProvider: NameGetter<Context>,
{
    fn name(&self) -> &str {
        Context::CgpProvider::name(self)
    }
}
```

When `HasCgpProvider` was used, the blanket implementation of the consumer trait prevents any type that implements `HasCgpProvider` to also implement the consumer trait. But with the new derivation, the context can still implement the consumer trait even if it implements `DelegateComponent`, as long as the trait is not implemented for the key `NameGetterComponent`. This means that as long as we don't have any generic implementation of `DelegateComponent` on the context that might cover the component key, we would be able to implement the consumer trait directly.

## Backward Compatibility

Since there are already quite some existing code bases that use CGP, completely removing the context provider might cause significant breakage. Fortunately, we can work around the breakage by changing `#[cgp_context]` to perform a bulk `DelegateComponent<Name>` for all `Name` type.

For example, given:

```rust
#[cgp_context]
pub struct App { ... }
```

The macro now generates:

```rust
pub struct AppComponents;

impl<Name> DelegateComponent<Name> for App {
    type Delegate = AppComponents;
}
```

With this, the bulk delegation essentially serves the same role as the use of `HasCgpProvider`, which was generated before this change:


```rust
pub struct AppComponents;

impl HasCgpProvider for App {
    type CgpProvider = AppComponents;
}
```

## Background

I'd like to provide a little bit of background of why `HasCgpProvider` was initially used in the blanket implementation, as compared to just use `DelegateComponent` like the design here.

Originally, I had the idea that multiple concrete contexts could share the same provider "table". For example:

```rust
pub struct AppComponents;

pub struct AppA { ... }
pub struct AppB { ... }

impl HasCgpProvider for AppA {
    type CgpProvider = AppComponents;
}

impl HasCgpProvider for AppB {
    type CgpProvider = AppComponents;
}
```

In this design, we could reuse the same component wiring for different applications, without needing to reconfigure them every time.

However, there is always some cases that two concrete context would share almost the same wiring, except for a handful of customization. This eventually lead to the development of the preset feature, which provide the same functionality as what shared context providers are supposed to serve.

As a result, the context providers were largely an artifact from the early design of CGP. However, it lingered for a long time, as I was worried that changing it would cause too much breakage to existing code.

Recently, I thought about this issue again, and I realized that I could mostly preserve the backward compatibility by modifying `#[cgp_context]` to generate a blanket implementation of `DelegateComponent`. As a result, the backward compatibility problem is largely resolved, and I am now able to push this change for the next major release.

# Introduce `#[cgp_inherit]` macro

With the deprecation of `#[cgp_context]`, we need a different way for concrete contexts to inherit from a preset. v0.6.0 introduces a new `#[cgp_inherit]` macro that can be used for a context to inherit from a preset.

## Example

Given the following:

```rust
#[cgp_inherit(MyPreset)]
pub struct App { ... }
```

is roughly equivalent to the use of preset inheritance in `#[cgp_context]`

```rust
#[cgp_context(AppComponents: MyPreset)]
pub struct App { ... }
```

The main difference between `#[cgp_inherit]` and `#[cgp_context]` is that the present inheritance is now done directly on the `App` context, and there is no longer need to generate an `AppComponents` provider type that inherits from `MyPreset`.

Behind the scene, the following is generated:

```rust
impl<Name> DelegateComponent<Name> for App
where
    Self: MyPreset::IsPreset<Name>,
    MyPreset::Components: DelegateComponent<Name>,
{
    type Delegate = <MyPreset::Components as DelegateComponent<Name>>::Delegate;
}

impl<Name, Context, Params> IsProviderFor<Name, Context, Params>
    for App
where
    Self: MyPreset::IsPreset<Name>,
    MyPreset::Components: IsProviderFor<Name, Context, Params>,
{
}
```

Note that even with the blanket implementation of `DelegateComponent`, we can still implement consumer traits for `App` if the given component key is not found in the preset.

# Migration Guide

In most cases, you should be able to upgrade to v0.6.0 without needing to update any existing code.

## Removal of `HasCgpProvider` trait

The main breaking change in v0.6.0 is the removal of the `HasCgpProvider` trait, and the change in how the blanket implementation of the consumer trait is generated. However, since the majority of CGP code are not supposed to directly interact with these constructs, they should not be affected by the breaking changes.

## Deprecation of `#[cgp_context]`

The `#[cgp_context]` macro has been updated to maintain backward compatibility with existing code that make use of the context provider. However, it is highly recommended that you remove the use of `#[cgp_context]` when upgrading to v0.6.0, so that you can gain the benefit of implementing consumer traits directly on your context.

## Deprecation of `#[cgp_provider]`

The new `#[cgp_impl]` macro eliminates the need to use `#[cgp_provider]` to define provider implementations. With v0.6.0, any existing use of `#[cgp_provider]` will continue to work. However, it is highly recommended that you migrate to use `#[cgp_impl]` when writing new provider implementation, since it makes the code much more readable.

It is also highly recommended that you migrate all existing use of `#[cgp_provider]` to use `#[cgp_impl]`, especially if there are more than one contributor to your project. This is mainly because if the project uses both `#[cgp_impl]` and `#[cgp_provider]`, it could bring confusion to readers who are new to CGP and make them wonder about the difference between the two styles. On the other hand, `#[cgp_impl]` can work almost seamlessly with any Rust user without requiring prior experience with CGP, since it can effectively be understood as a named blanket implementation.
