<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Overview | Context-Generic Programming </title>
    <meta property="og:title" content="Context-Generic Programming" />
    <meta property="og:description" content="Context-Generic Programming: Modular programming paradigm for Rust">
    <meta property="og:image" content="https://contextgeneric.dev/cgp-logo.png">
    <meta name="twitter:title" content="Context-Generic Programming">
    <meta name="twitter:description" content="Context-Generic Programming: Modular programming paradigm for Rust">
    <meta name="twitter:image" content="https://contextgeneric.dev/cgp-logo.png">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    
<link rel="icon" type="image/png" href="/favicon.png" />

    <style>
  :root {
    /* Primary theme color */
    --primary-color: #FFF5DA;
    /* Primary theme text color */
    /* --primary-text-color: #543631; */
    --primary-text-color: #000;
    --primary-text-color-over: #000;
    --primary-heading-color: #5D0705;
    /* Primary theme link color */
    --primary-link-color: #8F1F1D;
    /* Secondary color: the background body color */
    --secondary-color: #FCF7E9;
    --secondary-text-color: #303030;
    /* Highlight text color of table of content */
    --toc-highlight-text-color: #8F1F1D;
    --toc-background-color: white;
    --shadow-color: #ddd;
    /* Font used for headers (h1 & h2) */
    --header-font-family: "Fira Sans", sans-serif;
    /* Font used for text */
    --text-font-family: "Fira Sans", sans-serif;
  }
</style>
    
    <link href="https://fonts.googleapis.com/css?family=Alfa+Slab+One&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Fira+Sans:400,500,600&display=swap" rel="stylesheet">
    
    <link rel="stylesheet" href="/normalize.css">
    <link rel="stylesheet" href="https://www.contextgeneric.dev/juice.css">
    
    <link rel="stylesheet" href="https://www.contextgeneric.dev/carbon.css">
    
    <link rel="alternate" type="application/atom+xml" title="Context-Generic Programming Atom Feed" href="/atom.xml">
</head>

<body>
    
<header class="box-shadow">
    

<a href="https://www.contextgeneric.dev/">
    <div class="logo">
        <img src="https://www.contextgeneric.dev/cgp-logo.svg" alt="logo">
        Context-Generic Programming
    </div>
</a>

<nav>
    
    
    
    <a class="nav-item subtitle-text" href="https://www.contextgeneric.dev/overview/">Overview</a>
    
    
    
    
    <a class="nav-item subtitle-text" href="https://www.contextgeneric.dev/contribute/">Contribute</a>
    
    
    
    
    <a class="nav-item subtitle-text" href="https://www.contextgeneric.dev/resources/">Resources</a>
    
    
    
        
        <a class="nav-item subtitle-text" href="/blog">Blog</a>
        
        <a class="nav-item subtitle-text" href="https://patterns.contextgeneric.dev">Book</a>
        
        <a class="nav-item subtitle-text" href="https://github.com/contextgeneric/cgp">GitHub</a>
        
    
</nav>

</header>


    <main>
        
        
        
        
        
        <div class="toc">
            <div class="toc-sticky">
                
                <div class="toc-item">
                    <a class="subtext" href="https://www.contextgeneric.dev/overview/#overview">Overview</a>
                </div>
                
                
                <div class="toc-item">
                    <a class="subtext" href="https://www.contextgeneric.dev/overview/#key-features">Key Features</a>
                </div>
                
                
                <div class="toc-item-child">
                    <a class="subtext" href="https://www.contextgeneric.dev/overview/#modular-component-system"><small>- Modular Component System</small></a>
                </div>
                
                <div class="toc-item-child">
                    <a class="subtext" href="https://www.contextgeneric.dev/overview/#highly-expressive-macros"><small>- Highly Expressive Macros</small></a>
                </div>
                
                <div class="toc-item-child">
                    <a class="subtext" href="https://www.contextgeneric.dev/overview/#type-safe-composition"><small>- Type-Safe Composition</small></a>
                </div>
                
                <div class="toc-item-child">
                    <a class="subtext" href="https://www.contextgeneric.dev/overview/#no-std-friendly"><small>- No-Std Friendly</small></a>
                </div>
                
                <div class="toc-item-child">
                    <a class="subtext" href="https://www.contextgeneric.dev/overview/#zero-cost-abstraction"><small>- Zero-Cost Abstraction</small></a>
                </div>
                
                
                
                <div class="toc-item">
                    <a class="subtext" href="https://www.contextgeneric.dev/overview/#problems-solved">Problems Solved</a>
                </div>
                
                
                <div class="toc-item-child">
                    <a class="subtext" href="https://www.contextgeneric.dev/overview/#error-handling"><small>- Error Handling</small></a>
                </div>
                
                <div class="toc-item-child">
                    <a class="subtext" href="https://www.contextgeneric.dev/overview/#async-runtime"><small>- Async Runtime</small></a>
                </div>
                
                <div class="toc-item-child">
                    <a class="subtext" href="https://www.contextgeneric.dev/overview/#overlapping-implementations"><small>- Overlapping Implementations</small></a>
                </div>
                
                <div class="toc-item-child">
                    <a class="subtext" href="https://www.contextgeneric.dev/overview/#dynamic-dispatch"><small>- Dynamic Dispatch</small></a>
                </div>
                
                <div class="toc-item-child">
                    <a class="subtext" href="https://www.contextgeneric.dev/overview/#monolithic-traits"><small>- Monolithic Traits</small></a>
                </div>
                
                
                
            </div>
        </div>
        
        

        <div class="content text">
            <div>
                
<div class="heading-text"></div>
<h1 id="overview"><a class="zola-anchor" href="#overview" aria-label="Anchor link for: overview">Overview</a></h1>
<p>This page provides a quick overview and highlight the key features of CGP. For a deeper dive into the concepts and patterns of CGP, explore our comprehensive book, <a href="https://patterns.contextgeneric.dev/">Context-Generic Programming Patterns</a>.</p>
<h1 id="key-features"><a class="zola-anchor" href="#key-features" aria-label="Anchor link for: key-features">Key Features</a></h1>
<p>This section highlights some of the key advantages that Context-Generic Programming (CGP) offers.</p>
<h2 id="modular-component-system"><a class="zola-anchor" href="#modular-component-system" aria-label="Anchor link for: modular-component-system">Modular Component System</a></h2>
<p>CGP leverages Rust's powerful trait system to define generic component <em>interfaces</em> that decouple the code that <em>consumes</em> an interface from the code that <em>implements</em> it. This is achieved by introducing:</p>
<ul>
<li><strong>Provider traits</strong>, which define the implementation of a component interface.</li>
<li><strong>Consumer traits</strong>, which specify how a component interface is consumed.</li>
</ul>
<p>By separating provider traits from consumer traits, CGP enables multiple context-generic provider implementations to coexist. This approach circumvents Rust's usual limitation on overlapping or orphaned trait implementations, offering greater flexibility and modularity.</p>
<h2 id="highly-expressive-macros"><a class="zola-anchor" href="#highly-expressive-macros" aria-label="Anchor link for: highly-expressive-macros">Highly Expressive Macros</a></h2>
<p>CGP empowers developers to write <em>abstract programs</em> that are generic over a context, including all its associated types and methods. This capability eliminates the need to explicitly specify an extensive list of generic parameters in type signatures, streamlining code structure and readability.</p>
<p>Additionally, CGP offers powerful <em>macros</em> for defining component interfaces and simplifies the process of wiring component implementations for use with a specific context.</p>
<p>With CGP, Rust code can achieve a level of expressiveness comparable to, if not exceeding, that of other popular programming paradigms, such as object-oriented programming and dynamically typed programming.</p>
<h2 id="type-safe-composition"><a class="zola-anchor" href="#type-safe-composition" aria-label="Anchor link for: type-safe-composition">Type-Safe Composition</a></h2>
<p>CGP leverages Rust's robust type system to guarantee that all component wiring is <em>type-safe</em>, ensuring that any missing dependencies are caught at compile time. It operates entirely within safe Rust, avoiding dynamic typing techniques such as <code>dyn traits</code>, <code>Any</code>, or runtime reflection.</p>
<p>This strict adherence to type safety ensures that no CGP-specific errors can occur during application runtime, providing developers with greater confidence in their code's reliability.</p>
<h2 id="no-std-friendly"><a class="zola-anchor" href="#no-std-friendly" aria-label="Anchor link for: no-std-friendly">No-Std Friendly</a></h2>
<p>CGP enables the creation of <em>fully abstract programs</em> that can be defined without relying on any concrete dependencies â€” except for other abstract CGP components. This abstraction extends to dependencies such as I/O, runtime, cryptographic operations, and encoding schemes, allowing these concerns to be separated from the core application logic.</p>
<p>As a result, the core logic of an application can be seamlessly instantiated with specialized dependencies, making it compatible with no-std environments. These include embedded systems, operating system kernels, sandboxed environments like WebAssembly, and symbolic execution platforms such as Kani.</p>
<h2 id="zero-cost-abstraction"><a class="zola-anchor" href="#zero-cost-abstraction" aria-label="Anchor link for: zero-cost-abstraction">Zero-Cost Abstraction</a></h2>
<p>CGP operates entirely at compile-time, leveraging Rust's type system to ensure correctness without introducing runtime overhead. This approach upholds Rust's hallmark of <em>zero-cost abstraction</em>, enabling developers to use CGP's features without sacrificing runtime performance.</p>
<h1 id="problems-solved"><a class="zola-anchor" href="#problems-solved" aria-label="Anchor link for: problems-solved">Problems Solved</a></h1>
<p>Here are some common problems in Rust that CGP helps to address.</p>
<h2 id="error-handling"><a class="zola-anchor" href="#error-handling" aria-label="Anchor link for: error-handling">Error Handling</a></h2>
<p>Rather than being tied to a specific error crate like <code>anyhow</code> or <code>eyre</code>, CGP's <code>HasErrorType</code> and <code>CanRaiseError</code> traits allow the decoupling of core application logic from error handling. This enables concrete applications to choose their preferred error library and select the error-handling strategy that best suits their needs, such as deciding whether or not to include stack traces in errors.</p>
<p>For more detailed information on error handling, refer to the <a href="https://patterns.contextgeneric.dev/error-handling.html">error handling chapter</a> in our book</p>
<h2 id="async-runtime"><a class="zola-anchor" href="#async-runtime" aria-label="Anchor link for: async-runtime">Async Runtime</a></h2>
<p>Rather than committing to a specific runtime crate like <code>tokio</code> or <code>async-std</code>, CGP enables the application core logic to rely on an abstract runtime context that provides only the features required by the application.</p>
<p>Unlike monolithic runtime traits, an abstract runtime context in CGP does <em>not</em> require a comprehensive or upfront design of all possible runtime features any application might need. This flexibility allows easy switching between concrete runtime implementations, depending on the specific runtime features the application utilizes.</p>
<h2 id="overlapping-implementations"><a class="zola-anchor" href="#overlapping-implementations" aria-label="Anchor link for: overlapping-implementations">Overlapping Implementations</a></h2>
<p>A common frustration among Rust programmers is the restriction on overlapping trait implementations. A typical workaround is to use newtype wrappers, but this can become cumbersome when dealing with multiple composite types that need to be extended.</p>
<p>Rust requires a crate to own either the type or the trait for a trait implementation, which often places a significant burden on the author of a new type to implement all the common traits their users might need. This can lead to bloated type definitions, with excessive trait implementations such as <code>Eq</code>, <code>Clone</code>, <code>TryFrom</code>, <code>Hash</code>, and <code>Serialize</code>. Despite careful design, libraries may still face requests from users to implement less common traits, which can only be implemented by the crate that owns the type.</p>
<p>With the introduction of <em>provider traits</em>, CGP removes these restrictions on overlapping implementations. Both the owner and non-owners of a type can define custom implementations for that type. When multiple provider implementations are available, users can choose one and wire it up easily using CGP constructs.</p>
<p>CGP also favors the use of <em>abstract types</em> over newtype wrappers. For instance, a type like <code>f64</code> can be directly used for both <code>Context::Distance</code> and <code>Context::Weight</code>, with the associated types still treated as distinct within the abstract code. CGP also enables specialized provider implementations, even if the crate does not own the primitive type (e.g., <code>f64</code>) or the provider trait.</p>
<h2 id="dynamic-dispatch"><a class="zola-anchor" href="#dynamic-dispatch" aria-label="Anchor link for: dynamic-dispatch">Dynamic Dispatch</a></h2>
<p>A common approach for newcomers to support polymorphism in Rust is to use dynamic dispatch with <code>dyn Trait</code> objects. However, this severely limits the functionality to a restricted subset of <em>dyn-compatible</em> (object-safe) features in Rust. Often, this limitation spreads throughout the entire codebase, requiring non-trivial workarounds for non-dyn-compatible constructs, such as <code>Clone</code>.</p>
<p>Even when dynamic dispatch is not used, many Rust programmers rely on ad-hoc polymorphism, defining enums to represent all potential variants of types in the application. This results in numerous <code>match</code> expressions scattered across the codebase, making it difficult to decouple logic for each branch. Additionally, adding new variants to the enum becomes challenging, as every branch must be updated, even when the new variant is only used in a small portion of the code.</p>
<p>CGP provides several solutions to address the dynamic dispatch problem by delegating the "assembly" of the variant collection to the concrete context. The core application logic can be written generically over the context and the associated type representing the abstract enum. CGP also facilitates powerful datatype-generic patterns that allow providers for each variant to be implemented separately and combined to work with enums that contain any combination of variants.</p>
<h2 id="monolithic-traits"><a class="zola-anchor" href="#monolithic-traits" aria-label="Anchor link for: monolithic-traits">Monolithic Traits</a></h2>
<p>Even without CGP, Rust's trait system provides powerful mechanisms for building abstractions that would be difficult to achieve in other mainstream languages. One common best practice is to write abstract code that is generic over a context type, but this often involves an implicit trait bound tied directly to the generic context.</p>
<p>Unlike CGP, traits in this pattern are typically designed as monolithic, encompassing all the dependencies that the core application might need. Without CGP, an abstract caller must also include all trait bounds required by the generic functions it invokes. As a result, any additional generic trait bounds tend to propagate throughout the codebase, leading developers to combine all these trait bounds into one monolithic trait for convenience.</p>
<p>Monolithic traits can quickly become bottlenecks that prevent large projects from scaling. It's not uncommon for such traits to become bloated with dozens or even hundreds of methods and types. This overgrowth makes it increasingly difficult to introduce new implementations or modify existing ones. Additionally, with Rust's current practices, breaking down or decoupling these monolithic traits into smaller, more manageable traits can be challenging.</p>
<p>CGP offers significant improvements over this traditional pattern, making it possible to write abstract Rust code without the risk of creating unwieldy, monolithic traits. CGP enables the decomposition of large traits into many small, focused traits, each ideally consisting of just a single method or type. This is made possible by the dependency injection pattern used in CGP, which allows implementations to introduce only the minimal trait bounds they need directly within the implementation, rather than bundling everything into a single, monolithic structure.</p>


            </div>
        </div>

        

    </main>

    
<footer>
    <small class="subtext" style="text-align: center;">
        <a href="https://maybevoid.com">MaybeVoid</a> Â© 2024
        <br />
        <a href="https://creativecommons.org/licenses/by-sa/4.0/?ref=chooser-v1" target="_blank" rel="license noopener noreferrer" style="display:inline-block;">
            CC BY-SA 4.0<img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/cc.svg?ref=chooser-v1" alt=""><img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/by.svg?ref=chooser-v1" alt=""><img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/sa.svg?ref=chooser-v1" alt="">
        </a>
    </small>
</footer>

</body>
<script>
    const scrollHandler = entries => {
        // Find the first entry which intersecting and ratio > 0.9 to highlight.
        let entry = entries.find(entry => {
            return entry.isIntersecting && entry.intersectionRatio > 0.9;
        });
        if (!entry) return;

        document.querySelectorAll(".toc a").forEach((item) => {
            item.classList.remove("active");
        });

        // let url = new URL(`#${entry.target.id}`);
        let link = document.querySelector(`.toc a[href$="${decodeURIComponent(`#${entry.target.id}`)}"]`)
        if (link) {
            link.classList.add("active");
            link.scrollIntoView({ behavior: "auto", block: "nearest" });
        }
    };
    // Set -100px root margin to improve highlight experience.
    const observer = new IntersectionObserver(scrollHandler, { threshold: 1 });
    let items = document.querySelectorAll('h1,h2,h3,h4,h5,h6');
    items.forEach(item => observer.observe(item));
</script>

</html>
