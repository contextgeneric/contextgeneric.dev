<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Hello World Tutorial | Context-Generic Programming</title>
    <meta property="og:title" content="Hello World Tutorial | Context-Generic Programming" />
    <meta property="og:description" content="">
    <meta property="og:image" content="https://contextgeneric.dev/cgp-logo.png">
    <meta name="twitter:title" content="Hello World Tutorial | Context-Generic Programming">
    <meta name="twitter:description" content="">
    <meta name="twitter:image" content="https://contextgeneric.dev/cgp-logo.png">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    
<link rel="icon" type="image/png" href="/favicon.png" />

    <style>
  :root {
    /* Primary theme color */
    --primary-color: #FFF5DA;
    /* Primary theme text color */
    /* --primary-text-color: #543631; */
    --primary-text-color: #000;
    --primary-text-color-over: #000;
    --primary-heading-color: #5D0705;
    /* Primary theme link color */
    --primary-link-color: #8F1F1D;
    /* Secondary color: the background body color */
    --secondary-color: #FCF7E9;
    --secondary-text-color: #303030;
    /* Highlight text color of table of content */
    --toc-highlight-text-color: #8F1F1D;
    --toc-background-color: white;
    --shadow-color: #ddd;
    /* Font used for headers (h1 & h2) */
    --header-font-family: "Fira Sans", sans-serif;
    /* Font used for text */
    --text-font-family: "Fira Sans", sans-serif;
  }
</style>
    
    <link href="https://fonts.googleapis.com/css?family=Alfa+Slab+One&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Fira+Sans:400,500,600&display=swap" rel="stylesheet">
    
    <link rel="stylesheet" href="/normalize.css">
    <link rel="stylesheet" href="https://www.contextgeneric.dev/juice.css">
    
    <link rel="stylesheet" href="https://www.contextgeneric.dev/carbon.css">
    
    <link rel="alternate" type="application/atom+xml" title="Context-Generic Programming Atom Feed" href="/atom.xml">
</head>

<body>
    
<header class="box-shadow">
    

<a href="https://www.contextgeneric.dev/">
    <div class="logo">
        <img src="https://www.contextgeneric.dev/cgp-logo.svg" alt="logo">
        Context-Generic Programming
    </div>
</a>

<nav>
    
    
    
    <a class="nav-item subtitle-text" href="https://www.contextgeneric.dev/overview/">Overview</a>
    
    
    
    
    <a class="nav-item subtitle-text" href="https://www.contextgeneric.dev/contribute/">Contribute</a>
    
    
    
    
    <a class="nav-item subtitle-text" href="https://www.contextgeneric.dev/resources/">Resources</a>
    
    
    
        
        <a class="nav-item subtitle-text" href="/blog">Blog</a>
        
        <a class="nav-item subtitle-text" href="https://patterns.contextgeneric.dev">Book</a>
        
        <a class="nav-item subtitle-text" href="https://github.com/contextgeneric/cgp">GitHub</a>
        
    
</nav>

</header>


    <main>
        
        
        
        
        
        <div class="toc">
            <div class="toc-sticky">
                
                <div class="toc-item">
                    <a class="subtext" href="https://www.contextgeneric.dev/tutorials/hello/#greeter-component">Greeter Component</a>
                </div>
                
                
                <div class="toc-item">
                    <a class="subtext" href="https://www.contextgeneric.dev/tutorials/hello/#name-getter">Name Getter</a>
                </div>
                
                
                <div class="toc-item">
                    <a class="subtext" href="https://www.contextgeneric.dev/tutorials/hello/#hello-greeter">Hello Greeter</a>
                </div>
                
                
                <div class="toc-item">
                    <a class="subtext" href="https://www.contextgeneric.dev/tutorials/hello/#person-context">Person Context</a>
                </div>
                
                
                <div class="toc-item">
                    <a class="subtext" href="https://www.contextgeneric.dev/tutorials/hello/#delegate-components">Delegate Components</a>
                </div>
                
                
                <div class="toc-item">
                    <a class="subtext" href="https://www.contextgeneric.dev/tutorials/hello/#calling-greet">Calling Greet</a>
                </div>
                
                
                <div class="toc-item">
                    <a class="subtext" href="https://www.contextgeneric.dev/tutorials/hello/#conclusion">Conclusion</a>
                </div>
                
                
                <div class="toc-item">
                    <a class="subtext" href="https://www.contextgeneric.dev/tutorials/hello/#full-example-code">Full Example Code</a>
                </div>
                
                
            </div>
        </div>
        
        

        <div class="content text">
            <div>
                
<div class="heading-text">Hello World Tutorial</div>
<div><p>We will demonstrate various concepts of CGP with a simple hello world example.</p>
<h2 id="greeter-component"><a class="zola-anchor" href="#greeter-component" aria-label="Anchor link for: greeter-component">Greeter Component</a></h2>
<p>To begin, we import the <code>cgp</code> crate and define a greeter component as follows:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#569cd6;">use </span><span>cgp::prelude::*;
</span><span>
</span><span>#[cgp_component(Greeter)]
</span><span style="color:#569cd6;">pub trait </span><span>CanGreet {
</span><span>    </span><span style="color:#569cd6;">fn </span><span>greet(</span><span style="color:#569cd6;">&amp;</span><span>self);
</span><span>}
</span></code></pre>
<p>The <code>cgp</code> crate provides common constructs through its <code>prelude</code> module, which should be imported in most cases. The first CGP construct we use here is the <code>#[cgp_component]</code> macro. This macro generates additional CGP constructs for the greeter component.</p>
<p>The target of this macro, <code>CanGreet</code>, is a <strong>consumer trait</strong> used similarly to regular Rust traits. However, unlike traditional traits, we won't implement anything directly on this trait.</p>
<p>In its simplified form, the argument to the macro, <code>Greeter</code>, designates a <strong>provider trait</strong> for the component. The <code>Greeter</code> provider is used to define the actual implementations for the greeter component. It has a similar structure to <code>CanGreet</code>, but with the implicit <code>Self</code> type replaced by a generic <code>Context</code> type.</p>
<p>The macro also generates an empty <code>GreeterComponent</code> struct, which is used as the <em>name</em> of the greeter component which can be used for the component wiring later on.</p>
<h2 id="name-getter"><a class="zola-anchor" href="#name-getter" aria-label="Anchor link for: name-getter">Name Getter</a></h2>
<p>Now, we will define an <em>getter trait</em> to retrieve the name value from a context:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span>#[cgp_auto_getter]
</span><span style="color:#569cd6;">pub trait </span><span>HasName {
</span><span>    </span><span style="color:#569cd6;">fn </span><span>name(</span><span style="color:#569cd6;">&amp;</span><span>self) -&gt; </span><span style="color:#569cd6;">&amp;str</span><span>;
</span><span>}
</span></code></pre>
<p>The <code>HasName</code> trait contains the getter method <code>name</code>, which returns a <code>&amp;str</code> string value.</p>
<p>The <code>#[cgp_auto_getter]</code> attribute macro applied to <code>HasName</code> automatically generates a blanket implementation. This enables any context containing a field named <code>name</code> of type <code>String</code> to automatically implement the <code>HasName</code> trait.</p>
<h2 id="hello-greeter"><a class="zola-anchor" href="#hello-greeter" aria-label="Anchor link for: hello-greeter">Hello Greeter</a></h2>
<p>The traits <code>CanGreet</code> and <code>HasName</code> can be defined separately across different modules or crates. However, we can import them into a single location and then implement a <code>Greeter</code> provider that uses <code>HasName</code> in its implementation:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span>#[cgp_impl(new GreetHello)]
</span><span style="color:#569cd6;">impl</span><span>&lt;Context&gt; Greeter </span><span style="color:#569cd6;">for </span><span>Context
</span><span style="color:#569cd6;">where
</span><span>    Context: HasName,
</span><span>{
</span><span>    </span><span style="color:#569cd6;">fn </span><span>greet(</span><span style="color:#569cd6;">&amp;</span><span>self) {
</span><span>        println!(</span><span style="color:#d69d85;">&quot;Hello, </span><span style="color:#b4cea8;">{}</span><span style="color:#d69d85;">!&quot;</span><span>, self.name());
</span><span>    }
</span><span>}
</span></code></pre>
<p>We use <code>#[cgp_impl]</code> to define a new provider, called <code>GreetHello</code>, which implements the <code>Greeter</code> provider trait. The implementation is written to be <strong>generic</strong> over any <code>Context</code> type that implements <code>HasName</code>.</p>
<p>Normally, it would not be possible to write a blanket implementation like this in vanilla Rust, due to it violating the <em>overlapping</em> and <em>orphan</em> rules of Rust traits. However, the use of <code>#[cgp_impl]</code> and the <code>Greeter</code> provider trait allows us to <strong>bypass</strong> this restriction.</p>
<p>Behind the scene, the macro generates an empty struct named <code>GreetHello</code>, which is used as an <em>identifier</em> of the provider that implements the <code>Greeter</code> trait.</p>
<p>Notice that the constraint <code>HasName</code> is specified only in the <code>impl</code> block, not in the trait bounds for <code>CanGreet</code> or <code>Greeter</code>. This design allows us to use <em>dependency injection</em> for both values and <em>types</em> through Rust’s trait system.</p>
<h2 id="person-context"><a class="zola-anchor" href="#person-context" aria-label="Anchor link for: person-context">Person Context</a></h2>
<p>Next, we define a concrete context, <code>Person</code>, and wire it up to use <code>GreetHello</code> for implementing CanGreet:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span>#[derive(HasField)]
</span><span style="color:#569cd6;">pub struct </span><span>Person {
</span><span>    </span><span style="color:#569cd6;">pub </span><span>name: String,
</span><span>}
</span></code></pre>
<p>The <code>Person</code> context is defined as a struct containing a <code>name</code> field of type <code>String</code>.</p>
<p>We use the <code>#[derive(HasField)]</code> macro to automatically derive <code>HasField</code> implementations for every field in <code>Person</code>. This works together with the blanket implementation generated by <code>#[cgp_auto_getter]</code> for <code>HasName</code>, allowing <code>HasName</code> to be automatically implemented for <code>Person</code> without requiring any additional code.</p>
<h2 id="delegate-components"><a class="zola-anchor" href="#delegate-components" aria-label="Anchor link for: delegate-components">Delegate Components</a></h2>
<p>Next, we want to define some wirings to link up the <code>GreetHello</code> that we defined earlier, so that we can use it on the <code>Person</code> context. This is done by using the <code>delegate_components!</code> macro as follows:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span>delegate_components! {
</span><span>    Person {
</span><span>        GreeterComponent:
</span><span>            GreetHello,
</span><span>    }
</span><span>}
</span></code></pre>
<p>We use the <code>delegate_components!</code> macro to perform the wiring of <code>Person</code> context with the chosen providers for each CGP component that we want to use with <code>Person</code>. For each entry in <code>delegate_components!</code>, we use the component name type as the key, and the chosen provider as the value.</p>
<p>The mapping <code>GreeterComponent: GreetHello</code> indicates that we want to use <code>GreetHello</code> as the implementation of the <code>CanGreet</code> consumer trait.</p>
<h2 id="calling-greet"><a class="zola-anchor" href="#calling-greet" aria-label="Anchor link for: calling-greet">Calling Greet</a></h2>
<p>Now that the wiring is set up, we can construct a <code>Person</code> instance and call <code>greet</code> on it:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#569cd6;">fn </span><span>main() {
</span><span>    </span><span style="color:#569cd6;">let</span><span> person = Person {
</span><span>        name: </span><span style="color:#d69d85;">&quot;Alice&quot;</span><span>.into(),
</span><span>    };
</span><span>
</span><span>    </span><span style="color:#608b4e;">// prints &quot;Hello, Alice!&quot;
</span><span>    person.greet();
</span><span>}
</span></code></pre>
<p>This is made possible by a series of blanket implementations generated by CGP. Here's how the magic works:</p>
<ul>
<li>We can call <code>greet</code> because <code>CanGreet</code> is implemented for <code>Person</code>.</li>
<li><code>Person</code> contains the <code>delegate_components!</code> mapping that uses <code>GreetHello</code> as the provider for <code>GreeterComponent</code>.</li>
<li><code>GreetHello</code> implements <code>Greeter</code> for <code>Person</code>.</li>
<li><code>Person</code> implements <code>HasName</code> via the <code>HasField</code> implementation.</li>
</ul>
<p>There’s quite a bit of indirection happening behind the scenes!</p>
<h2 id="conclusion"><a class="zola-anchor" href="#conclusion" aria-label="Anchor link for: conclusion">Conclusion</a></h2>
<p>By the end of this tutorial, you should have a high-level understanding of how programming in CGP works. There's much more to explore regarding how CGP handles the wiring behind the scenes, as well as the many features and capabilities CGP offers. To dive deeper, check out our book <a href="https://patterns.contextgeneric.dev/">Context-Generic Programming Patterns</a>.</p>
<h2 id="full-example-code"><a class="zola-anchor" href="#full-example-code" aria-label="Anchor link for: full-example-code">Full Example Code</a></h2>
<p>Below, we show the full hello world example code, so that you can walk through them again without the text.</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#569cd6;">use </span><span>cgp::prelude::*; </span><span style="color:#608b4e;">// Import all CGP constructs
</span><span>
</span><span style="color:#608b4e;">// Derive CGP provider traits and blanket implementations
</span><span>#[cgp_component(Greeter)]
</span><span style="color:#569cd6;">pub trait </span><span>CanGreet </span><span style="color:#608b4e;">// Name of the consumer trait
</span><span>{
</span><span>    </span><span style="color:#569cd6;">fn </span><span>greet(</span><span style="color:#569cd6;">&amp;</span><span>self);
</span><span>}
</span><span>
</span><span style="color:#608b4e;">// A getter trait representing a dependency for `name` value
</span><span>#[cgp_auto_getter] </span><span style="color:#608b4e;">// Derive blanket implementation
</span><span style="color:#569cd6;">pub trait </span><span>HasName {
</span><span>    </span><span style="color:#569cd6;">fn </span><span>name(</span><span style="color:#569cd6;">&amp;</span><span>self) -&gt; </span><span style="color:#569cd6;">&amp;str</span><span>;
</span><span>}
</span><span>
</span><span style="color:#608b4e;">// Implement `Greeter` that is generic over `Context`
</span><span>#[cgp_impl(new GreetHello)]
</span><span style="color:#569cd6;">impl</span><span>&lt;Context&gt; Greeter </span><span style="color:#569cd6;">for </span><span>Context
</span><span style="color:#569cd6;">where
</span><span>    Context: HasName, </span><span style="color:#608b4e;">// Inject the `name` dependency from `Context`
</span><span>{
</span><span>    </span><span style="color:#569cd6;">fn </span><span>greet(</span><span style="color:#569cd6;">&amp;</span><span>self) {
</span><span>        println!(</span><span style="color:#d69d85;">&quot;Hello, </span><span style="color:#b4cea8;">{}</span><span style="color:#d69d85;">!&quot;</span><span>, self.name());
</span><span>    }
</span><span>}
</span><span>
</span><span style="color:#608b4e;">// A concrete context that uses CGP components
</span><span>#[derive(HasField)] </span><span style="color:#608b4e;">// Deriving `HasField` automatically implements `HasName`
</span><span style="color:#569cd6;">pub struct </span><span>Person {
</span><span>    </span><span style="color:#569cd6;">pub </span><span>name: String,
</span><span>}
</span><span>
</span><span style="color:#608b4e;">// Compile-time wiring of CGP components
</span><span>delegate_components! {
</span><span>    Person {
</span><span>        GreeterComponent: GreetHello, </span><span style="color:#608b4e;">// Use `GreetHello` to provide `Greeter`
</span><span>    }
</span><span>}
</span><span>
</span><span style="color:#569cd6;">fn </span><span>main() {
</span><span>    </span><span style="color:#569cd6;">let</span><span> person = Person {
</span><span>        name: </span><span style="color:#d69d85;">&quot;Alice&quot;</span><span>.into(),
</span><span>    };
</span><span>
</span><span>    </span><span style="color:#608b4e;">// `CanGreet` is automatically implemented for `Person`
</span><span>    person.greet();
</span><span>}
</span><span>
</span></code></pre>
</div>

            </div>
        </div>

        

    </main>

    
<footer>
    <small class="subtext" style="text-align: center;">
        <a href="https://maybevoid.com">MaybeVoid</a> © 2024
        <br />
        <a href="https://creativecommons.org/licenses/by-sa/4.0/?ref=chooser-v1" target="_blank" rel="license noopener noreferrer" style="display:inline-block;">
            CC BY-SA 4.0<img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/cc.svg?ref=chooser-v1" alt=""><img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/by.svg?ref=chooser-v1" alt=""><img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/sa.svg?ref=chooser-v1" alt="">
        </a>
    </small>
</footer>

</body>
<script>
    const scrollHandler = entries => {
        // Find the first entry which intersecting and ratio > 0.9 to highlight.
        let entry = entries.find(entry => {
            return entry.isIntersecting && entry.intersectionRatio > 0.9;
        });
        if (!entry) return;

        document.querySelectorAll(".toc a").forEach((item) => {
            item.classList.remove("active");
        });

        // let url = new URL(`#${entry.target.id}`);
        let link = document.querySelector(`.toc a[href$="${decodeURIComponent(`#${entry.target.id}`)}"]`)
        if (link) {
            link.classList.add("active");
            link.scrollIntoView({ behavior: "auto", block: "nearest" });
        }
    };
    // Set -100px root margin to improve highlight experience.
    const observer = new IntersectionObserver(scrollHandler, { threshold: 1 });
    let items = document.querySelectorAll('h1,h2,h3,h4,h5,h6');
    items.forEach(item => observer.observe(item));
</script>

</html>
